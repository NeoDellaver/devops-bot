{
  "linux": [
    {
      "title": "Load Average: что это и как интерпретировать в реальных системах",
      "content": "Дорогой друг, сегодня мы поговорим об одной из самых важных, но часто непонимаемых метрик в Linux — Load Average. Я помню, как сам начинал свой путь в мире системного администрирования, и эта метрика вызывала у меня больше вопросов, чем ответов. Поэтому я постараюсь объяснить всё максимально понятно, с примерами из реальной жизни и практическими советами, которые помогут вам чувствовать себя уверенно при работе с этой метрикой.\n\n## Почему Load Average так важен?\n\nПредставьте, что ваш сервер — это оживлённый ресторан. Гости (процессы) приходят, садятся за столы (ядра процессора) и заказывают блюда (выполняют задачи). Load Average — это не просто количество людей в ресторане, а показатель, который говорит нам о том, насколько ресторан загружен: сколько гостей уже обедают, а сколько стоит в очереди, ожидая места.\n\nМногие начинающие администраторы смотрят на Load Average как на процент использования CPU, но это серьезное заблуждение! Эта метрика гораздо глубже и информативнее, чем кажется на первый взгляд.\n\n## Что такое Load Average на самом деле?\n\nLoad Average — это среднее количество процессов, находящихся в состоянии выполнения (R) или ожидающих ресурсов (D) за определенные промежутки времени: 1, 5 и 15 минут. Эти три числа дают нам динамическую картину загруженности системы.\n\n- **Состояние R (running/runnable)**: процессы, которые либо сейчас используют CPU, либо стоят в очереди на использование CPU.\n- **Состояние D (uninterruptible sleep)**: процессы, которые ожидают завершения операций ввода-вывода (I/O), например, чтения с диска. Эти процессы не могут быть прерваны даже сигналом SIGKILL, что делает их особенно важными для анализа.\n\nВажно понимать, что Load Average не нормируется к количеству ядер процессора. Это абсолютное число. Поэтому значение 2.0 на одн"
    },
    {
      "title": "Swap: виртуальная память, swappiness и её влияние на производительность",
      "content": "Дорогой друг, сегодня мы поговорим о виртуальной памяти и механизме подкачки (swap) в Linux. Эта тема часто вызывает путаницу даже у опытных специалистов, но я постараюсь объяснить её максимально просто и понятно, как будто мы сидим за чашкой чая и обсуждаем тонкости работы операционных систем.\n\n## Что такое swap и зачем он нужен?\n\nПредставьте, что ваша оперативная память (RAM) — это рабочий стол программиста. Чем больше стол, тем больше документов и книг можно разместить перед собой для удобной работы. Но что происходит, когда стол переполняется? Правильно — приходится складывать ненужные в данный момент документы в ящик стола или даже в шкаф.\n\nSwap в Linux работает точно так же. Когда физической памяти не хватает для всех активных процессов, операционная система начинает перемещать редко используемые участки памяти из RAM на специальное место на диске, называемое swap-пространством. Это позволяет системе продолжать работу, даже когда физической памяти недостаточно.\n\nНо есть важный нюанс: диск работает намного медленнее, чем оперативная память. Если процессу понадобится доступ к данным, которые были перемещены в swap, система сначала должна прочитать их с диска и вернуть в RAM. Это может значительно замедлить работу приложения.\n\n## Как работает механизм подкачки?\n\nВ Linux подкачка управляется ядром через специальный параметр — `vm.swappiness`. Этот параметр принимает значения от 0 до 100 и определяет, насколько агрессивно ядро будет использовать swap-пространство.\n\nПо умолчанию значение `vm.swappiness` равно 60. Это означает, что ядро начнет активно использовать swap, когда свободной памяти останется примерно 40%. Для многих серверов это неоптимально!\n\nДавайте рассмотрим несколько практических примеров:\n\n1. **Сервер баз данных (PostgreSQL, MySQL)**: для таких серверов важна скорость доступа к данным. Если данные будут постоянно подкачиваться с диска, производительность упадет в разы. Поэтому для БД рекомендуется устанавливать `vm.swappiness=1`, что означает минимальное использование swap — ядро будет использовать его только в крайнем случае, когда памяти практически не осталось.\n\n2. **Веб-сервер с большим количеством соединений**: здесь можно позволить чуть более высокое значение (10-20), так как многие соединения могут быть неактивны в определенный момент времени.\n\n3. **Системы обработки данных (batch processing)**: для таких задач можно установить значение побольше (30-40), так как они часто используют память неравномерно, и временное перемещение части данных на диск не критично.\n\n## Как проверить использование swap?\n\nДля диагностики состояния виртуальной памяти в Linux есть несколько полезных команд:\n\n```\nfree -h\n```\nЭта команда покажет общую статистику по памяти и swap. Флаг `-h` делает вывод человекочитаемым (в GB, MB вместо байтов).\n\n```\nvmstat 1\n```\nЭта команда будет показывать статистику каждую секунду. Особенно важно следить за колонками `si` (swap in — данные, перемещенные из swap в RAM) и `so` (swap out — данные, перемещенные из RAM в swap). Если эти значения постоянно больше нуля, это серьезный повод для беспокойства.\n\n```\ncat /proc/sys/vm/swappiness\n```\nЭта команда покажет текущее значение swappiness.\n\n## Почему полностью отключать swap опасно?\n\nМногие администраторы, стремясь к максимальной производительности, полностью отключают swap. Но это может быть опасной практикой!\n\nПредставьте ситуацию: на вашем сервере внезапно возникает пиковая нагрузка, и всем процессам срочно требуется дополнительная память. Если swap отключен, операционная система не сможет расширить виртуальную память и будет вынуждена активировать OOM Killer (Out-Of-Memory Killer).\n\nOOM Killer — это механизм аварийного восстановления, который начинает принудительно завершать процессы, потребляющие больше всего памяти. Но он не всегда выбирает процессы правильно! Иногда он может убить критически важный сервис (например, вашу базу данных или веб-сервер), вместо менее важного фонового процесса.\n\nНаличие небольшого swap-пространства (даже размером с 10-20% от RAM) дает системе \"буфер безопасности\". В экстремальных ситуациях система сможет использовать swap кратковременно, чтобы избежать аварийного завершения процессов.\n\n## Swap в контейнерных средах\n\nВ Docker-контейнерах и Kubernetes ситуация с swap немного отличается. По умолчанию в большинстве Docker-образов swap отключен, так как управление памятью возлагается на cgroups (контрольные группы ядра Linux).\n\nНо важно понимать, что если контейнер исчерпает выделенную ему память, его процесс будет завершен с ошибкой OOM, и контейнер перезапустится (если настроен restart policy). Поэтому правильная настройка лимитов памяти для контейнеров критически важна.\n\n## Практические рекомендации\n\n1. **Для production-серверов с базами данных**:\n   - Установите `vm.swappiness=1`\n   - Создайте небольшой swap-файл (1-2GB даже для серверов с 64+ GB RAM)\n   ```
   sudo fallocate -l 2G /swapfile\n   sudo chmod 600 /swapfile\n   sudo mkswap /swapfile\n   sudo swapon /swapfile\n   ```\n   - Добавьте в `/etc/fstab` для постоянного включения:\n   ```\n   /swapfile none swap sw 0 0\n   ```\n   - Настройте `vm.overcommit_memory=2` для более строгого контроля выделения памяти\n\n2. **Для веб-серверов**:\n   - Установите `vm.swappiness=10`\n   - Можно создать swap-пространство размером с 25-50% от RAM\n\n3. **Для разработки и тестирования**:\n   - Значение по умолчанию (60) обычно приемлемо\n   - Size swap может быть равен размеру RAM или немного больше\n\n4. **Мониторинг**:\n   - Настройте алерты на использование swap больше 20%\n   - Следите за `si` и `so` в vmstat\n   - Используйте инструменты вроде Prometheus и Grafana для визуализации трендов\n\n## Распространенные мифы о swap\n\n1. **\"Swap — это плохо, его нужно всегда отключать\"**\n   Это неверно. Swap — это инструмент, который нужно правильно настраивать под конкретную нагрузку. Полное отключение может привести к неожиданным падениям сервисов.\n\n2. **\"Больше swap — всегда лучше\"**\n   Избыточное swap-пространство заставляет ядро слишком агрессивно использовать подкачку, что приводит к замедлению работы системы (эффект \"thrashing\").\n\n3. **\"SSD диски быстрые, поэтому можно использовать много swap\"**\n   Даже SSD диски на порядки медленнее RAM. Частое использование swap на SSD также сокращает срок его службы.\n\n## Как изменить swappiness временно и постоянно\n\nВременное изменение (до перезагрузки):\n```\nsudo sysctl vm.swappiness=1\n```\n\nПостоянное изменение:\n```\necho 'vm.swappiness=1' | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n```\n\n## Заключение\n\nДорогой друг, помните, что нет универсальных настроек, подходящих для всех ситуаций. Ваша задача как DevOps-инженера — понять специфику вашей нагрузки и настроить параметры системы соответственно.\n\nНе бойтесь экспериментировать, но всегда делайте это постепенно и с тщательным мониторингом результатов. Начните с рекомендованных значений для вашего типа нагрузки, а затем корректируйте их в зависимости от поведения системы в реальных условиях.\n\nЕсли у вас остались вопросы или нужна помощь с конкретной ситуацией — не стесняйтесь задавать их в комментариях. Я всегда рад помочь!\n\nПомните: хороший инженер не тот, кто знает все ответы, а тот, кто умеет находить правильные решения для каждой уникальной задачи. Удачи в вашем пути освоения Linux!\n\nP.S. Если вы нашли эту статью полезной, поделитесь ею с коллегами — вместе мы делаем мир технологий немного понятнее и дружелюбнее!",
      "questions": [
        {
          "text": "Почему полностью отключать swap может быть опасно?",
          "options": ["Система не загрузится", "При нехватке памяти OOM Killer может убить важный процесс", "Диск перестанет работать", "Это нарушает POSIX"],
          "correct": 1
        },
        {
          "text": "Какой параметр ядра регулирует агрессивность использования swap?",
          "options": ["vm.overcommit_memory", "vm.dirty_ratio", "vm.swappiness", "fs.file-max"],
          "correct": 2
        }
      ]
    },
    {
      "title": "Процессы, файл /proc и статусы (R, S, D, Z): взгляд изнутри ядра",
      "content": "Здравствуй, дорогой друг! Сегодня мы совершим небольшое путешествие внутрь ядра Linux, чтобы понять, как устроены процессы и как с ними работать. Это важная тема, потому что без понимания процессов невозможно эффективно управлять системой, диагностировать проблемы или оптимизировать производительность. Я постараюсь объяснить всё максимально доступно, с примерами и практическими советами.\n\n## Что такое процесс?\n\nНачнем с самого главного: что такое процесс в Linux? Многие думают, что процесс — это просто запущенная программа, но это неполное определение.\n\nВ Linux процесс — это экземпляр выполняющейся программы, имеющий собственное адресное пространство, системные ресурсы (открытые файлы, сокеты) и состояние выполнения. Каждый процесс имеет уникальный идентификатор (PID), и когда вы запускаете программу, ядро создает для нее новый процесс.\n\nНо самое удивительное, что в Linux даже потоки реализованы как процессы! Да-да, то, что в других операционных системах называют потоками (threads), в Linux — это просто процессы, разделяющие адресное пространство с родительским процессом. Это называется моделью \"один-к-одному\" (1:1 threading model).\n\n## Файловая система /proc — окно в мир процессов\n\nОдной из самых гениальных идей в Unix-системах является виртуальная файловая система /proc. Она существует только в памяти и предоставляет доступ к информации о работающих процессах и параметрах ядра через привычный интерфейс файловой системы.\n\nКогда вы заходите в директорию `/proc/1234`, где 1234 — это PID процесса, вы видите множество файлов и директорий, каждый из которых содержит определенную информацию о процессе:\n\n- `status` — общая информация о процессе: имя, состояние, память, владельца\n- `cmdline` — командная строка, с которой был запущен процесс\n- `environ` — переменные окружения процесса\n- `fd/` — директория с файловыми дескрипторами (открытыми файлами)\n- `maps` — информация об отображенных в память файлах (библиотеках)\n\nПочему это так важно? Потому что вы можете получить всю необходимую информацию о процессе, используя простые команды вроде `cat /proc/1234/status`, без необходимости в специальных инструментах!\n\n## Статусы процессов: R, S, D, Z, T\n\nТеперь перейдем к самому интересному — статусам процессов. В Linux процесс может находиться в различных состояниях, которые определяют, что с ним происходит в данный момент. Давайте разберем каждый статус подробно.\n\n### Состояние R (Running/Runnable)\n\nПроцесс в состоянии R находится либо на выполнении на CPU, либо в очереди планировщика, готовый к выполнению. Это нормальное состояние для активных процессов.\n\n**Пример:** Ваш веб-сервер обрабатывает запросы — большую часть времени он находится в состоянии R.\n\n### Состояние S (Sleeping)\n\nПроцесс в состоянии S ожидает какого-то события: ввода от пользователя, данных от сети, сигнала от другого процесса. Это прерываемое состояние ожидания (interruptible sleep), что означает, что процесс можно прервать сигналом.\n\n**Пример:** Телнет-клиент ждет, пока пользователь введет команду.\n\n### Состояние D (Uninterruptible Sleep)\n\nЭто особое состояние, которое часто вызывает проблемы. Процесс в состоянии D ожидает завершения операции ввода-вывода (I/O), обычно чтения или записи на диск. Особенность этого состояния в том, что его нельзя прервать никаким сигналом, включая SIGKILL!\n\nПочему так сделано? Потому что если прервать процесс во время операции ввода-вывода, это может привести к повреждению данных. Ядро гарантирует, что операция I/O будет завершена корректно.\n\n**Пример:** Сервер баз данных выполняет запись на диск. Если диск медленный или завис, процесс будет находиться в состоянии D до завершения операции.\n\n### Состояние Z (Zombie)\n\nПроцесс-зомби — это завершившийся процесс, чей родитель еще не вызвал системный вызов `wait()` для получения кода завершения. Зомби не потребляют CPU или RAM (за исключением записи в таблице процессов), но они занимают PID.\n\n**Почему зомби опасны?** Если зомби накапливаются (например, из-за ошибки в родительском процессе), они могут исчерпать все доступные PID в системе.\n\n### Состояние T (Stopped)\n\nПроцесс в состоянии T приостановлен. Это может произойти по нескольким причинам:\n\n- Пользователь нажал Ctrl+Z в терминале\n- Процесс получил сигнал SIGSTOP, SIGTSTP или SIGTTIN\n\nПриостановленный процесс можно продолжить выполнение с помощью `fg`, `bg` или посылая сигнал SIGCONT.\n\n## Практическое использование: диагностика проблем\n\nТеперь, когда мы знаем о различных состояниях процессов, давайте рассмотрим, как это применять на практике.\n\n### Диагностика высокой нагрузки\n\nКогда в системе высокий load average, важно понять, какие процессы его создают. Команда `top` покажет вам процессы и их статусы в колонке `S` (State):\n\n```\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n1234 mysql    20   0 1500000 200000   5000 R  95.0 10.0   2:10.34 mysqld\n5678 nginx    20   0  250000  50000   2000 D   2.0  2.5   0:23.45 nginx\n```\n\nЗдесь видно, что MySQL активно использует CPU (состояние R), а nginx находится в состоянии D (ожидает I/O).\n\n### Диагностика зомби-процессов\n\nЧтобы найти зомби-процессы, используйте команду:\n\n```\nps aux | grep 'Z'\n```\n\nИли в формате `top`:\n\n```\ntop -c -p $(ps -A -ostat,pid | grep -e '[zZ]' | awk '{print $2}' | tr '\\n' ',' | sed 's/,$//')\n```\n\n### Что делать с процессами в состоянии D?\n\nПроцессы в состоянии D — одна из самых сложных проблем в диагностике. Поскольку их нельзя убить сигналом SIGKILL, остается только ждать завершения операции I/O или перезагружать систему.\n\n**Совет:** Если процесс постоянно находится в состоянии D, проверьте:\n\n1. Состояние дисковой подсистемы (используйте `iostat -x 1`, `dmesg | grep -i error`)\n2. Сетевые файловые системы (NFS, CIFS) — возможно, сервер недоступен\n3. Драйверы устройств — попробуйте обновить их\n\n### Диагностика с помощью /proc\n\nПредставьте, что в вашей системе не установлены стандартные утилиты вроде `ps` или `top`, но нужно узнать, какие процессы используют больше всего памяти. Что делать?\n\nОтвет: анализировать файловую систему /proc напрямую!\n\nВот простой скрипт на bash, который покажет топ-10 процессов по использованию памяти:\n\n```bash\n#!/bin/bash\n\nprintf \"%-8s %-20s %s\\n\" \"PID\" \"COMMAND\" \"RSS (KB)\"\nfor pid in /proc/[0-9]*; do\n    pid=${pid##*/}\n    cmd=$(cat /proc/$pid/cmdline 2>/dev/null | tr '\\0' ' ')\n    rss=$(awk '/Rss/ {sum += $2} END {print sum}' /proc/$pid/smaps 2>/dev/null)\n    [[ $rss ]] && printf \"%-8d %-20s %s\\n\" \"$pid\" \"${cmd:0:20}\" \"$rss\"\ndone | sort -k3 -nr | head -10\n```\n\nЭтот скрипт работает даже на самых минимальных системах, потому что использует только возможности ядра Linux через /proc.\n\n## PID 1 — особый процесс\n\nОсобое место в мире процессов Linux занимает процесс с PID 1. Это первый процесс, запускаемый ядром при загрузке системы. Исторически это был SysVinit, сегодня это чаще всего systemd.\n\nPID 1 имеет несколько уникальных свойств:\n\n1. Если PID 1 завершается, ядро паникует и перезагружает систему\n2. PID 1 \"усыновляет\" сиротские процессы (те, чей родитель завершился)\n3. В контейнерах PID 1 имеет особое значение — если он не обрабатывает сигналы правильно, контейнер может работать некорректно\n\n## Процессы-сироты и зомби: взаимосвязь\n\nВажно понимать разницу между процессами-сиротами и зомби:\n\n- **Процесс-сирота** — это процесс, чей родительский процесс завершился. Сирота автоматически \"усыновляется\" PID 1, который периодически вызывает `wait()` для завершенных дочерних процессов.\n\n- **Зомби-процесс** — это процесс, который завершил выполнение, но чей родитель еще не вызвал `wait()`. Зомби существует только в таблице процессов ядра.\n\nКлючевой момент: сирота становится зомби только если его новый родитель (PID 1) не вызывает `wait()` для него. Но современные init-системы (systemd, upstart) отлично справляются с этой задачей.\n\n## Практические советы для DevOps\n\n1. **Всегда проверяйте статусы процессов при диагностике проблем**\n   - Высокий load average с множеством процессов в состоянии R: не хватает CPU\n   - Высокий load average с множеством процессов в состоянии D: проблемы с диском или сетевой файловой системой\n   - Зомби-процессы: ошибка в родительском приложении\n\n2. **Учитывайте особенности PID 1 в контейнерах**\n   Если вы создаете Docker-образ, всегда используйте init-систему (tini, dumb-init) в качестве PID 1, особенно если контейнер запускает несколько процессов. Это предотвратит появление зомби.\n\n3. **Используйте /proc для глубокой диагностики**\n   Когда стандартные инструменты не показывают полной картины, прямой анализ /proc может дать ответы на сложные вопросы о состоянии системы.\n\n4. **Пишите надежные приложения**\n   Если вы разработчик, убедитесь, что ваше приложение правильно обрабатывает сигналы, особенно SIGCHLD для ожидания завершения дочерних процессов.\n\n## Заключение\n\nДорогой друг, понимание процессов и их состояний — это не просто академическое знание, а практический навык, который поможет вам стать более эффективным DevOps-инженером. Знание о том, как устроены процессы под капотом Linux, даст вам уверенность в диагностике самых сложных проблем производительности и стабильности.\n\nПомните, что каждая система уникальна, и нет универсальных рецептов. Ваша задача — наблюдать за поведением процессов в вашей конкретной среде, анализировать закономерности и делать выводы.\n\nЕсли у вас есть вопросы или вы столкнулись с интересным кейсом, связанным с процессами в Linux, поделитесь им в комментариях — вместе мы сможем разобраться в любой ситуации!\n\nНадеюсь, эта статья помогла вам лучше понять мир процессов Linux. До новых встреч у следующей темы!\n\nP.S. Не забывайте, что знания ценны только тогда, когда ими делятся. Если статья была полезна — поделитесь ею с коллегами!",
      "questions": [
        {
          "text": "Какой статус процесса означает «uninterruptible sleep»?",
          "options": ["R", "S", "D", "Z"],
          "correct": 2
        },
        {
          "text": "Где хранится информация о процессах в Linux?",
          "options": ["/etc/passwd", "/var/log", "/proc", "/sys"],
          "correct": 2
        }
      ]
    },
    {
      "title": "Зомби и сироты: когда процессы не умирают до конца",
      "content": "Дорогой друг, сегодня мы поговорим о двух загадочных явлениях в мире Linux — зомби-процессах и процессах-сиротах. Эти понятия часто путают даже опытные системные администраторы, но на самом деле все довольно просто, если разобраться в деталях. Я расскажу об этой теме так, как объяснял бы ее студенту на лекции — с примерами, аналогиями и практическими советами.\n\n## Жизненный цикл процесса\n\nПрежде чем перейти к зомби и сиротам, давайте вспомним, как вообще работает жизненный цикл процесса в Linux. Это поможет нам лучше понять, где появляются \"проблемные\" состояния.\n\nКогда вы запускаете программу в Linux, происходит следующее:\n\n1. **Создание процесса** — родительский процесс вызывает системные вызовы `fork()` и `exec()` для создания нового процесса\n2. **Выполнение** — процесс работает, потребляя ресурсы системы\n3. **Завершение** — процесс завершает свою работу и вызывает `exit()`, возвращая код завершения\n4. **Освобождение ресурсов** — родительский процесс вызывает `wait()` или `waitpid()`, чтобы получить код завершения и освободить ресурсы\n\nИменно на этапе 4 и возникают зомби-процессы, если родительский процесс не выполняет свою работу должным образом.\n\n## Что такое зомби-процесс?\n\nПредставьте, что вы заказали пиццу через приложение. Пиццерия получила заказ (процесс запущен), приготовила пиццу (процесс выполнился), доставила ее вам (процесс завершил работу), но вы так и не подтвердили получение заказа в приложении (родитель не вызвал `wait()`).\n\nВот в этом состоянии и находится зомби-процесс — он завершил свою работу, но его запись в таблице процессов ядра все еще существует, потому что родительский процесс не \"собрал\" информацию о его завершении.\n\n**Важно:** зомби-процессы не потребляют ресурсы CPU и памяти (RAM)! Они занимают только запись в таблице процессов и PID. Поэтому один или два зомби не нанесут вреда системе, но если их накапливается много, это может привести к исчерпанию PID.\n\n## Что такое процесс-сирота?\n\nПроцесс-сирота — это процесс, чей родительский процесс завершил работу раньше него самого. Например:\n\n1. Вы запускаете процесс в терминале (родитель — bash)\n2. Вы закрываете терминал, не дождавшись завершения процесса\n3. Процесс становится сиротой\n\nВ отличие от зомби, процессы-сироты продолжают работать нормально. Просто их \"родитель\" меняется — они передаются в управление PID 1 (init-процессу).\n\n## PID 1 — приемный родитель\n\nВот где Linux проявляет свою заботу о процессах! Когда процесс становится сиротой, ядро передает его под управление специального процесса с PID 1 — init-процесса (это может быть systemd, sysvinit или другой init-демон).\n\nInit-процесс имеет особую обязанность: он периодически вызывает `wait()` для всех своих дочерних процессов. Благодаря этому:\n\n1. Сироты не становятся зомби (init-процесс всегда \"собирает\" информацию о завершении)\n2. Система не заполняется зомби-процессами\n\nСовременные init-системы, такие как systemd, делают это очень эффективно.\n\n## Почему происходят зомби-процессы?\n\nЗомби появляются, когда родительский процесс:\n\n1. **Игнорирует сигнал SIGCHLD** — это сигнал, который ядро посылает родителю, когда дочерний процесс завершается\n2. **Не вызывает `wait()`** после завершения дочернего процесса\n3. **Умирает сам**, не дождавшись завершения детей (но в этом случае дети становятся сиротами и передаются PID 1)\n\nЧаще всего это происходит из-за ошибок в программировании. Например, разработчик написал программу, которая создает дочерние процессы, но забыл обработать их завершение.\n\n## Как обнаружить зомби и сирот?\n\n### Поиск зомби-процессов\n\nСамый простой способ найти зомби — использовать команду `ps`:\n\n```bash\nps aux | grep 'Z'\n```\n\nИли более точный вариант:\n\n```bash\nps -eo stat,pid,ppid,cmd | grep '^Z'\n```\n\nВ выводе вы увидите процессы со статусом `Z` или `Z+` (плюс означает, что процесс в группе терминала).\n\n### Поиск процессов-сирот\n\nПроцессы-сироты не имеют особого статуса, но их можно найти по PPID (Parent PID), равному 1:\n\n```bash\nps -eo pid,ppid,cmd | awk '$2 == 1 && $1 != 1'\n```\n\nЭта команда покажет все процессы, чей родительский PID равен 1 (кроме самого init-процесса).\n\n## Способы борьбы с зомби-процессами\n\n### 1. Исправить родительский процесс\n\nСамый правильный способ — исправить программу, которая создает зомби. Разработчик должен:\n\n- Обрабатывать сигнал SIGCHLD\n- Вызывать `wait()` или `waitpid()`\n\nПример обработки на C:\n\n```c\n#include <signal.h>\n#include <sys/wait.h>\n\nvoid sigchld_handler(int sig) {\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n}\n\nint main() {\n    signal(SIGCHLD, sigchld_handler);\n    // основная логика программы\n}\n```\n\n### 2. Перезапустить родительский процесс\n\nЕсли исправление невозможно, можно перезапустить родительский процесс. При этом:\n\n1. Все дочерние процессы станут сиротами\n2. Они будут переданы под управление PID 1\n3. PID 1 выполнит `wait()` для завершившихся детей, убрав зомби\n\n### 3. Убить родительский процесс\n\nВ крайнем случае, если родительский процесс не критичен, можно завершить его принудительно:\n\n```bash\nkill -9 <PPID_зомби>\n```\n\nПосле этого зомби-процессы станут сиротами и будут автоматически убраны PID 1.\n\n**Важно:** нельзя убить зомби-процесс напрямую командой `kill -9`, потому что он уже завершен! Убивать нужно именно родителя.\n\n## Особенности в Docker-контейнерах\n\nВ контейнерах Docker проблема зомби становится особенно актуальной. Почему?\n\nПредставьте Docker-контейнер, в котором запущен только один процесс — например, nginx. В этом случае nginx становится PID 1 в контейнере. Но nginx не предназначен быть init-системой — он не обрабатывает сигнал SIGCHLD и не вызывает `wait()` для дочерних процессов!\n\nЭто приводит к тому, что:\n\n1. Любые дочерние процессы, созданные приложением внутри контейнера, останутся в состоянии зомби после завершения\n2. Со временем зомби накапливаются, занимая все PID в контейнере\n3. В итоге контейнер перестает создавать новые процессы\n\n## Решение для Docker-контейнеров: tini\n\nЧтобы решить эту проблему, Docker предоставляет встроенный init-процесс, который можно включить флагом `--init`:\n\n```bash\ndocker run --init my-nginx-image\n```\n\nИли указать в Dockerfile:\n\n```dockerfile\n# Использовать tini как init-процесс\nENTRYPOINT [\"/usr/bin/tini\", \"--\"]\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\nTini — это специальная миниатюрная init-система, созданная для контейнеров. Она:\n\n1. Становится PID 1 в контейнере\n2. Обрабатывает сигналы (особенно SIGCHLD)\n3. Автоматически \"собирает\" зомби-процессы\n4. Передает сигналы основному приложению\n\n## Практические советы для DevOps\n\n1. **Всегда используйте `--init` в Docker-контейнерах**, особенно если:\n   - Контейнер запускает скрипты вроде bash\n   - Приложение создает дочерние процессы\n   - Вы не уверены, поддерживает ли приложение правильную обработку сигналов\n\n2. **Мониторьте зомби-процессы** в production-системах:\n   ```bash\n   # Алерт при наличии зомби\n   if [ $(ps -eo stat | grep -c '^Z') -gt 0 ]; then\n       echo \"ALERT: обнаружены зомби-процессы!\" | mail -s \"Zombie Alert\" admin@example.com\n   fi\n   ```\n\n3. **Проверяйте логи приложений** на предмет ошибок, связанных с созданием процессов, если замечаете зомби.\n\n4. **Используйте systemd в виртуальных машинах и bare-metal серверах** — современные init-системы отлично справляются с управлением процессами и сбором зомби.\n\n5. **Для критически важных сервисов** настройте автоматический перезапуск через systemd или supervisor, чтобы сбросить накопившуюся \"грязь\" вроде зомби.\n\n## Историческая справка\n\nПонятие \"зомби-процесс\" появилось еще в ранних версиях Unix в 1970-х годах. В те времена разработчики сознательно выбрали модель, при которой родитель должен явно подтверждать завершение детей, потому что это позволяло:\n\n1. Передавать код возврата от ребенка к родителю\n2. Избегать ситуаций, когда важные данные терялись бы при автоматическом удалении завершенного процесса\n3. Сохранять целостность системы в условиях ограниченных ресурсов\n\nСегодня, спустя 50 лет, эта модель по-прежнему остается одной из ключевых особенностей Unix-подобных систем.\n\n## Заключение\n\nДорогой друг, я надеюсь, что теперь зомби-процессы и процессы-сироты перестали быть для вас загадкой. Помните, что эти понятия — не просто технические детали, а важный аспект стабильности и надежности системы.\n\nГлавное правило: зомби не опасны по одиночке, но их накопление сигнализирует о проблеме в архитектуре или коде приложения. Вместо того чтобы просто убивать их, лучше найти и устранить корневую причину.\n\nЕсли вы работаете с контейнерами, всегда используйте init-процесс (tini) — это сэкономит вам часы отладки и стресс в будущем.\n\nА если у вас есть вопросы или интересные кейсы, связанные со зомби-процессами — делитесь в комментариях! Вместе мы сделаем системное администрирование более понятным и предсказуемым.\n\nДо новых встреч на страницах нашего блога!\n\nP.S. Помните: даже самые опытные инженеры когда-то начинали с вопроса \"а что это за Z в колонке STAT?\" Не бойтесь задавать вопросы и копать глубже — именно так рождаются настоящие эксперты.",
      "questions": [
        {
          "text": "Что такое зомби-процесс?",
          "options": ["Процесс, потребляющий 100% CPU", "Завершённый процесс, чей родитель не вызвал wait()", "Процесс без родителя", "Процесс в состоянии D"],
          "correct": 1
        },
        {
          "text": "Почему в Docker-контейнерах часто возникают зомби?",
          "options": ["Docker блокирует сигналы", "PID 1 в контейнере не обрабатывает SIGCHLD", "Ядро не поддерживает зомби в namespace", "Контейнеры не имеют /proc"],
          "correct": 1
        }
      ]
    },
    {
      "title": "Файловые системы в Linux: ext4, XFS, Btrfs и особенности работы",
      "content": "Дорогой друг, сегодня мы поговорим о файловых системах в Linux. Эта тема многогранна и глубока, но я постараюсь объяснить ее так, чтобы было понятно даже тем, кто впервые сталкивается с Linux. Мы рассмотрим основные типы файловых систем, их особенности, преимущества и недостатки, а также практические советы по выбору и работе с ними.\n\n## Что такое файловая система?\n\nПредставьте, что ваш жесткий диск — это огромный склад. Без системы хранения все коробки (файлы) были бы свалены в кучу, и найти нужную было бы невозможно. Файловая система — это как раз та система каталогов, полок и ярлыков, которая позволяет организовать хранение данных на диске.\n\nВ Linux файловая система определяет:\n- Как хранятся имена файлов\n- Как хранятся данные файлов\n- Как хранится метаинформация (права доступа, владелец, время изменения)\n- Как организованы директории\n- Как обеспечивается целостность данных при сбоях\n\n## Основные файловые системы в Linux\n\nВ современных Linux-дистрибутивах чаще всего встречаются три файловые системы: ext4, XFS и Btrfs. Рассмотрим каждую подробнее.\n\n### ext4 (Fourth Extended Filesystem)\n\next4 — это эволюция самой популярной файловой системы Linux. Она была представлена в 2008 году как преемник ext3. ext4 является журналируемой файловой системой, что означает, что перед изменением данных на диске система сначала записывает операцию в журнал (journal). Это позволяет восстановить целостность файловой системы после сбоя питания или аварийного выключения.\n\n**Ключевые особенности ext4:**\n- Поддержка файлов размером до 16 ТБ и разделов до 1 ЭБ (экзабайт)\n- Улучшенная производительность по сравнению с ext3 благодаря отложенному выделению блоков (delayed allocation)\n- Поддержка экстентов (extents) вместо прямых/косвенных блоков, что уменьшает фрагментацию\n- Быстрая проверка файловой системы (e2fsck) за счет отмеченных незанятых блоков\n- Поддержка динамического расширения (увеличения размера)\n\n**Когда выбирать ext4:**\n- Для обычных серверов и рабочих станций\n- Для систем с большим количеством мелких файлов\n- Когда важна совместимость и стабильность\n- Для флеш-накопителей (USB, SSD)\n\n### XFS\n\nXFS изначально была разработана компанией Silicon Graphics (SGI) для их высокопроизводительных Unix-систем в 1990-х годах. В 2001 году она была портирована в Linux и с тех пор активно развивается.\n\n**Ключевые особенности XFS:**\n- Оптимизирована для работы с большими файлами и высокими скоростями записи/чтения\n- Использует B+ деревья для организации метаданных, что обеспечивает отличную производительность даже с миллионами файлов\n- Поддержка файлов размером до 8 ЭБ и разделов до 16 ЭБ\n- Мгновенная дефрагментация в режиме онлайн\n- Отложенное обновление метаданных улучшает производительность\n\n**Когда выбирать XFS:**\n- Для файловых серверов с большими файлами (видео, базы данных)\n- Для систем с высокой нагрузкой на запись (логи, потоковая запись)\n- Для больших хранилищ данных\n- Когда важна производительность при работе с большими файлами\n\n### Btrfs (B-tree File System)\n\nBtrfs (произносится \"бетер-эф-эс\" или \"бифтер\") — относительно молодая файловая система, разработка которой началась в 2007 году. Ее часто называют \"файловая система следующего поколения\" для Linux.\n\n**Ключевые особенности Btrfs:**\n- Copy-on-Write (CoW) архитектура — при изменении данных создаются новые копии блоков вместо перезаписи старых\n- Поддержка снапшотов — мгновенное создание точных копий файловой системы без остановки сервисов\n- Встроенная система RAID (0, 1, 5, 6, 10)\n- Сжатие данных на лету\n- Дедупликация (уменьшение дубликатов данных)\n- Динамическое изменение размера и добавление дисков\n- Контрольные суммы для защиты от повреждения данных (bit rot)\n\n**Когда выбирать Btrfs:**\n- Для систем, где важна целостность данных\n- Когда необходимы частые снапшоты (резервное копирование, откаты)\n- Для домашних медиа-серверов\n- В тестовых средах (пока не рекомендуется для production-баз данных)\n\n## Понимание inodes\n\nОдна из самых важных концепций, которую нужно понять при работе с файловыми системами Linux, — это inodes. Многие новички сталкиваются с проблемой \"no space left on device\" при наличии свободного места на диске. Причина часто кроется именно в inodes.\n\n**Что такое inode?**\n\nInode (information node) — это структура данных в файловой системе, которая хранит всю метаинформацию о файле, кроме его имени и содержимого. В inode содержится:\n- Права доступа\n- Владелец и группа\n- Размер файла\n- Временные метки (создание, изменение, доступ)\n- Указатели на блоки данных на диске\n\n**Где хранится имя файла?**\n\nВажно понять, что имя файла не хранится в inode! Имена файлов хранятся в директориях. Директория в Linux — это специальный файл, который содержит список имен файлов и соответствующих им inode номеров.\n\nЭто объясняет, почему возможны жесткие ссылки (hard links) — несколько имен могут указывать на один и тот же inode, то есть на одни и те же данные на диске.\n\n**Проблема исчерпания inodes**\n\nВ файловых системах ext2/ext3/ext4 количество inodes фиксируется при создании файловой системы. Если вы создаете ФС с большим количеством мелких файлов (например, почтовый сервер или кэш веб-сервера), можно исчерпать все inodes, даже если на диске еще много свободного места.\n\nПроверить использование inodes можно командой:\n\n```bash\ndf -i\n```\n\nXFS и Btrfs поддерживают динамическое выделение inodes, поэтому эта проблема для них менее актуальна.\n\n## Жесткие и символические ссылки\n\nВ Linux существует два типа ссылок на файлы: жесткие (hard links) и символические (symbolic links).\n\n**Жесткая ссылка (hard link)**\n- Указывает непосредственно на inode файла\n- Все жесткие ссылки равноправны — нет \"оригинала\" и \"копии\"\n- Удаление одной жесткой ссылки не влияет на доступность данных через другие ссылки\n- Жесткие ссылки не могут пересекать файловые системы\n- Жесткие ссылки не могут указывать на директории (только на файлы)\n\nСоздание жесткой ссылки:\n```bash\nln file.txt hardlink.txt\n```\n\n**Символическая ссылка (symbolic link или symlink)**\n- Это отдельный файл, который содержит путь к целевому файлу\n- Может пересекать файловые системы\n- Может указывать на директории\n- Если целевой файл удален, символическая ссылка становится \"битой\"\n- Символические ссылки имеют свои права доступа (обычно 777)\n\nСоздание символической ссылки:\n```bash\nln -s /path/to/file.txt symlink.txt\n```\n\n## Практические советы по работе с файловыми системами\n\n### 1. Как выбрать файловую систему?\n\n- **ext4**: Универсальный выбор для большинства задач. Стабильна, хорошо поддерживается, предсказуема.\n- **XFS**: Выбирайте для работы с большими файлами и высокой нагрузкой на запись. Отлично подходит для баз данных PostgreSQL, MySQL.\n- **Btrfs**: Используйте для домашних серверов, когда нужны снапшоты и сжатие. Пока избегайте для критически важных production-баз данных.\n\n### 2. Мониторинг состояния файловых систем\n\nРегулярно проверяйте состояние файловых систем:\n\n```bash\n# Свободное место и inodes\ndf -hT    # Показать типы ФС и свободное место\ndf -i     # Показать использование inodes\n\n# Размер директорий\ndu -sh /var/log/*    # Показать размеры поддиректорий в /var/log\n\n# Состояние файловой системы ext4\nsudo tune2fs -l /dev/sda1 | grep -E \"Block count|Reserved block count|Free blocks\"\n\n# Состояние XFS\nxfs_info /mount/point\n```\n\n### 3. Устранение распространенных проблем\n\n**Проблема: \"No space left on device\" при наличии свободного места**\n\nШаги диагностики:\n1. Проверьте использование inodes: `df -i`\n2. Проверьте, не удерживает ли процесс удаленный файл: `lsof +L1`\n3. Проверьте зарезервированное место для root: `sudo tune2fs -l /dev/sda1 | grep 'Reserved'`\n4. Проверьте пользовательские квоты: `quota -u username`\n\n**Проблема: Файловая система доступна только для чтения**\n\nЭто часто случается после сбоя или при обнаружении ошибок:\n1. Проверьте журналы: `dmesg | grep -i error`\n2. Размонтируйте ФС и проверьте целостность: `sudo umount /dev/sda1 && sudo fsck /dev/sda1`\n3. Если ФС смонтирована в режиме только для чтения из-за ошибок, ее нужно размонтировать и проверить\n\n### 4. Советы по оптимизации\n\n- **Для ext4**:\n  ```bash\n  # Уменьшить резервное место для root (с 5% до 1%)\n  sudo tune2fs -m 1 /dev/sda1\n  \n  # Отключить обновление времени доступа (noatime)\n  mount -o remount,noatime /mount/point\n  ```\n\n- **Для XFS**:\n  ```bash\n  # Включить отложенную запись метаданных\n  mount -o remount,logbsize=256k /mount/point\n  ```\n\n- **Для Btrfs**:\n  ```bash\n  # Включить сжатие при монтировании\n  mount -o remount,compress=zstd /mount/point\n  \n  # Создать снапшот\n  sudo btrfs subvolume snapshot /data /data/snapshot-2024-01-01\n  ```\n\n## Работа с файловыми системами в облаке\n\nВ облачных средах (AWS, GCP, Azure) часто используются сетевые файловые системы (EBS, EFS, Azure Files). Особенности работы с ними:\n\n1. **Более высокая латентность** по сравнению с локальными дисками\n2. **Ограничения IOPS** — количество операций ввода-вывода в секунду\n3. **Стоимость** зависит от объема данных и количества операций\n4. **Рекомендации**:\n   - Для баз данных используйте SSD-тома с гарантированными IOPS\n   - Для shared storage (веб-серверы) используйте сетевые ФС типа NFS\n   - Для архивных данных используйте объектное хранилище (S3) вместо файловых систем\n\n## Будущее файловых систем\n\nLinux постоянно развивается, и на горизонте видны новые файловые системы:\n\n- **F2FS** (Flash-Friendly File System) — оптимизирована для флеш-памяти (SSD, USB)\n- **ZFS** — мощная файловая система с поддержкой пулов, снапшотов и дедупликации (изначально для Solaris, теперь в Linux через модули)\n- **EROFS** (Enhanced Read-Only File System) — оптимизирована для read-only систем (контейнеры, embedded)\n\n## Заключение\n\nДорогой друг, я надеюсь, что эта статья помогла вам разобраться в мире файловых систем Linux. Помните, что выбор правильной файловой системы — это не просто техническое решение, а важный шаг в обеспечении надежности и производительности вашей системы.\n\nНачните с ext4 для большинства задач — это безопасный выбор. Если вам нужны особые возможности (снапшоты, работа с большими файлами), изучите XFS или Btrfs более подробно.\n\nА если у вас есть вопросы или интересный опыт работы с файловыми системами — поделитесь в комментариях! Вместе мы делаем знания о Linux более доступными и понятными.\n\nДо новых встреч на страницах нашего блога!\n\nP.S. Не забывайте делать резервные копии! Независимо от того, насколько надежна ваша файловая система, данные слишком ценны, чтобы рисковать их потерей.",
      "questions": [
        {
          "text": "При создании файла система возвращает ошибку 'no space left on device', но df показывает свободное место. В чём причина?",
          "options": ["Сломан диск", "Закончились inodes", "Нет прав на запись", "ФС не смонтирована"],
          "correct": 1
        },
        {
          "text": "Где хранится информация об именах файлов?",
          "options": ["В inode", "В суперблоке", "В директории", "В журнале ФС"],
          "correct": 2
        }
      ]
    },
    {
      "title": "Жёсткие и символьные ссылки: различия, применение и ограничения",
      "content": "Здравствуй, дорогой друг! Сегодня мы поговорим об одной из самых полезных, но часто непонимаемых возможностей Linux — ссылках на файлы. Многие администраторы и разработчики используют их постоянно, но не всегда понимают, как они работают изнутри. Я постараюсь объяснить эту тему максимально понятно, с примерами из реальной практики и практическими советами, которые помогут вам использовать ссылки эффективно и безопасно.\n\n## Историческая справка\n\nПеред тем как погрузиться в технические детали, давайте немного истории. Ссылки появились в Unix еще в 1970-х годах, когда Кен Томпсон и Деннис Ритчи разрабатывали первую версию операционной системы. Они столкнулись с проблемой: как эффективно организовать хранение файлов, особенно когда одни и те же данные нужны в разных местах файловой системы.\n\nИх решение было гениально в своей простоте — вместо дублирования данных создавать \"указатели\" на существующие файлы. Так появились жесткие ссылки (hard links), а позже — символьные ссылки (symbolic links), которые добавили больше гибкости.\n\n## Что такое ссылка?\n\nВ Linux файл состоит из двух основных частей:\n1. **Содержимое файла** — данные, которые хранятся на диске\n2. **Метаданные файла** — информация о файле (права доступа, владелец, размер, временные метки), которые хранятся в специальной структуре, называемой **inode**\n\nСсылка — это механизм для создания дополнительных имен (путей) к существующему файлу. Но в зависимости от типа ссылки, она работает по-разному.\n\n## Жесткие ссылки (Hard Links)\n\n### Как работают жесткие ссылки\n\nКогда вы создаете файл в Linux, система:\n1. Выделяет место на диске для данных файла\n2. Создает запись в inode с метаданными файла\n3. Создает запись в директории, связывающую имя файла с номером inode\n\n**Жесткая ссылка** — это дополнительная запись в директории, которая указывает на тот же inode, что и исходный файл. Это означает, что:\n- Обе ссылки равноправны — нет \"оригинала\" и \"копии\"\n- Удаление одной ссылки не влияет на доступность данных через другую ссылку\n- Данные удаляются с диска только когда удаляется последняя ссылка на inode\n\n### Создание жесткой ссылки\n\n```bash\n# Создать жесткую ссылку\nln исходный_файл жесткая_ссылка\n\n# Пример\nln document.txt copy.txt\n```\n\n### Просмотр жестких ссылок\n\n```bash\n# Показать inode файла\nls -i document.txt\n# 123456 document.txt\n\nls -i copy.txt\n# 123456 copy.txt\n\n# Показать количество ссылок на inode\nls -l document.txt\n# -rw-r--r-- 2 user group 1024 Jan 1 10:00 document.txt\n#            ^\n#     Это счетчик ссылок\n```\n\n### Ограничения жестких ссылок\n\n- **Не могут указывать на директории** (только на файлы). Это ограничение ядра Linux для предотвращения зацикливания файловой системы.\n- **Не могут пересекать файловые системы** (разные разделы, диски). Каждая файловая система имеет свою собственную таблицу inode.\n- **Не работают с примонтированными сетевыми файловыми системами** в некоторых конфигурациях.\n\n## Символьные ссылки (Symbolic Links или Soft Links)\n\n### Как работают символьные ссылки\n\nСимвольная ссылка (symlink) — это особый тип файла, который содержит путь к другому файлу или директории. В отличие от жесткой ссылки:\n- Symlink имеет свой собственный inode\n- Он хранит путь к целевому файлу как свое содержимое\n- Если целевой файл удален, symlink становится \"битым\" (dangling)\n- Symlink можно создавать даже если целевой файл еще не существует\n\n### Создание символьной ссылки\n\n```bash\n# Создать символьную ссылку\nln -s целевой_файл символическая_ссылка\n\n# Пример\nln -s /var/log/nginx/access.log nginx_access.log\n```\n\n### Просмотр символьных ссылок\n\n```bash\n# Показать тип файла\nls -l nginx_access.log\n# lrwxrwxrwx 1 user group 24 Jan 1 10:00 nginx_access.log -> /var/log/nginx/access.log\n# ^          ^\n# |          |\n# Тип файла  Количество ссылок всегда 1\n```\n\n### Преимущества символьных ссылок\n\n- **Могут пересекать файловые системы** — можно ссылаться на файлы на других разделах или дисках\n- **Могут указывать на директории** — очень полезно для организации структуры файловой системы\n- **Показывают относительные или абсолютные пути** — гибкость в настройке\n- **Можно создавать ссылки на несуществующие файлы** — полезно для подготовки структуры перед установкой ПО\n\n## Сравнение жестких и символьных ссылок\n\nДавайте систематизируем различия в таблице:\n\n| Характеристика | Жесткая ссылка | Символьная ссылка |\n|---------------|--------------|-----------------|\n| Тип inode | Указывает на тот же inode, что и исходный файл | Имеет свой собственный inode |\n| Данные | Разделяет данные с исходным файлом | Хранит путь к целевому файлу |\n| Удаление исходного файла | Данные остаются доступны через жесткую ссылку | Ссылка становится \"битой\" |\n| Количество ссылок | Увеличивает счетчик ссылок в inode | Не влияет на счетчик ссылок исходного файла |\n| Связь с файловой системой | Не может пересекать файловые системы | Может пересекать файловые системы |\n| Указание на директории | Невозможно | Возможно |\n| Размер | Нулевой (только запись в директории) | Зависит от длины пути |\n\n## Практические примеры использования\n\n### 1. Версионирование программного обеспечения\n\nОчень распространенный паттерн в Linux — использование символических ссылок для управления версиями ПО:\n\n```bash\n/usr/local/bin/\n├── python -> python3.11\n├── python3 -> python3.11\n├── python3.9\n└── python3.11\n```\n\nКогда нужно обновить версию Python по умолчанию, достаточно изменить символическую ссылку:\n\n```bash\nrm /usr/local/bin/python\nln -s python3.12 /usr/local/bin/python\n```\n\n### 2. Экономия места на диске\n\nЖесткие ссылки идеально подходят для экономии места, когда нужно одно и то же содержимое в нескольких местах:\n\n```bash\n# Вместо копирования больших файлов\nln big_backup.tar.gz /mnt/backup/current.tar.gz\nln big_backup.tar.gz /home/user/archives/backup_jan2024.tar.gz\n```\n\nТаким образом, вы экономите место на диске, так как данные физически хранятся только в одном месте.\n\n### 3. Организация рабочих пространств\n\nСимвольные ссылки помогают организовать удобную структуру рабочих каталогов:\n\n```bash\n/home/user/\n├── projects/\n│   ├── website -> /var/www/html\n│   ├── database -> /var/lib/mysql\n│   └── configs -> /etc/nginx\n└── ...\n```\n\nЭто позволяет быстро переходить к часто используемым директориям без запоминания длинных путей.\n\n### 4. Сохранение совместимости при обновлениях\n\nПри обновлении ПО часто меняется структура директорий. Символьные ссылки помогают сохранить обратную совместимость:\n\n```bash\n# Старые приложения ожидают конфиги в /etc/app/config\n# Новые версии используют /etc/app/2.0/config\nln -s /etc/app/2.0/config /etc/app/config\n```\n\n## Распространенные ошибки и как их избежать\n\n### 1. Копирование символических ссылок\n\nПо умолчанию команда `cp` копирует не саму ссылку, а файл, на который она указывает:\n\n```bash\nln -s target.txt symlink.txt\ncp symlink.txt copy.txt\n# copy.txt будет содержать данные из target.txt, а не быть ссылкой\n```\n\nЧтобы скопировать саму ссылку, используйте флаг `-P`:\n\n```bash\ncp -P symlink.txt copy_of_symlink.txt\n# copy_of_symlink.txt будет такой же символьной ссылкой\n```\n\n### 2. Рекурсивное копирование с ссылками\n\nПри копировании директорий с символическими ссылками внутри:\n\n```bash\n# Копировать саму ссылку\ncp -RP source_dir/ destination_dir/\n\n# Разрешить ссылку и скопировать данные (по умолчанию)\ncp -RL source_dir/ destination_dir/\n```\n\n### 3. Удаление файлов через символические ссылки\n\nБудьте осторожны при удалении файлов через символические ссылки:\n\n```bash\nln -s /important/file.txt symlink.txt\nrm symlink.txt  # Удалит только ссылку, не сам файл\nrm $(readlink symlink.txt)  # Удалит сам файл!\n```\n\n### 4. Бесконечные циклы из-за ссылок на директории\n\nНеправильное использование символьных ссылок на директории может создать бесконечные циклы:\n\n```bash\nmkdir dir\ncd dir\nln -s .. parent  # Создает ссылку на родительскую директорию\n```\n\nТеперь команда `ls -R` или `find .` может зависнуть, обходя цикл `dir -> parent -> dir -> parent...`\n\n## Продвинутые приемы\n\n### 1. Относительные vs абсолютные пути в symlink\n\nСимвольные ссылки могут содержать как абсолютные, так и относительные пути:\n\n```bash\n# Абсолютный путь (лучше для стабильности)\nln -s /var/log/nginx/access.log /home/user/logs/nginx_access.log\n\n# Относительный путь (лучше для переносимости)\ncd /home/user/projects\nln -s ../common/libraries shared_libs\n```\n\n### 2. Поиск всех ссылок на файл\n\nЧтобы найти все жесткие ссылки на файл, используйте его inode:\n\n```bash\n# Найти inode файла\nls -i somefile.txt\n# 123456 somefile.txt\n\n# Найти все файлы с этим inode на файловой системе\nfind / -inum 123456 2>/dev/null\n```\n\n### 3. Восстановление удаленного файла через жесткую ссылку\n\nЕсли файл был удален, но на него все еще есть открытый файловый дескриптор (например, процесс читает его), можно восстановить данные через `/proc`:\n\n```bash\n# Найти процесс, использующий удаленный файл\nlsof | grep deleted\n\n# Восстановить файл через файловый дескриптор\nls -l /proc/1234/fd/3  # где 1234 - PID процесса, 3 - номер дескриптора\n# lr-x------ 1 user group 64 Jan 1 11:00 /proc/1234/fd/3 -> /path/to/deleted/file (deleted)\n\ncp /proc/1234/fd/3 /path/to/recovered_file\n```\n\n### 4. Создание атомарных обновлений\n\nЖесткие ссылки позволяют создавать атомарные обновления конфигурационных файлов:\n\n```bash\n# 1. Создаем новую версию файла\nmv config.txt config.txt.old\necho \"new config\" > config.txt.new\n\n# 2. Создаем жесткую ссылку на новую версию\nln config.txt.new config.txt.tmp\n\n# 3. Атомарно заменяем старый файл новым\nmv -Tf config.txt.tmp config.txt\n\n# 4. Удаляем старую версию\nrm config.txt.old\n```\n\nЭтот метод гарантирует, что в любой момент времени процесс либо видит старую, либо новую версию файла, но никогда — половину одного и половину другого.\n\n## Советы для DevOps и системных администраторов\n\n1. **Для управления версиями ПО всегда используйте символические ссылки**\n   Это стандартная практика в Linux, используемая во всех дистрибутивах и менеджерах пакетов.\n\n2. **Для экономии места на диске используйте жесткие ссылки**\n   Особенно полезно для логов, резервных копий и больших медиафайлов.\n\n3. **В скриптах всегда проверяйте, является ли файл ссылкой**\n   ```bash\n   if [ -L \"$file\" ]; then\n       echo \"Это символическая ссылка\"\n   fi\n   ```\n\n4. **Избегайте создания символических ссылок на относительные пути в скриптах**\n   Это может привести к неожиданному поведению при запуске из разных директорий.\n\n5. **Для атомарных обновлений используйте жесткие ссылки + mv**\n   Это надежно работает даже при сбоях питания и аварийных перезагрузках.\n\n## Заключение\n\nДорогой друг, я надеюсь, что теперь вы лучше понимаете разницу между жесткими и символьными ссылками в Linux. Эти инструменты могут показаться простыми на первый взгляд, но они являются фундаментальными строительными блоками файловой системы Unix и открывают множество возможностей для оптимизации и автоматизации.\n\nПомните основные правила:\n- **Жесткие ссылки** используйте для экономии места и атомарных обновлений\n- **Символьные ссылки** используйте для организации структуры файловой системы и управления версиями\n- Всегда проверяйте тип ссылки перед критическими операциями\n- Будьте осторожны при рекурсивном удалении или копировании директорий со ссылками\n\nЕсли у вас есть вопросы или интересные примеры использования ссылок в вашей практике — поделитесь ими в комментариях! Вместе мы делаем мир Linux более понятным и доступным.\n\nДо новых встреч на страницах нашего блога!\n\nP.S. Как говорил один мудрый системный администратор: \"Ссылки в Linux — это как червоточины в космосе: они соединяют разные части файловой системы, но иногда приводят в совершенно неожиданные места\". Используйте их с умом!",
      "questions": [
        {
          "text": "В чём разница между жёсткой и символьной ссылкой?",
          "options": ["Жёсткая ссылка — это путь к файлу, символьная — inode", "Жёсткая ссылка указывает на inode, символьная — на путь", "Символьная ссылка не может быть удалена", "Жёсткая ссылка работает между ФС, символьная — нет"],
          "correct": 1
        },
        {
          "text": "Какой командой создаётся символьная ссылка?",
          "options": ["ln file link", "link file link", "ln -s target link", "symlink target link"],
          "correct": 2
        }
      ]
    },
    {
      "title": "Процесс загрузки Linux: от кнопки питания до пользовательской сессии",
      "content": "Дорогой друг, сегодня мы совершим увлекательное путешествие — проследим за всем процессом загрузки Linux, от момента нажатия кнопки питания до появления приглашения командной строки или графического интерфейса. Эта тема фундаментальна для понимания работы операционной системы, и я постараюсь объяснить ее максимально подробно, но при этом понятно даже новичкам.",
      "questions": [
        {
          "text": "Какой компонент загружается до монтирования корневой ФС?",
          "options": ["GRUB", "systemd", "initramfs", "ядро"],
          "correct": 2
        },
        {
          "text": "Что делает initramfs?",
          "options": ["Управляет сервисами", "Содержит драйверы для монтирования корневой ФС", "Это альтернатива ядру", "Хранит пользовательские данные"],
          "correct": 1
        }
      ]
    },
    {
      "title": "Итоговый тест: полная проверка знаний Linux",
      "content": "Этот тест содержит ВСЕ 73 вопроса из вашего учебного материала. Он охватывает: загрузку, процессы, память, диск, файловые системы, bash, сигналы, безопасность, сеть и архитектуру ядра. Каждый раз вы получаете случайный вопрос из всего пула.",
      "questions": [
        {
          "text": "Как посмотреть нагрузку на диски?",
          "options": [
            "iostat -x 1, iotop, vmstat 1",
            "df -h",
            "free -h",
            "ps aux"
          ],
          "correct": 0
        },
        {
          "text": "Что означают поля bi и bo в vmstat?",
          "options": [
            "bi — блоки, полученные с диска (чтение); bo — блоки, отправленные на диск (запись)",
            "bi — байты входящие, bo — байты исходящие",
            "bi — буферы inodes, bo — блоки объектов",
            "bi — background I/O, bo — blocked operations"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $@ в bash?",
          "options": [
            "Все аргументы командной строки как отдельные слова",
            "Статус последней команды",
            "PID текущего процесса",
            "PID последнего фонового процесса"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $! в bash?",
          "options": [
            "PID последнего фонового процесса",
            "Все аргументы",
            "Статус последней команды",
            "PID текущего shell"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $? в bash?",
          "options": [
            "Статус завершения последней команды (0 — успех)",
            "PID фонового процесса",
            "Все аргументы",
            "Текущий каталог"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $$ в bash?",
          "options": [
            "PID текущего shell-процесса",
            "Статус команды",
            "Аргументы скрипта",
            "Имя скрипта"
          ],
          "correct": 0
        },
        {
          "text": "Что такое load average?",
          "options": [
            "Среднее количество процессов в состоянии R или D за 1/5/15 минут",
            "Процент загрузки CPU",
            "Количество активных пользователей",
            "Скорость диска в IOPS"
          ],
          "correct": 0
        },
        {
          "text": "Где посмотреть load average?",
          "options": [
            "uptime, top, cat /proc/loadavg, w",
            "df -h",
            "free -h",
            "ls /proc"
          ],
          "correct": 0
        },
        {
          "text": "Что такое swap?",
          "options": [
            "Область на диске для расширения RAM при её нехватке",
            "Тип файловой системы",
            "Механизм сетевой балансировки",
            "Кэш процессора"
          ],
          "correct": 0
        },
        {
          "text": "Для чего нужен swap?",
          "options": [
            "Резерв памяти, гибернация, оптимизация RAM",
            "Ускорение загрузки системы",
            "Шифрование данных",
            "Создание резервных копий"
          ],
          "correct": 0
        },
        {
          "text": "Где хранится информация о процессах в Linux?",
          "options": ["/proc", "/etc", "/var/log", "/sys"],
          "correct": 0
        },
        {
          "text": "Что такое процесс в Linux?",
          "options": [
            "Экземпляр выполняющейся программы с собственным адресным пространством",
            "Файл на диске",
            "Пользователь системы",
            "Сетевое соединение"
          ],
          "correct": 0
        },
        {
          "text": "Какие статусы процессов бывают?",
          "options": ["R, S, D, T, Z", "A, B, C, D", "1, 2, 3, 4", "RUN, STOP, KILL"],
          "correct": 0
        },
        {
          "text": "Что означает статус D у процесса?",
          "options": [
            "Uninterruptible sleep (ожидание I/O)",
            "Зомби",
            "Остановлен",
            "Выполняется"
          ],
          "correct": 0
        },
        {
          "text": "Что такое зомби-процесс?",
          "options": [
            "Завершённый процесс, чей родитель не вызвал wait()",
            "Процесс без родителя",
            "Процесс с высоким потреблением CPU",
            "Процесс в состоянии sleeping"
          ],
          "correct": 0
        },
        {
          "text": "Что такое процесс-сирота?",
          "options": [
            "Процесс, чей родитель завершился — усыновляется PID 1",
            "Завершённый процесс",
            "Процесс в состоянии D",
            "Процесс без прав"
          ],
          "correct": 0
        },
        {
          "text": "Как создать файловую систему на блочном устройстве?",
          "options": [
            "mkfs.ext4 /dev/sdX1",
            "mount /dev/sdX1",
            "fdisk /dev/sdX",
            "lsblk"
          ],
          "correct": 0
        },
        {
          "text": "В чём разница между hardlink и symlink?",
          "options": [
            "Hardlink указывает на inode, symlink — на путь",
            "Hardlink работает между ФС, symlink — нет",
            "Symlink не может быть удалён",
            "Hardlink — это ярлык"
          ],
          "correct": 0
        },
        {
          "text": "Как создать жёсткую ссылку?",
          "options": ["ln file link", "ln -s file link", "link file link", "cp -l file link"],
          "correct": 0
        },
        {
          "text": "Как создать символьную ссылку?",
          "options": ["ln -s file link", "ln file link", "mklink file link", "symlink file link"],
          "correct": 0
        },
        {
          "text": "Опишите процесс загрузки Linux.",
          "options": [
            "BIOS/UEFI → GRUB → ядро + initramfs → init (PID 1) → сервисы",
            "Ядро → GRUB → BIOS",
            "GRUB → systemd → ядро",
            "init → ядро → загрузчик"
          ],
          "correct": 0
        },
        {
          "text": "Что такое BIOS?",
          "options": [
            "16-битная прошивка с поддержкой MBR",
            "Современная 64-битная прошивка",
            "Тип файловой системы",
            "Менеджер пакетов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое UEFI?",
          "options": [
            "32/64-битная прошивка с GPT и Secure Boot",
            "Устаревшая 16-битная прошивка",
            "Сетевой протокол",
            "Тип диска"
          ],
          "correct": 0
        },
        {
          "text": "Что такое systemd?",
          "options": [
            "Современная init-система с параллельным запуском сервисов",
            "Тип файловой системы",
            "Менеджер пакетов",
            "Загрузчик"
          ],
          "correct": 0
        },
        {
          "text": "Чем systemd лучше init?",
          "options": [
            "Параллельный запуск, зависимости, логирование через journald",
            "Меньше функций",
            "Работает только в облаке",
            "Не поддерживает сервисы"
          ],
          "correct": 0
        },
        {
          "text": "Как проверить, используется ли systemd?",
          "options": ["ps -p 1 -o comm=", "ls /etc", "df -h", "free -h"],
          "correct": 0
        },
        {
          "text": "Что такое sudo?",
          "options": [
            "Команда для выполнения действий с правами другого пользователя",
            "Менеджер пакетов",
            "Тип файловой системы",
            "Сетевой инструмент"
          ],
          "correct": 0
        },
        {
          "text": "Что такое Docker?",
          "options": [
            "Платформа контейнеризации на основе namespaces и cgroups",
            "Гипервизор",
            "Менеджер пакетов",
            "Тип виртуальной машины"
          ],
          "correct": 0
        },
        {
          "text": "Какие ядерные технологии лежат в основе Docker?",
          "options": ["namespaces, cgroups, UnionFS", "KVM, QEMU", "BIOS, UEFI", "ext4, XFS"],
          "correct": 0
        },
        {
          "text": "Что такое физическая память?",
          "options": [
            "RAM — быстрая энергозависимая память для активных данных",
            "Swap на диске",
            "Файловая система",
            "Кэш процессора"
          ],
          "correct": 0
        },
        {
          "text": "Что такое виртуальная память?",
          "options": [
            "Механизм расширения RAM за счёт swap и изоляции процессов",
            "Тип диска",
            "Сетевой протокол",
            "Файловая система"
          ],
          "correct": 0
        },
        {
          "text": "Что такое файловая система?",
          "options": [
            "Способ организации данных на диске: имена, права, структура",
            "Тип процессора",
            "Сетевой протокол",
            "Менеджер пакетов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое inode?",
          "options": [
            "Структура с метаданными файла: права, владелец, указатели на данные",
            "Имя файла",
            "Содержимое файла",
            "Тип диска"
          ],
          "correct": 0
        },
        {
          "text": "Где хранятся имена файлов?",
          "options": ["В директории", "В inode", "В суперблоке", "В ядре"],
          "correct": 0
        },
        {
          "text": "Почему может быть 'no space left on device', если место есть?",
          "options": ["Закончились inodes", "Сломан диск", "Нет прав", "Ошибка в df"],
          "correct": 0
        },
        {
          "text": "Как проверить, не закончились ли inodes?",
          "options": ["df -i", "df -h", "du -sh", "ls -l"],
          "correct": 0
        },
        {
          "text": "Что такое POSIX?",
          "options": [
            "Стандарт совместимости Unix-систем",
            "Тип файловой системы",
            "Сетевой протокол",
            "Менеджер томов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое PXE?",
          "options": [
            "Загрузка ОС по сети через DHCP + TFTP",
            "Шифрование диска",
            "Тип файловой системы",
            "Менеджер пакетов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое LVM?",
          "options": [
            "Logical Volume Manager: PV → VG → LV",
            "Тип загрузчика",
            "Сетевой протокол",
            "Менеджер процессов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое userspace и kernelspace?",
          "options": [
            "Kernelspace — привилегированный режим ядра, userspace — обычные приложения",
            "Это типы дисков",
            "Сетевые зоны",
            "Режимы работы CPU"
          ],
          "correct": 0
        },
        {
          "text": "Что такое системные вызовы?",
          "options": [
            "Механизм обращения из userspace в kernelspace",
            "Команды в терминале",
            "Сигналы между процессами",
            "Типы файлов"
          ],
          "correct": 0
        },
        {
          "text": "Какой сигнал отправляется при Ctrl+C?",
          "options": ["SIGINT", "SIGKILL", "SIGTERM", "SIGHUP"],
          "correct": 0
        },
        {
          "text": "Чем отличается SIGTERM от SIGKILL?",
          "options": [
            "SIGTERM можно перехватить, SIGKILL — нет",
            "SIGKILL мягче",
            "SIGTERM используется только для root",
            "SIGKILL отправляется первым"
          ],
          "correct": 0
        },
        {
          "text": "Какие сигналы нельзя проигнорировать?",
          "options": ["SIGKILL и SIGSTOP", "SIGTERM и SIGINT", "SIGHUP и SIGUSR1", "Все можно"],
          "correct": 0
        },
        {
          "text": "Как посмотреть, какие файлы открыл процесс?",
          "options": ["ls -l /proc/PID/fd/", "ps aux", "df -h", "free -h"],
          "correct": 0
        },
        {
          "text": "Как узнать, где программа ищет конфиг?",
          "options": ["strace -e open program", "cat /etc/program.conf", "ps aux", "netstat"],
          "correct": 0
        },
        {
          "text": "Что делать, если chmod лишён прав на исполнение?",
          "options": [
            "Запустить через /lib64/ld-linux-x86-64.so.2 /bin/chmod +x /bin/chmod",
            "Перезагрузить",
            "Установить заново",
            "Использовать альтернативу"
          ],
          "correct": 0
        },
        {
          "text": "Почему available > free в free -h?",
          "options": [
            "Available учитывает, что кэш можно сбросить",
            "Это ошибка",
            "Available включает swap",
            "Free не считает RAM"
          ],
          "correct": 0
        },
        {
          "text": "Как работает OOM Killer?",
          "options": [
            "Убивает процесс с наибольшим oom_score при нехватке памяти",
            "Перезагружает систему",
            "Блокирует новые процессы",
            "Переносит всё в swap"
          ],
          "correct": 0
        },
        {
          "text": "Что такое iowait?",
          "options": [
            "Процент времени, которое CPU ждал завершения I/O",
            "Загрузка сети",
            "Использование swap",
            "Потребление RAM"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть, какие процессы используют диск?",
          "options": ["iotop", "top", "ps aux", "df -h"],
          "correct": 0
        },
        {
          "text": "Как проверить, слушает ли сервис порт?",
          "options": ["ss -tuln", "ps aux", "df -h", "free -h"],
          "correct": 0
        },
        {
          "text": "Что такое iptables?",
          "options": [
            "Фильтрация пакетов на уровне ядра",
            "Менеджер пакетов",
            "Тип файловой системы",
            "Сетевой монитор"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть историю команд?",
          "options": ["history", "cat ~/.bash_history", "journalctl", "ls /var/log"],
          "correct": 0
        },
        {
          "text": "Где хранятся системные логи?",
          "options": ["/var/log/", "/etc/log/", "/tmp", "/home"],
          "correct": 0
        },
        {
          "text": "Как отследить системные вызовы?",
          "options": ["strace -p PID", "lsof", "netstat", "ps"],
          "correct": 0
        },
        {
          "text": "Как управлять сервисами в systemd?",
          "options": ["systemctl start/stop/enable", "service start", "init.d", "run"],
          "correct": 0
        },
        {
          "text": "Как установить пакет из исходного кода?",
          "options": ["./configure → make → make install", "apt install", "yum install", "pip install"],
          "correct": 0
        },
        {
          "text": "Что такое initramfs?",
          "options": [
            "Временная ФС в RAM с драйверами для монтирования корня",
            "Загрузчик",
            "Тип ядра",
            "Лог-файл"
          ],
          "correct": 0
        },
        {
          "text": "Как работает fork()?",
          "options": [
            "Создаёт копию процесса (copy-on-write)",
            "Запускает новый терминал",
            "Перезагружает систему",
            "Убивает процесс"
          ],
          "correct": 0
        },
        {
          "text": "Как работать с файлами >2GB на 32-битной системе?",
          "options": [
            "Требуется поддержка large file support (LFS)",
            "Невозможно",
            "Только через swap",
            "Автоматически работает"
          ],
          "correct": 0
        },
        {
          "text": "Что такое softirq?",
          "options": [
            "Нижняя половина обработки прерываний в ядре",
            "Тип сигнала",
            "Сетевой пакет",
            "Ошибка диска"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть дерево процессов?",
          "options": ["pstree", "ps aux", "top", "htop"],
          "correct": 0
        },
        {
          "text": "Как найти процесс по имени?",
          "options": ["pgrep имя", "ps aux | grep имя", "top", "htop"],
          "correct": 0
        },
        {
          "text": "Как убить процесс по имени?",
          "options": ["pkill имя", "kill PID", "stop имя", "exit имя"],
          "correct": 0
        },
        {
          "text": "Как проверить целостность ФС?",
          "options": ["fsck /dev/sdX1", "df -h", "du -sh", "lsblk"],
          "correct": 0
        },
        {
          "text": "Как монтировать ФС постоянно?",
          "options": ["Добавить запись в /etc/fstab", "Выполнить mount", "Создать скрипт", "Использовать systemd"],
          "correct": 0
        },
        {
          "text": "Как узнать UUID раздела?",
          "options": ["blkid /dev/sdX1", "lsblk", "df -h", "fdisk -l"],
          "correct": 0
        }
      ]
    }
  ],
"networking": [
{
"title": "IP-адресация и маски подсети",
"content": "IP-адрес (IPv4) — это 32-битный числовой идентификатор устройства в сети, записываемый как четыре десятичных числа через точку (например, 192.168.1.10). Маска подсети определяет, какая часть адреса относится к сети, а какая — к хосту. Например, маска /24 (255.255.255.0) означает, что первые 24 бита — сеть, остальные 8 — хосты. В такой подсети теоретически 256 адресов, но два зарезервированы: первый — сетевой адрес (192.168.1.0), последний — широковещательный (192.168.1.255), поэтому доступно 254 хоста. Приватные диапазоны (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) используются во внутренних сетях и не маршрутизируются в интернете.",
"questions": [
{
"text": "Сколько хостов доступно в сети 192.168.1.0/24?",
"options": ["256", "254", "255", "128"],
"correct": 1
},
{
"text": "Какой из адресов является приватным?",
"options": ["8.8.8.8", "172.15.0.1", "192.168.10.5", "203.0.113.1"],
"correct": 2
},
{
"text": "Что означает маска /23?",
"options": ["512 адресов всего, 510 для хостов", "256 адресов", "1024 адреса", "128 адресов"],
"correct": 0
}
]
},
{
"title": "Модели OSI и TCP/IP",
"content": "Модель OSI (7 уровней) — концептуальная модель взаимодействия сетевых протоколов: 1) Физический, 2) Канальный, 3) Сетевой, 4) Транспортный, 5) Сеансовый, 6) Представительский, 7) Прикладной. Модель TCP/IP (4 уровня) — упрощённая и используемая на практике: Link (Link Layer), Internet (IP), Transport (TCP/UDP), Application (HTTP, DNS, SSH). Протокол TCP работает на транспортном уровне (4-й в OSI, 3-й в TCP/IP). SSH — на прикладном уровне, но использует TCP для передачи данных. Понимание уровней помогает диагностировать проблемы: например, если не работает ping — проблема на сетевом уровне, если не открывается сайт — на прикладном.",
"questions": [
{
"text": "На каком уровне OSI работает протокол TCP?",
"options": ["Сетевой (3-й)", "Транспортный (4-й)", "Канальный (2-й)", "Прикладной (7-й)"],
"correct": 1
},
{
"text": "На каком уровне OSI работает SSH?",
"options": ["Прикладной (7-й)", "Транспортный (4-й)", "Сетевой (3-й)", "Сеансовый (5-й)"],
"correct": 0
},
{
"text": "Сколько уровней в модели OSI?",
"options": ["4", "5", "7", "8"],
"correct": 2
}
]
},
{
"title": "TCP vs UDP",
"content": "TCP (Transmission Control Protocol) — надёжный, ориентированный на соединение протокол. Он гарантирует доставку, порядок пакетов и защиту от дублирования через подтверждения (ACK), повторные передачи и управление потоком. Используется для веба (HTTP), почты, SSH. UDP (User Datagram Protocol) — ненадёжный, без установки соединения. Он быстрее, но не гарантирует доставку. Используется для DNS, VoIP, потокового видео, онлайн-игр. DNS использует UDP для стандартных запросов (быстро, маленький объём), но переключается на TCP при больших ответах (например, при DNSSEC) или зоне передачи.",
"questions": [
{
"text": "Почему DNS использует UDP?",
"options": ["Потому что запросы короткие и UDP быстрее", "Потому что UDP надёжнее TCP", "DNS не поддерживает TCP", "Для шифрования запросов"],
"correct": 0
},
{
"text": "Какой протокол гарантирует доставку пакетов?",
"options": ["UDP", "ICMP", "TCP", "ARP"],
"correct": 2
},
{
"text": "Какой протокол используется для VoIP?",
"options": ["TCP", "UDP", "HTTP", "SSH"],
"correct": 1
}
]
},
{
"title": "DNS: как это работает",
"content": "DNS (Domain Name System) преобразует доменные имена (yandex.ru) в IP-адреса. Процесс: 1) Браузер проверяет кеш ОС. 2) Если нет — обращается к рекурсивному DNS-резолверу (например, 8.8.8.8). 3) Резолвер запрашивает корневые серверы → серверы зоны .ru → авторитетные серверы yandex.ru. Авторитетный DNS хранит записи: A (IPv4), AAAA (IPv6), CNAME (алиас), MX (почта), TXT (текстовые данные, например, для верификации). Рекурсивный DNS выполняет всю цепочку за клиента и кэширует результат. Локальный DNS в браузере/ОС позволяет избежать повторных запросов.",
"questions": [
{
"text": "Какие типы DNS-записей существуют?",
"options": ["A, AAAA, CNAME, MX, TXT", "TCP, UDP, ICMP", "IPv4, IPv6, MAC", "SSL, TLS, HTTPS"],
"correct": 0
},
{
"text": "Что такое рекурсивный DNS?",
"options": ["Сервер, выполняющий полную цепочку запросов за клиента", "Сервер, отдающий только кэш", "Локальный резолвер в ОС", "Корневой сервер"],
"correct": 0
},
{
"text": "Что такое authority в DNS?",
"options": ["Авторитетный сервер, хранящий оригинальные записи", "Центр сертификации", "Администратор домена", "Тип записи"],
"correct": 0
},
{
"text": "На каком протоколе работает DNS?",
"options": ["В основном UDP, при больших ответах — TCP", "Только TCP", "Только HTTP", "Только ICMP"],
"correct": 0
}
]
},
{
"title": "HTTP и HTTPS",
"content": "HTTP (HyperText Transfer Protocol) — протокол прикладного уровня для передачи веб-данных. Методы: GET (получение), POST (отправка), PUT (обновление), DELETE (удаление). Статус-коды: 2xx (успех, например, 200), 3xx (перенаправление, 301/302), 4xx (ошибка клиента, 404), 5xx (ошибка сервера, 500). Заголовки содержат метаданные: User-Agent, Cookie, Authorization, Content-Type. HTTPS — это HTTP поверх TLS/SSL, обеспечивающий шифрование, целостность и аутентификацию. Базовая HTTP-аутентификация передаёт логин/пароль в заголовке Authorization в base64 (небезопасно без HTTPS).",
"questions": [
{
"text": "Какие основные типы HTTP-запросов существуют?",
"options": ["GET, POST, PUT, DELETE", "TCP, UDP, ICMP", "A, AAAA, CNAME", "SSL, TLS, SSH"],
"correct": 0
},
{
"text": "Что означает статус-код 404?",
"options": ["Успех", "Перенаправление", "Ошибка клиента (не найдено)", "Ошибка сервера"],
"correct": 2
},
{
"text": "Что может содержаться в заголовках HTTP?",
"options": ["User-Agent, Cookie, Authorization", "MAC-адрес, TTL", "SSL-ключ", "DNS-записи"],
"correct": 0
},
{
"text": "Как работает базовая HTTP-аутентификация?",
"options": ["Логин/пароль в base64 в заголовке Authorization", "Через TLS-сертификат", "Через отдельный порт", "С двухфакторной авторизацией"],
"correct": 0
}
]
},
{
"title": "SSL/TLS и безопасность",
"content": "SSL (устарел) и TLS — протоколы шифрования на транспортном уровне. TLS-handshake: 1) Клиент и сервер договариваются о версии и шифрах. 2) Сервер отправляет сертификат. 3) Клиент проверяет его у доверенного центра сертификации (CA). 4) Генерируется сессионный ключ (симметричное шифрование). SNI (Server Name Indication) позволяет одному IP-адресу обслуживать несколько HTTPS-сайтов, передавая имя хоста на этапе handshake. PFS (Perfect Forward Secrecy) гарантирует, что компрометация долгосрочного ключа не раскроет прошлые сессии. mTLS (mutual TLS) требует сертификат от клиента — используется во внутренних микросервисах.",
"questions": [
{
"text": "Что такое SNI?",
"options": ["Расширение TLS для передачи имени хоста", "Тип DNS-записи", "Метод шифрования в SSH", "Протокол VoIP"],
"correct": 0
},
{
"text": "Что такое Perfect Forward Secrecy (PFS)?",
"options": ["Каждая сессия использует уникальный ключ", "Полное шифрование данных", "Метод сжатия сертификатов", "Тип аутентификации"],
"correct": 0
},
{
"text": "Как работает TLS-handshake?",
"options": ["Договор о шифрах, обмен сертификатами, генерация сессионного ключа", "Обмен паролями", "Через UDP", "С ручным подтверждением"],
"correct": 0
}
]
},
{
"title": "Сетевые инструменты: ping, traceroute, TTL",
"content": "Ping использует протокол ICMP (Internet Control Message Protocol), а не TCP/UDP, поэтому у него нет портов. Он отправляет ICMP Echo Request и ждёт Echo Reply. TTL (Time To Live) — поле в IP-заголовке, ограничивающее время жизни пакета (обычно 64). Каждый маршрутизатор уменьшает TTL на 1; при 0 — пакет отбрасывается, и отправляется ICMP Time Exceeded. Traceroute использует TTL: отправляет пакеты с TTL=1,2,3... и по ICMP-ответам строит маршрут до цели. Низкий latency до 8.8.8.8 (Google DNS) обеспечивается глобальной CDN и оптимизацией маршрутов.",
"questions": [
{
"text": "На каком порту работает ping?",
"options": ["Ping не использует порты — работает поверх ICMP", "Порт 7", "Порт 53", "Порт 80"],
"correct": 0
},
{
"text": "Что такое TTL?",
"options": ["Поле в IP-заголовке, ограничивающее время жизни пакета", "Тип лицензии", "Метод сжатия", "Протокол аутентификации"],
"correct": 0
},
{
"text": "Как работает traceroute?",
"options": ["Отправляет пакеты с увеличивающимся TTL", "Делает ping до каждого узла", "Использует DNS", "Анализирует таблицу маршрутизации"],
"correct": 0
}
]
},
{
"title": "NAT, VLAN и маршрутизация",
"content": "NAT (Network Address Translation) позволяет множеству устройств в локальной сети выходить в интернет через один публичный IP. Например, роутер заменяет исходный IP 192.168.1.10 на свой публичный при исходящем трафике и наоборот — при ответе. VLAN (Virtual LAN) логически разделяет одну физическую сеть на несколько изолированных сегментов (например, для отделов), улучшая безопасность и управление. Таблица маршрутизации на устройстве определяет, куда направлять пакеты: по умолчанию — шлюз (роутер), для локальных сетей — напрямую.",
"questions": [
{
"text": "Зачем нужен VLAN?",
"options": ["Для логического разделения физической сети", "Для увеличения скорости", "Для шифрования", "Для настройки IP"],
"correct": 0
},
{
"text": "Как работает NAT?",
"options": ["Позволяет многим устройствам использовать один публичный IP", "Шифрует трафик", "Блокирует соединения", "Ускоряет DNS"],
"correct": 0
},
{
"text": "Что такое таблица маршрутизации?",
"options": ["Определяет, куда направлять пакеты", "Хранит пароли", "Список DNS-серверов", "Журнал подключений"],
"correct": 0
}
]
},
{
"title": "Практические сценарии",
"content": "Если сервис на порту 80 доступен локально (curl localhost), но не извне — возможные причины: 1) Фаервол (например, Windows Defender или iptables) блокирует входящие подключения. 2) Сервис слушает только на 127.0.0.1 (localhost), а не на 0.0.0.0 (все интерфейсы). Проверка: netstat -tuln → должно быть 0.0.0.0:80, а не 127.0.0.1:80. Вторая причина: провайдер или хостинг блокируют порт 80 (часто на VPS без белого IP).",
"questions": [
{
"text": "Сервис на 80 порту доступен локально, но не из браузера. Почему?",
"options": ["Слушает только 127.0.0.1 или фаервол блокирует", "Порт 80 закрыт провайдером", "Нужен HTTPS", "Браузер не поддерживает HTTP"],
"correct": 0
},
{
"text": "Почему latency до 8.8.8.8 всегда низкий?",
"options": ["Потому что это Google DNS с глобальной CDN", "Потому что это локальный адрес", "Потому что пинг через UDP", "Потому что нет шифрования"],
"correct": 0
}
]
},
{
"title": "Балансировщики L4 и L7",
"content": "L4-балансировщик (например, IPVS, HAProxy в режиме TCP) работает на транспортном уровне (TCP/UDP). Он распределяет трафик по IP и порту, не видя содержимого. Быстрый, но ограниченный. L7-балансировщик (Nginx, HAProxy в HTTP-режиме, ALB в AWS) работает на прикладном уровне. Он читает заголовки HTTP (Host, User-Agent), может маршрутизировать по URI, кукам, содержимому. Позволяет делать канареечные релизы, A/B-тестирование, но требует больше ресурсов.",
"questions": [
{
"text": "Чем отличаются балансировщики L4 и L7?",
"options": ["L4 — по IP/порту; L7 — по содержимому (HTTP)", "L4 шифрует трафик", "L7 быстрее", "L4 используется только в облаке"],
"correct": 0
},
{
"text": "Что даёт балансировщик трафика?",
"options": ["Распределение нагрузки для отказоустойчивости", "Шифрование всего трафика", "Автоматическую настройку DNS", "Ускорение интернета"],
"correct": 0
}
]
},
{
"title": "SSH и безопасный доступ",
"content": "SSH (Secure Shell) работает поверх TCP (порт 22). Установка соединения: 1) Клиент и сервер обмениваются версиями. 2) Договариваются о шифрах. 3) Сервер отправляет свой публичный ключ. 4) Клиент проверяет его по записям в ~/.ssh/known_hosts. Авторизация: 1) По паролю. 2) По ключу: клиент подписывает запрос своим приватным ключом, сервер проверяет публичным. Ключи надёжнее и удобнее.",
"questions": [
{
"text": "Как устанавливает соединение SSH?",
"options": ["Обмен версиями, договор о шифрах, проверка ключа", "Через HTTP-запрос", "Через UDP", "Требует DNS TXT"],
"correct": 0
},
{
"text": "Какой метод авторизации в SSH надёжнее?",
"options": ["По ключу", "По паролю", "По IP", "По имени пользователя"],
"correct": 0
}
]
},
{
"title": "Дополнительно: mTLS, iptables, PFS",
"content": "mTLS (mutual TLS) — двусторонняя аутентификация, где и клиент, и сервер предъявляют сертификаты. Используется в микросервисных архитектурах. Настройка проброса портов в iptables: iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080 — перенаправляет внешний порт 80 на внутренний 8080. PFS (Perfect Forward Secrecy) достигается использованием эфемерных ключей — каждый сеанс использует уникальный ключ.",
"questions": [
{
"text": "Что такое mTLS?",
"options": ["Взаимная аутентификация по сертификатам", "Тип балансировщика", "Метод сжатия TLS", "Протокол для мобильных сетей"],
"correct": 0
},
{
"text": "Как работает двусторонняя аутентификация (mTLS)?",
"options": ["И клиент, и сервер проверяют сертификаты", "Используется только пароль", "Работает без сертификатов", "Требует физического ключа"],
"correct": 0
},
{
"text": "Как настроить проброс портов через iptables?",
"options": ["iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080", "iptables --allow-port 80", "Невозможно", "Через route add"],
"correct": 0
}
]
},
{
"title": "Итоговый тест: полная проверка знаний по сетям",
"content": "Этот тест содержит ВСЕ вопросы по сетям — от основ IP до продвинутых тем вроде mTLS и PFS. Удачи!",
"questions": [
{
"text": "Что такое IP и маска подсети?",
"options": ["IP — уникальный идентификатор устройства; маска определяет границу сети и хоста", "IP — MAC-адрес", "IP — имя домена", "IP — пароль от Wi-Fi"],
"correct": 0
},
{
"text": "Чем отличается TCP от UDP?",
"options": ["TCP — надёжный с подтверждением; UDP — быстрый, без гарантий", "TCP работает только локально", "TCP использует порты, UDP — нет", "TCP шифрует трафик"],
"correct": 0
},
{
"text": "Как работает DNS, зачем он нужен?",
"options": ["Преобразует домены в IP-адреса", "Шифрует трафик", "Блокирует сайты", "Ускоряет загрузку"],
"correct": 0
},
{
"text": "Какие типы DNS-записей существуют?",
"options": ["A, AAAA, CNAME, MX, TXT", "TCP, UDP, ICMP", "IPv4, IPv6, MAC", "SSL, TLS, HTTPS"],
"correct": 0
},
{
"text": "Как узнать мой внешний IP-адрес?",
"options": ["Через сервисы вроде ifconfig.me", "Командой ipconfig", "Командой ifconfig", "В настройках роутера"],
"correct": 0
},
{
"text": "Какие стандартные коды ответов есть у веб-серверов?",
"options": ["2xx, 3xx, 4xx, 5xx", "1xx, 2xx, 3xx", "A, B, C, D", "HTTP, HTTPS, FTP"],
"correct": 0
},
{
"text": "В чём отличие HTTP от HTTPS?",
"options": ["HTTPS — это HTTP поверх TLS", "HTTP только на порту 80", "HTTPS быстрее", "HTTP требует авторизации"],
"correct": 0
},
{
"text": "Что такое SSL и TLS?",
"options": ["Протоколы шифрования транспортного уровня", "Типы веб-серверов", "Методы сжатия", "СУБД"],
"correct": 0
},
{
"text": "Какие основные типы HTTP-запросов существуют?",
"options": ["GET, POST, PUT, DELETE", "TCP, UDP, ICMP", "A, AAAA, CNAME", "SSL, TLS, SSH"],
"correct": 0
},
{
"text": "Как TCP устанавливает соединение?",
"options": ["Через трёхэтапное рукопожатие", "Через двухэтапное", "Автоматически", "С DNS-запросом"],
"correct": 0
},
{
"text": "Что происходит, когда в браузере вводишь yandex.ru?",
"options": ["DNS-запрос, TCP-соединение, HTTP-запрос", "Сразу HTTPS без DNS", "Подключение к локальному серверу", "Используется только UDP"],
"correct": 0
},
{
"text": "Как TCP поддерживает соединение?",
"options": ["Через ACK, повторные передачи, управление потоком", "Через регулярные ping", "С DNS-кэшированием", "Автоматически"],
"correct": 0
},
{
"text": "Что такое и зачем нужен ARP-протокол?",
"options": ["Сопоставляет IP MAC-адресам в локальной сети", "Шифрует трафик", "Маршрутизирует пакеты", "Блокирует IP"],
"correct": 0
},
{
"text": "Зачем нужен VLAN?",
"options": ["Для логического разделения физической сети", "Для увеличения скорости", "Для шифрования", "Для настройки IP"],
"correct": 0
},
{
"text": "На каком уровне OSI работает TCP?",
"options": ["Транспортный (4-й)", "Сетевой (3-й)", "Канальный (2-й)", "Прикладной (7-й)"],
"correct": 0
},
{
"text": "На каком уровне OSI работает SSH?",
"options": ["Прикладной (7-й)", "Транспортный (4-й)", "Сетевой (3-й)", "Сеансовый (5-й)"],
"correct": 0
},
{
"text": "Что такое адреса 127.0.0.0/8, 192.168.0.0/16 и т.д.?",
"options": ["Приватные диапазоны для внутренних сетей", "Публичные DNS", "Корневые серверы", "Multicast"],
"correct": 0
},
{
"text": "Как работает NAT и зачем он нужен?",
"options": ["Позволяет многим устройствам использовать один публичный IP", "Шифрует трафик", "Блокирует соединения", "Ускоряет DNS"],
"correct": 0
},
{
"text": "Что такое SNI?",
"options": ["Расширение TLS для передачи имени хоста", "Тип DNS-записи", "Метод шифрования SSH", "Протокол VoIP"],
"correct": 0
},
{
"text": "Чем симметричное шифрование отличается от асимметричного?",
"options": ["Симметричное — один ключ; асимметричное — пара ключей", "Симметричное медленнее", "Симметричное только в HTTPS", "Асимметричное не обеспечивает целостность"],
"correct": 0
},
{
"text": "Почему DNS использует UDP?",
"options": ["Потому что запросы короткие и UDP быстрее", "Потому что UDP надёжнее", "DNS не поддерживает TCP", "Для шифрования"],
"correct": 0
},
{
"text": "На каком порту работает ping?",
"options": ["Ping не использует порты — работает поверх ICMP", "Порт 7", "Порт 53", "Порт 80"],
"correct": 0
},
{
"text": "Как работает ICMP?",
"options": ["Протокол для служебных сообщений (ошибки доставки)", "Шифрует трафик", "Используется для DNS", "Работает только в IPv6"],
"correct": 0
},
{
"text": "Что такое TTL?",
"options": ["Поле в IP-заголовке, ограничивающее время жизни пакета", "Тип лицензии", "Метод сжатия", "Протокол аутентификации"],
"correct": 0
},
{
"text": "Как работает traceroute?",
"options": ["Отправляет пакеты с увеличивающимся TTL", "Делает ping до каждого узла", "Использует DNS", "Анализирует таблицу маршрутизации"],
"correct": 0
},
{
"text": "Что такое authority в DNS?",
"options": ["Авторитетный сервер с оригинальными записями", "Центр сертификации", "Администратор домена", "Тип записи"],
"correct": 0
},
{
"text": "Что такое рекурсивный DNS?",
"options": ["Сервер, выполняющий полную цепочку запросов за клиента", "Сервер с кэшированными ответами", "Локальный резолвер", "Корневой сервер"],
"correct": 0
},
{
"text": "У тебя маска /23. Сколько адресов доступно?",
"options": ["512 всего, 510 для хостов", "256", "1024", "128"],
"correct": 0
},
{
"text": "Как работает базовая HTTP-аутентификация?",
"options": ["Логин/пароль в base64 в заголовке Authorization", "Через TLS-сертификат", "Через отдельный порт", "С двухфакторной авторизацией"],
"correct": 0
},
{
"text": "Как работают сертификаты в HTTPS?",
"options": ["Сервер отправляет сертификат, клиент проверяет у CA", "Сертификат шифрует весь трафик", "Сертификат генерируется браузером", "Используется только для SMTP"],
"correct": 0
},
{
"text": "Как устанавливает соединение SSH?",
"options": ["Обмен версиями, договор о шифрах, проверка ключа", "Через HTTP", "Через UDP", "Требует DNS TXT"],
"correct": 0
},
{
"text": "Чем отличаются балансировщики L4 и L7?",
"options": ["L4 — по IP/порту; L7 — по содержимому", "L4 шифрует трафик", "L7 быстрее", "L4 только в облаке"],
"correct": 0
},
{
"text": "Почему latency до 8.8.8.8 всегда низкий?",
"options": ["Потому что это Google DNS с глобальной CDN", "Потому что локальный адрес", "Потому что пинг через UDP", "Потому что нет шифрования"],
"correct": 0
},
{
"text": "На каком протоколе работает DNS?",
"options": ["В основном UDP, при больших ответах — TCP", "Только TCP", "Только HTTP", "Только ICMP"],
"correct": 0
},
{
"text": "Сервис на 80 порту доступен локально, но не из браузера. Почему?",
"options": ["Слушает только 127.0.0.1 или фаервол блокирует", "Порт 80 закрыт провайдером", "Нужен HTTPS", "Браузер не поддерживает HTTP"],
"correct": 0
},
{
"text": "Что даёт балансировщик трафика?",
"options": ["Распределение нагрузки для отказоустойчивости", "Шифрование всего трафика", "Автоматическую настройку DNS", "Ускорение интернета"],
"correct": 0
},
{
"text": "Что такое mTLS?",
"options": ["Взаимная аутентификация по сертификатам", "Тип балансировщика", "Метод сжатия TLS", "Протокол для мобильных сетей"],
"correct": 0
},
{
"text": "Что может содержаться в заголовках HTTP?",
"options": ["User-Agent, Cookie, Authorization", "MAC-адрес, TTL", "SSL-ключ", "DNS-записи"],
"correct": 0
},
{
"text": "Как работает TLS-handshake?",
"options": ["Договор о шифрах, обмен сертификатами, генерация ключа", "Обмен паролями", "Через UDP", "С ручным подтверждением"],
"correct": 0
},
{
"text": "Как настроить проброс портов через iptables?",
"options": ["iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080", "iptables --allow-port 80", "Невозможно", "Через route add"],
"correct": 0
},
{
"text": "Что такое Perfect Forward Secrecy (PFS)?",
"options": ["Каждая сессия использует уникальный ключ", "Полное шифрование данных", "Метод сжатия сертификатов", "Тип аутентификации"],
"correct": 0
},
{
"text": "Как работает двусторонняя аутентификация (mTLS)?",
"options": ["И клиент, и сервер проверяют сертификаты", "Используется только пароль", "Работает без сертификатов", "Требует физического ключа"],
"correct": 0
}
]
}
],
"databases": [
{
"title": "TRUNCATE, DELETE и DROP в SQL",
"content": "Эти команды удаляют данные, но по-разному. DELETE удаляет строки (можно с WHERE), поддерживает ROLLBACK и вызывает триггеры. TRUNCATE быстро очищает всю таблицу, сбрасывает автоинкремент, но не логирует построчно (в MySQL откат невозможен). DROP удаляет таблицу полностью — структуру, данные, индексы. DELETE — для выборочного удаления, TRUNCATE — для быстрой очистки, DROP — для полного удаления таблицы.",
"questions": [
{
"text": "Какая команда удаляет таблицу полностью, включая структуру?",
"options": ["DELETE", "TRUNCATE", "DROP", "ALTER"],
"correct": 2
},
{
"text": "Какая команда позволяет использовать WHERE для удаления строк?",
"options": ["DELETE", "TRUNCATE", "DROP", "CREATE"],
"correct": 0
},
{
"text": "Какая команда сбрасывает автоинкрементный счётчик?",
"options": ["DELETE", "TRUNCATE", "Обе", "Ни одна"],
"correct": 1
}
]
},
{
"title": "Индексы в базах данных",
"content": "Индексы — структуры для ускорения поиска (как оглавление в книге). Создаются для столбцов, часто используемых в WHERE, JOIN, ORDER BY. Типы: B-дерево (стандарт), хеш (только =), составные (несколько столбцов), GIN/GiST (для JSON/текста). Индексы ускоряют SELECT, но замедляют INSERT/UPDATE, так как их тоже нужно обновлять. Уникальные индексы гарантируют отсутствие дубликатов. Используй EXPLAIN, чтобы проверить, используется ли индекс.",
"questions": [
{
"text": "Какой тип индекса подходит для точного сравнения (=) и самый быстрый?",
"options": ["B-дерево", "Хеш-индекс", "Составной", "GIN"],
"correct": 1
},
{
"text": "Что ускоряет индекс на столбце `email`?",
"options": ["Запросы с WHERE email = ...", "Запросы с WHERE age > ...", "INSERT в таблицу", "DROP TABLE"],
"correct": 0
},
{
"text": "Какой индекс гарантирует уникальность значений?",
"options": ["PRIMARY KEY", "UNIQUE INDEX", "Обычный индекс", "Хеш-индекс"],
"correct": 1
}
]
},
{
"title": "Основные операторы SQL",
"content": "SQL-операторы делятся на категории: DQL (SELECT, WHERE, JOIN — запросы), DML (INSERT, UPDATE, DELETE — изменение данных), DDL (CREATE, ALTER, DROP — структура), TCL (COMMIT, ROLLBACK — транзакции), DCL (GRANT, REVOKE — права). SELECT — основа запросов. JOIN объединяет таблицы. GROUP BY группирует, HAVING фильтрует группы. LIMIT ограничивает результат. Используйте EXPLAIN для анализа плана выполнения запроса.",
"questions": [
{
"text": "К какой категории относится оператор SELECT?",
"options": ["DML", "DDL", "DQL", "TCL"],
"correct": 2
},
{
"text": "Какой оператор используется для подтверждения транзакции?",
"options": ["SAVEPOINT", "ROLLBACK", "COMMIT", "GRANT"],
"correct": 2
},
{
"text": "Какой оператор добавляет новый столбец в таблицу?",
"options": ["CREATE COLUMN", "ADD COLUMN", "ALTER TABLE ... ADD COLUMN", "UPDATE TABLE"],
"correct": 2
},
{
"text": "Что делает оператор HAVING?",
"options": ["Фильтрует строки до группировки", "Фильтрует группы после GROUP BY", "Сортирует результат", "Ограничивает количество строк"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Базы данных (Junior)",
"content": "Финальный тест по модулю «Базы данных». 10 вопросов на знание основ SQL.",
"questions": [
{
"text": "Какая команда НЕ может использовать WHERE?",
"options": ["DELETE", "TRUNCATE", "SELECT", "UPDATE"],
"correct": 1
},
{
"text": "Что произойдёт при выполнении DROP TABLE users?",
"options": ["Удалятся только данные", "Таблица очистится, но останется", "Таблица и её структура удалятся", "Сработает ошибка"],
"correct": 2
},
{
"text": "Для чего используется индекс?",
"options": ["Ускорить поиск данных", "Зашифровать данные", "Удалить дубликаты", "Создать резервную копию"],
"correct": 0
},
{
"text": "Какой оператор возвращает уникальные значения?",
"options": ["UNIQUE", "DISTINCT", "GROUP BY", "HAVING"],
"correct": 1
},
{
"text": "Как откатить транзакцию в SQL?",
"options": ["UNDO", "CANCEL", "ROLLBACK", "REVERT"],
"correct": 2
},
{
"text": "Какой оператор изменяет структуру существующей таблицы?",
"options": ["MODIFY", "UPDATE", "ALTER", "CHANGE"],
"correct": 2
},
{
"text": "Какой тип индекса лучше всего подходит для поиска по диапазону (например, price > 100)?",
"options": ["Хеш-индекс", "B-дерево", "GIN", "Уникальный"],
"correct": 1
},
{
"text": "Что делает команда TRUNCATE TABLE?",
"options": ["Удаляет таблицу", "Удаляет все строки быстро", "Удаляет строки с WHERE", "Создаёт копию таблицы"],
"correct": 1
},
{
"text": "Какой оператор используется для объединения таблиц?",
"options": ["MERGE", "COMBINE", "JOIN", "UNION"],
"correct": 2
},
{
"text": "Как ограничить количество результатов в PostgreSQL?",
"options": ["TOP", "LIMIT", "MAX", "FETCH"],
"correct": 1
}
]
}
],
"ansible": [
{
"title": "Что такое Ansible и как он работает",
"content": "Ansible — это инструмент автоматизации инфраструктуры (IaC). Главные особенности: агентless-архитектура (работает через SSH/WinRM), идемпотентность (повторный запуск не ломает систему) и декларативный подход (описываете желаемое состояние). Основные компоненты: Inventory (список хостов), Playbook (YAML-сценарий), Module (готовые команды), Role (переиспользуемый блок). Ansible загружает модули на целевые узлы через Python и возвращает результат в JSON.",
"questions": [
{
"text": "Какая архитектура у Ansible?",
"options": ["Требует агентов на хостах", "Агентless (работает через SSH/WinRM)", "Использует открытые порты кроме SSH", "Только для Linux"],
"correct": 1
},
{
"text": "Что означает идемпотентность в Ansible?",
"options": ["Задача выполняется быстрее при повторном запуске", "Повторный запуск не меняет систему, если она уже в нужном состоянии", "Задача всегда ломает систему", "Требует перезагрузки сервера"],
"correct": 1
},
{
"text": "Как Ansible подключается к Linux-хостам?",
"options": ["Через специальный агент", "Через SSH", "Через HTTP API", "Через Telnet"],
"correct": 1
}
]
},
{
"title": "Playbook и Inventory в Ansible",
"content": "Playbook — это YAML-файл с задачами (tasks), который описывает автоматизацию. Структура: hosts (целевые хосты), become (sudo), tasks (вызов модулей). Inventory — файл (INI или YAML), где перечислены хосты и их параметры (ansible_user, ansible_port и т.д.). Пример inventory: [webservers] 10.0.0.1. Пример playbook: установка Nginx через apt и запуск службы через service. Playbook можно запустить командой ansible-playbook -i inventory playbook.yml.",
"questions": [
{
"text": "Какой формат файла используется для Playbook?",
"options": ["JSON", "XML", "YAML", "INI"],
"correct": 2
},
{
"text": "Как указать нестандартный SSH-порт для хоста в inventory?",
"options": ["10.0.0.1:2222", "10.0.0.1 port=2222", "10.0.0.1 ansible_port=2222", "Нельзя указать"],
"correct": 2
},
{
"text": "Какая команда запускает playbook?",
"options": ["ansible run playbook.yml", "ansible-playbook playbook.yml", "ansible execute playbook.yml", "playbook run"],
"correct": 1
}
]
},
{
"title": "Роли (Roles) в Ansible",
"content": "Роль — это переиспользуемый набор задач, шаблонов, файлов и переменных с чёткой структурой: tasks/main.yml (задачи), handlers/main.yml (обработчики), templates/ (шаблоны Jinja2), files/ (статические файлы), vars/main.yml (переменные), defaults/main.yml (переменные по умолчанию). Роли подключаются в playbook через секцию roles. Преимущество: удобство поддержки и повторное использование (например, роль nginx можно подключить в десятки проектов). Создать роль: ansible-galaxy init my_role.",
"questions": [
{
"text": "Где хранятся шаблоны конфигов в роли?",
"options": ["files/", "templates/", "vars/", "handlers/"],
"correct": 1
},
{
"text": "Какая папка содержит переменные по умолчанию (низкий приоритет)?",
"options": ["vars/", "defaults/", "meta/", "tasks/"],
"correct": 1
},
{
"text": "Как подключить роль в playbook?",
"options": ["import_role: nginx", "include: roles/nginx", "roles: - nginx", "call nginx_role"],
"correct": 2
}
]
},
{
"title": "Продвинутые возможности: Handlers, Tags, Ansible vs Terraform",
"content": "Handlers — задачи, которые запускаются только при уведомлении (notify) и только если произошли изменения (например, перезапуск nginx после обновления конфига). Tags позволяют запускать часть задач: --tags 'install'. Ansible vs Terraform: Ansible — для управления конфигурацией существующих серверов (push-модель), Terraform — для создания/удаления облачной инфраструктуры (IaC). Ansible — идемпотентный, безагентный, использует модули и плагины.",
"questions": [
{
"text": "Когда выполняется handler?",
"options": ["После каждой задачи", "Только если задача изменила состояние и вызвала notify", "Перед всеми задачами", "Никогда"],
"correct": 1
},
{
"text": "Чем Ansible отличается от Terraform?",
"options": ["Ansible создаёт инфраструктуру, Terraform настраивает её", "Ansible управляет конфигурацией серверов, Terraform — управляет облачными ресурсами", "Terraform работает через SSH, Ansible — через API", "Нет разницы"],
"correct": 1
},
{
"text": "Как запустить только задачи с тегом 'deploy'?",
"options": ["--tag deploy", "--tags 'deploy'", "-t deploy", "Все варианты верны"],
"correct": 3
},
{
"text": "Где работают модули Ansible?",
"options": ["На управляющей машине", "На целевых хостах", "В облаке", "В Docker-контейнере"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Ansible (Junior)",
"content": "Финальный тест по модулю Ansible. 15 вопросов на все ключевые темы.",
"questions": [
{
"text": "Какая команда проверяет подключение к хостам?",
"options": ["ansible all -m ping", "ansible ping all", "ansible test all", "ping all"],
"correct": 0
},
{
"text": "Что такое inventory в Ansible?",
"options": ["Файл с задачами", "Список управляемых хостов", "Шаблон конфигурации", "Результат выполнения"],
"correct": 1
},
{
"text": "Какой модуль используется для установки пакетов в Ubuntu?",
"options": ["yum", "apt", "package", "install"],
"correct": 1
},
{
"text": "Какой файл в роли содержит основные задачи?",
"options": ["tasks/main.yml", "handlers/main.yml", "vars/main.yml", "defaults/main.yml"],
"correct": 0
},
{
"text": "Что делает параметр become: yes в playbook?",
"options": ["Подключается под другим пользователем", "Выполняет задачи с правами sudo", "Пропускает задачу", "Логирует выполнение"],
"correct": 1
},
{
"text": "Какой формат inventory поддерживает вложенные группы?",
"options": ["Только INI", "Только YAML", "Оба формата", "Ни один"],
"correct": 2
},
{
"text": "Что такое facts в Ansible?",
"options": ["Переменные, заданные пользователем", "Автоматически собранные данные о хостах", "Шаблоны Jinja2", "Результаты тестов"],
"correct": 1
},
{
"text": "Какой плагин отвечает за подключение к хостам?",
"options": ["callback", "lookup", "connection", "inventory"],
"correct": 2
},
{
"text": "Где хранятся статические файлы для копирования в роли?",
"options": ["templates/", "files/", "vars/", "meta/"],
"correct": 1
},
{
"text": "Что произойдёт, если задача не изменила состояние, но вызвала notify?",
"options": ["Handler выполнится", "Handler не выполнится", "Playbook завершится с ошибкой", "Ansible перезапустится"],
"correct": 1
},
{
"text": "Какой модуль управляет службами (сервисами)?",
"options": ["service", "systemd", "start", "run"],
"correct": 0
},
{
"text": "Как создать новую роль?",
"options": ["ansible role create my_role", "ansible-galaxy init my_role", "mkdir roles/my_role", "Все способы верны"],
"correct": 1
},
{
"text": "Какой параметр inventory задаёт пользователя для SSH?",
"options": ["user", "ssh_user", "ansible_user", "login"],
"correct": 2
},
{
"text": "Что такое плагины в Ansible?",
"options": ["Замена модулей", "Расширение функциональности на управляющей машине", "Агенты на хостах", "Графический интерфейс"],
"correct": 1
},
{
"text": "Какой принцип позволяет запускать playbook много раз без вреда?",
"options": ["Idempotency", "Agentless", "Declarative", "Modular"],
"correct": 0
}
]
}
],
"docker": [
{
"title": "Контейнеризация vs Виртуализация",
"content": "Контейнеризация и виртуализация — разные подходы к изоляции. Виртуализация (VM) эмулирует железо через гипервизор и запускает полную гостевую ОС — тяжело, но безопасно. Контейнеризация (Docker) делит ядро хоста через namespaces (изоляция процессов, сети, ФС) и cgroups (ограничение ресурсов). Контейнер — это просто изолированный процесс, запускается за миллисекунды, потребляет минимум ресурсов. Изоляция слабее (общее ядро), но для микросервисов — идеальна. В облаках часто контейнеры запускают внутри VM (гибрид). Выбор: VM — для разных ОС или полной изоляции, контейнеры — для DevOps, CI/CD, микросервисов.",
"questions": [
{
"text": "В чём ключевое отличие контейнера от виртуальной машины?",
"options": ["Контейнер эмулирует железо", "Контейнер использует ядро хоста, VM — свою ОС", "VM запускается быстрее", "Контейнер требует гипервизор"],
"correct": 1
},
{
"text": "Какая технология обеспечивает изоляцию процессов в контейнере?",
"options": ["Гипервизор", "Namespaces", "cgroups", "VirtualBox"],
"correct": 1
},
{
"text": "Какая технология ограничивает CPU/RAM для контейнера?",
"options": ["Namespaces", "cgroups", "KVM", "Docker Hub"],
"correct": 1
}
]
},
{
"title": "Образы, слои и Copy-on-Write",
"content": "Docker-образ — неизменяемый шаблон для контейнера, состоит из слоёв. Каждая инструкция в Dockerfile (FROM, RUN, COPY) создаёт новый слой. Слои кэшируются: изменение в Dockerfile пересобирает только текущий и последующие слои. При запуске контейнера поверх слоёв образа создаётся записываемый слой (Copy-on-Write): изменения файлов сохраняются только в нём. Это позволяет экономить место и ускорять сборку. Анализ слоёв: `docker history <image>`. Оптимизация: объединять команды RUN, удалять кэш, использовать .dockerignore.",
"questions": [
{
"text": "Что такое слой (layer) в Docker?",
"options": ["Отдельный контейнер", "Неизменяемый компонент образа, созданный инструкцией Dockerfile", "Тип сети", "Файл логов"],
"correct": 1
},
{
"text": "Как работает Copy-on-Write в контейнере?",
"options": ["Копирует весь образ при запуске", "При изменении файла создаёт копию в записываемом слое", "Запрещает изменение файлов", "Работает только в VM"],
"correct": 1
},
{
"text": "Какой командой посмотреть слои образа?",
"options": ["docker layers", "docker history", "docker inspect", "docker images"],
"correct": 1
}
]
},
{
"title": "Dockerfile: инструкции, CMD vs ENTRYPOINT, оптимизация",
"content": "Dockerfile — инструкции для сборки образа. Ключевые команды: FROM (база), RUN (команды при сборке), COPY/ADD (копирование файлов; COPY предпочтительнее), WORKDIR (рабочая директория), CMD/ENTRYPOINT (запуск). CMD — аргументы по умолчанию (переопределяются), ENTRYPOINT — основная команда (не переопределяется без --entrypoint). Многоэтапная сборка (multi-stage) уменьшает размер образа: сборка в одном образе, копирование результата в минималистичный. Оптимизация: использовать -slim образы, удалять кэш (`rm -rf /var/lib/apt/lists/*`), избегать latest.",
"questions": [
{
"text": "В чём разница между CMD и ENTRYPOINT?",
"options": ["CMD нельзя переопределить, ENTRYPOINT — можно", "ENTRYPOINT задаёт основную команду, CMD — аргументы по умолчанию", "ENTRYPOINT работает только в multi-stage", "Нет разницы"],
"correct": 1
},
{
"text": "Зачем нужна многоэтапная сборка?",
"options": ["Для запуска нескольких контейнеров", "Для уменьшения размера финального образа", "Для ускорения загрузки Docker Hub", "Для совместимости с Kubernetes"],
"correct": 1
},
{
"text": "Почему не рекомендуется использовать образы с тегом latest?",
"options": ["Они самые большие", "Они нестабильны и нарушают воспроизводимость", "Они не содержат Python", "Они платные"],
"correct": 1
},
{
"text": "Какая инструкция предпочтительнее для копирования файлов?",
"options": ["ADD", "COPY", "RUN cp", "WORKDIR"],
"correct": 1
}
]
},
{
"title": "Сети, тома и Docker Compose",
"content": "Docker поддерживает сети: bridge (изолированная сеть по умолчанию), host (контейнер использует сеть хоста), none (без сети). Для связи контейнеров — пользовательские bridge-сети (`docker network create`). Тома (volumes) сохраняют данные между перезапусками: named volumes (управляются Docker) и bind mounts (привязка директории хоста). Docker Compose — инструмент для запуска мультконтейнерных приложений из YAML-файла (docker-compose.yml). Основные команды: `docker-compose up`, `down`, `ps`. Compose автоматически создаёт общую сеть для сервисов.",
"questions": [
{
"text": "В чём разница между bridge и host сетями?",
"options": ["bridge — сеть хоста, host — изолированная", "bridge — изолированная (по умолчанию), host — сеть хоста", "host работает только в VM", "bridge медленнее host всегда"],
"correct": 1
},
{
"text": "Когда использовать named volumes вместо bind mounts?",
"options": ["Когда нужно привязать директорию хоста", "Когда данные должны управляться Docker (переносимость)", "Bind mounts безопаснее", "Named volumes не работают в Compose"],
"correct": 1
},
{
"text": "Какая команда запускает приложение через Docker Compose?",
"options": ["docker run compose", "docker-compose up", "docker compose start", "compose run"],
"correct": 1
}
]
},
{
"title": "Безопасность и лучшие практики",
"content": "Безопасность Docker: запуск от непривилегированного пользователя (`USER` в Dockerfile), избегание `--privileged`, использование минимальных образов (-slim, -alpine), сканирование уязвимостей (trivy), не хранение секретов в образе (использовать docker secrets или переменные окружения при запуске). Лучшие практики: всегда указывать конкретную версию образа (не latest), использовать .dockerignore, объединять RUN-команды, многоэтапная сборка, HEALTHCHECK для мониторинга. Запуск: `docker run --read-only --tmpfs /tmp ...` для дополнительной защиты.",
"questions": [
{
"text": "Как запустить контейнер от непривилегированного пользователя?",
"options": ["Использовать sudo внутри контейнера", "Добавить USER nobody в Dockerfile", "Запустить с --privileged", "Это невозможно"],
"correct": 1
},
{
"text": "Почему не стоит хранить секреты (пароли, ключи) в Dockerfile?",
"options": ["Они видны в истории слоёв образа", "Dockerfile не поддерживает секреты", "Секреты замедляют сборку", "Они автоматически удаляются"],
"correct": 0
},
{
"text": "Какой флаг делает ФС контейнера доступной только для чтения?",
"options": ["--read-only", "--no-write", "--secure", "--readonly"],
"correct": 0
}
]
},
{
"title": "Диагностика проблем в Docker",
"content": "Контейнер запущен, но приложение недоступно? Проверяйте: `docker logs <container>` (логи), `docker exec -it <container> sh` (заход в контейнер), `docker port <container>` (проброшенные порты), `docker inspect <container>` (детали). Проблемы с сетью между контейнерами? Убедитесь, что они в одной пользовательской сети. Высокое потребление памяти? Ограничьте через `--memory=512m` и мониторьте `docker stats`. Ошибки сборки? Читайте вывод шага, проверяйте пути в COPY, наличие файлов в .dockerignore. Частые ошибки: порт уже занят, нет EXPOSE, приложение слушает только localhost (а не 0.0.0.0).",
"questions": [
{
"text": "Как посмотреть логи контейнера?",
"options": ["docker log", "docker logs", "docker inspect --logs", "journalctl -u docker"],
"correct": 1
},
{
"text": "Почему приложение в контейнере может быть недоступно извне, даже если порт проброшен?",
"options": ["Приложение слушает только 127.0.0.1, а не 0.0.0.0", "Docker не поддерживает TCP", "Нужен перезапуск хоста", "Порт должен быть выше 10000"],
"correct": 0
},
{
"text": "Какой командой зайти в запущенный контейнер?",
"options": ["docker attach", "docker exec -it", "docker shell", "docker run --inside"],
"correct": 1
},
{
"text": "Как ограничить память контейнера?",
"options": ["--ram=512m", "--memory=512m", "--mem-limit=512m", "Docker не позволяет ограничить память"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Docker (Junior)",
"content": "Финальный тест по Docker. 25+ вопросов на все ключевые темы: архитектура, образы, Dockerfile, сети, тома, безопасность, диагностика.",
"questions": [
{
"text": "Что такое Docker?",
"options": ["Гипервизор для VM", "Платформа контейнеризации на основе ядра Linux", "Менеджер пакетов", "Сетевой протокол"],
"correct": 1
},
{
"text": "В чём разница между образом и контейнером?",
"options": ["Образ — запущенный экземпляр, контейнер — шаблон", "Контейнер — запущенный экземпляр образа", "Нет разницы", "Образ хранится в облаке, контейнер — локально"],
"correct": 1
},
{
"text": "Какая инструкция в Dockerfile задаёт базовый образ?",
"options": ["BASE", "IMAGE", "FROM", "COPY"],
"correct": 2
},
{
"text": "Что делает инструкция EXPOSE в Dockerfile?",
"options": ["Открывает порт на хосте", "Указывает, какие порты использует приложение (документация)", "Блокирует порт", "Перенаправляет трафик"],
"correct": 1
},
{
"text": "Какой командой собрать образ из Dockerfile?",
"options": ["docker run", "docker build", "docker create", "docker compose"],
"correct": 1
},
{
"text": "Что такое multi-stage build?",
"options": ["Сборка образа на нескольких серверах", "Многоэтапная сборка для уменьшения размера финального образа", "Сборка с несколькими Dockerfile", "Тип сети"],
"correct": 1
},
{
"text": "Какой файл исключает ненужные файлы из COPY в Dockerfile?",
"options": [".gitignore", ".dockerignore", "exclude.txt", "Dockerfile.ignore"],
"correct": 1
},
{
"text": "В чём разница между ADD и COPY?",
"options": ["ADD только копирует, COPY может распаковывать", "COPY только копирует, ADD может распаковывать архивы и скачивать URL", "Нет разницы", "ADD работает только в Compose"],
"correct": 1
},
{
"text": "Как переопределить ENTRYPOINT при запуске контейнера?",
"options": ["Это невозможно", "Через --entrypoint", "Через -e", "Через docker update"],
"correct": 1
},
{
"text": "Какой тип сети Docker используется по умолчанию?",
"options": ["host", "none", "bridge", "overlay"],
"correct": 2
},
{
"text": "Что такое bind mount?",
"options": ["Том, управляемый Docker", "Привязка директории хоста в контейнер", "Тип сети", "Метод шифрования"],
"correct": 1
},
{
"text": "Какой командой остановить контейнер грациозно?",
"options": ["docker kill", "docker stop", "docker pause", "docker rm"],
"correct": 1
},
{
"text": "Что делает docker pause?",
"options": ["Полностью останавливает контейнер", "Замораживает процессы, сохраняя состояние в памяти", "Удаляет контейнер", "Перезапускает контейнер"],
"correct": 1
},
{
"text": "Какой флаг ограничивает CPU до 0.5 ядра?",
"options": ["--cpus=0.5", "--cpu=0.5", "--cores=0.5", "--cpu-limit=0.5"],
"correct": 0
},
{
"text": "Почему важно запускать контейнер от непривилегированного пользователя?",
"options": ["Для ускорения работы", "Для безопасности (ограничение привилегий)", "Для совместимости с Windows", "Это требование Docker Hub"],
"correct": 1
},
{
"text": "Как посмотреть использование ресурсов контейнерами?",
"options": ["docker top", "docker stats", "docker ps -a", "docker info"],
"correct": 1
},
{
"text": "Что такое Docker Compose?",
"options": ["Инструмент для оркестрации кластеров", "Инструмент для запуска мультконтейнерных приложений из YAML", "Замена Docker", "Тип тома"],
"correct": 1
},
{
"text": "Какой командой увидеть список запущенных контейнеров?",
"options": ["docker list", "docker ps", "docker containers", "docker show"],
"correct": 1
},
{
"text": "Что делать, если сборка Dockerfile падает на шаге COPY?",
"options": ["Переустановить Docker", "Проверить, существуют ли файлы и не исключены ли они в .dockerignore", "Использовать ADD вместо COPY", "Запустить с --force"],
"correct": 1
},
{
"text": "Какой инструмент используется для сканирования уязвимостей в образах?",
"options": ["docker scan", "trivy", "clair", "Все вышеперечисленные"],
"correct": 3
},
{
"text": "Что такое cgroups в контексте Docker?",
"options": ["Технология изоляции файловой системы", "Технология ограничения ресурсов (CPU, RAM)", "Тип сети", "Метод аутентификации"],
"correct": 1
},
{
"text": "Какой командой удалить неиспользуемые образы и тома?",
"options": ["docker system prune", "docker clean", "docker rm -all", "docker prune"],
"correct": 0
},
{
"text": "Что такое healthcheck в Docker?",
"options": ["Проверка состояния диска хоста", "Инструкция для периодической проверки работоспособности приложения", "Метод шифрования", "Тип логов"],
"correct": 1
},
{
"text": "Какой командой подключиться к запущенному контейнеру и выполнить команду?",
"options": ["docker connect", "docker run --inside", "docker exec", "docker attach --command"],
"correct": 2
},
{
"text": "Что произойдёт, если не указать тег образа (например, nginx вместо nginx:alpine)?",
"options": ["Docker выберет случайный тег", "Будет использован тег latest", "Сборка упадёт", "Используется самый старый тег"],
"correct": 1
},
{
"text": "Какой командой посмотреть детали контейнера (сети, тома, переменные)?",
"options": ["docker info", "docker describe", "docker inspect", "docker details"],
"correct": 2
},
{
"text": "Что делает инструкция WORKDIR в Dockerfile?",
"options": ["Устанавливает права на файлы", "Задаёт рабочую директорию для последующих команд", "Копирует файлы", "Создаёт пользователя"],
"correct": 1
}
]
}
],
"kubernetes": [
{
"title": "Архитектура Kubernetes: Control Plane и Worker Nodes",
"content": "Kubernetes-кластер состоит из Control Plane (управляющий слой) и Worker Nodes (рабочие узлы). Control Plane: kube-apiserver — центральный API для управления, etcd — распределённое хранилище состояния кластера, kube-scheduler — распределяет поды по узлам, kube-controller-manager — управляет контроллерами (реплик, узлов и т.д.). На каждом Worker Node работает: kubelet — агент для запуска подов, kube-proxy — сетевой прокси для балансировки трафика, Container Runtime (containerd, CRI-O) — запускает контейнеры. Пользователь взаимодействует через kubectl → kube-apiserver → etcd. Контроллеры и планировщик реагируют на изменения — kubelet запускает поды. Это обеспечивает самовосстановление, масштабирование и отказоустойчивость.",
"questions": [
{
"text": "Какой компонент Kubernetes хранит всё состояние кластера?",
"options": ["kube-apiserver", "etcd", "kube-scheduler", "kubelet"],
"correct": 1
},
{
"text": "Какой компонент запускает контейнеры на рабочем узле?",
"options": ["kube-proxy", "kubelet", "kube-scheduler", "etcd"],
"correct": 1
},
{
"text": "Через какой компонент проходят все команды kubectl?",
"options": ["kube-scheduler", "kube-controller-manager", "kube-apiserver", "kubelet"],
"correct": 2
}
]
},
{
"title": "Основные объекты Kubernetes: Pod, Service, Deployment",
"content": "Pod — минимальная единица развёртывания, содержит 1+ контейнеров с общим сетевым пространством и томами. Service — предоставляет стабильный IP/DNS для доступа к группе подов (типы: ClusterIP, NodePort, LoadBalancer). Deployment — управляет репликами подов: масштабирование, rolling-обновления, откаты. Deployment создаёт ReplicaSet, который следит за количеством подов. ConfigMap и Secret хранят конфигурацию и чувствительные данные (пароли в base64). PersistentVolume (PV) и PersistentVolumeClaim (PVC) — для постоянного хранилища. Namespace изолирует ресурсы (prod, dev). Для запуска: `kubectl apply -f manifest.yml`.",
"questions": [
{
"text": "Что такое Pod в Kubernetes?",
"options": ["Группа сервисов", "Минимальная единица развёртывания (1+ контейнеров)", "Тип сети", "Хранилище конфигурации"],
"correct": 1
},
{
"text": "Какой тип Service открывает порт на всех узлах кластера?",
"options": ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"],
"correct": 1
},
{
"text": "Что делает Deployment?",
"options": ["Хранит пароли", "Управляет репликами подов с поддержкой обновлений", "Создаёт тома", "Обеспечивает сетевую изоляцию"],
"correct": 1
},
{
"text": "Где хранятся чувствительные данные в Kubernetes?",
"options": ["ConfigMap", "Secret", "PersistentVolume", "Namespace"],
"correct": 1
}
]
},
{
"title": "StatefulSet vs Deployment и управление состоянием",
"content": "Deployment — для stateless-приложений (веб-серверы, API): поды взаимозаменяемы, имена случайные, данные временные. StatefulSet — для stateful-приложений (БД, Kafka): каждый под имеет фиксированное имя (pod-0, pod-1), постоянный PersistentVolume, запуск/удаление в строгом порядке. StatefulSet использует volumeClaimTemplates для привязки уникального тома к каждому поду. Headless Service (без ClusterIP) позволяет обращаться напрямую к подам по DNS. Выбор: Deployment — для масштабируемых сервисов, StatefulSet — для баз данных и систем, где важен порядок и состояние.",
"questions": [
{
"text": "В чём ключевое отличие StatefulSet от Deployment?",
"options": ["StatefulSet не поддерживает реплики", "StatefulSet даёт фиксированные имена подов и постоянное хранилище", "Deployment работает только в облаке", "StatefulSet не использует PersistentVolume"],
"correct": 1
},
{
"text": "Для какого типа приложений подходит StatefulSet?",
"options": ["Nginx", "REST API", "MySQL", "Фронтенд-приложение"],
"correct": 2
},
{
"text": "Что такое Headless Service?",
"options": ["Сервис без IP, для прямого доступа к подам по DNS", "Сервис только для внутреннего трафика", "Балансировщик нагрузки", "Тип тома"],
"correct": 0
}
]
},
{
"title": "Сети, Ingress и CNI в Kubernetes",
"content": "Kubernetes использует плагины CNI (Calico, Flannel, WeaveNet) для настройки сети. Каждый под получает уникальный IP из диапазона podCIDR. Сервисы используют ClusterIP для внутренней балансировки. Для внешнего доступа: NodePort (порт на узле), LoadBalancer (облачный балансировщик), или Ingress — объект для маршрутизации HTTP/HTTPS-трафика по правилам (host, path). Ingress требует Ingress Controller (Nginx, Traefik). Ingress Controller завершает TLS, балансирует нагрузку и централизует входящий трафик. Для ограничения трафика между подами — NetworkPolicy.",
"questions": [
{
"text": "Как реализована сеть в Kubernetes?",
"options": ["Через iptables напрямую", "Через плагины CNI (Calico, Flannel)", "Через Docker-сеть", "Сеть не поддерживается"],
"correct": 1
},
{
"text": "Что делает Ingress Controller?",
"options": ["Хранит конфигурацию", "Маршрутизирует HTTP/HTTPS-трафик по правилам Ingress", "Создаёт PersistentVolume", "Управляет репликами"],
"correct": 1
},
{
"text": "Какой объект позволяет ограничить сетевое взаимодействие между подами?",
"options": ["Service", "NetworkPolicy", "ConfigMap", "Secret"],
"correct": 1
}
]
},
{
"title": "Безопасность, ресурсы и отказоустойчивость",
"content": "Безопасность: RBAC (Role-Based Access Control) ограничивает права пользователей и сервисных аккаунтов. Секреты (Secret) хранят данные в base64. Ресурсы: в контейнере указываются requests (гарантированные ресурсы) и limits (максимум). Это нужно для правильного планирования и предотвращения 'голодания' других подов. Отказоустойчивость: несколько master-узлов с etcd в кластере, размещение worker-узлов в разных зонах, liveness/readiness-пробы для самовосстановления, HPA (Horizontal Pod Autoscaler) для масштабирования по CPU/памяти. Резервное копирование etcd — критично для восстановления кластера.",
"questions": [
{
"text": "Что такое liveness probe?",
"options": ["Проверяет готовность пода к трафику", "Проверяет, жив ли под — перезапускает при сбое", "Проверяет запуск контейнера", "Проверяет использование CPU"],
"correct": 1
},
{
"text": "Как ограничить ресурсы контейнера в Kubernetes?",
"options": ["Через limits и requests в манифесте", "Через Dockerfile", "Через CNI", "Это невозможно"],
"correct": 0
},
{
"text": "Что обеспечивает RBAC в Kubernetes?",
"options": ["Сетевую изоляцию", "Управление правами доступа", "Балансировку нагрузки", "Хранение секретов"],
"correct": 1
},
{
"text": "Что делает HPA (Horizontal Pod Autoscaler)?",
"options": ["Масштабирует ноды", "Масштабирует количество подов по метрикам", "Создаёт резервные копии", "Управляет томами"],
"correct": 1
}
]
},
{
"title": "Диагностика и продвинутые объекты: DaemonSet, Job, Helm",
"content": "DaemonSet запускает под на каждом узле — для мониторинга (Node Exporter), логирования (Fluentd). Job запускает под до завершения задачи (миграции, резервное копирование). CronJob — периодический запуск Job по расписанию. Helm — менеджер пакетов для Kubernetes: упрощает развёртывание через шаблоны (Charts), управление версиями и откаты. Диагностика: `kubectl get pods`, `kubectl describe pod`, `kubectl logs`, `kubectl top pods` (требует Metrics Server). Если под в статусе CrashLoopBackOff — проверяйте логи и liveness-пробы. Если Pending — не хватает ресурсов или нет подходящего узла.",
"questions": [
{
"text": "Для чего используется DaemonSet?",
"options": ["Для запуска пода на каждом узле", "Для масштабирования веб-приложения", "Для хранения конфигурации", "Для балансировки трафика"],
"correct": 0
},
{
"text": "Что такое Helm?",
"options": ["Сетевой плагин", "Менеджер пакетов для Kubernetes", "Тип тома", "Контроллер реплик"],
"correct": 1
},
{
"text": "Какой объект запускает задачу по расписанию?",
"options": ["Deployment", "StatefulSet", "CronJob", "Service"],
"correct": 2
}
]
},
{
"title": "Итоговый тест: Kubernetes (Junior)",
"content": "Финальный тест по Kubernetes. 25+ вопросов на архитектуру, объекты, сети, безопасность и диагностику.",
"questions": [
{
"text": "Что такое Kubernetes?",
"options": ["Менеджер пакетов", "Платформа для оркестрации контейнеров", "Тип виртуальной машины", "Сетевой протокол"],
"correct": 1
},
{
"text": "Какой компонент выбирает узел для запуска пода?",
"options": ["kubelet", "kube-scheduler", "kube-proxy", "etcd"],
"correct": 1
},
{
"text": "Что хранится в etcd?",
"options": ["Логи подов", "Всё состояние кластера", "Образы контейнеров", "Сетевые правила"],
"correct": 1
},
{
"text": "Может ли Pod содержать несколько контейнеров?",
"options": ["Нет, только один", "Да, обычно основной + sidecar", "Только в StatefulSet", "Только в Job"],
"correct": 1
},
{
"text": "Какой объект обеспечивает стабильный доступ к подам?",
"options": ["Pod", "Deployment", "Service", "ConfigMap"],
"correct": 2
},
{
"text": "В чём разница между Deployment и ReplicaSet?",
"options": ["Нет разницы", "ReplicaSet поддерживает обновления", "Deployment использует ReplicaSet и добавляет обновления/откаты", "Deployment не поддерживает реплики"],
"correct": 2
},
{
"text": "Для чего используется readiness probe?",
"options": ["Перезапускать под при сбое", "Определять, готов ли под к трафику", "Проверять запуск контейнера", "Измерять CPU"],
"correct": 1
},
{
"text": "Какой тип Service создаёт внешний балансировщик в облаке?",
"options": ["ClusterIP", "NodePort", "LoadBalancer", "Headless"],
"correct": 2
},
{
"text": "Что такое PersistentVolumeClaim (PVC)?",
"options": ["Физический диск", "Запрос на выделение постоянного тома", "Тип сети", "Конфигурация пода"],
"correct": 1
},
{
"text": "Где хранятся пароли и ключи в Kubernetes?",
"options": ["ConfigMap", "Secret", "PersistentVolume", "Deployment"],
"correct": 1
},
{
"text": "Что делает kubelet?",
"options": ["Маршрутизирует трафик", "Запускает и управляет подами на узле", "Хранит состояние кластера", "Планирует размещение подов"],
"correct": 1
},
{
"text": "Какой объект используется для stateful-приложений?",
"options": ["Deployment", "StatefulSet", "DaemonSet", "Job"],
"correct": 1
},
{
"text": "Что такое Ingress?",
"options": ["Тип тома", "Объект для маршрутизации HTTP/HTTPS", "Контроллер реплик", "Тип секрета"],
"correct": 1
},
{
"text": "Как запустить под на каждом узле?",
"options": ["Deployment", "StatefulSet", "DaemonSet", "ReplicaSet"],
"correct": 2
},
{
"text": "Что такое Horizontal Pod Autoscaler (HPA)?",
"options": ["Масштабирует ноды", "Масштабирует поды по CPU/памяти", "Балансирует трафик", "Управляет томами"],
"correct": 1
},
{
"text": "Какой командой посмотреть логи пода?",
"options": ["kubectl logs", "kubectl describe", "kubectl get", "kubectl top"],
"correct": 0
},
{
"text": "Что такое Namespace?",
"options": ["Тип сети", "Логическая изоляция ресурсов", "Хранилище образов", "Контейнерный рантайм"],
"correct": 1
},
{
"text": "Какой компонент управляет сетевыми правилами на узле?",
"options": ["kubelet", "kube-proxy", "CNI", "etcd"],
"correct": 1
},
{
"text": "Что произойдёт, если под не уложится в requests по памяти?",
"options": ["Он не запустится", "Он будет убит OOM Killer", "Он продолжит работать", "Kubernetes увеличит лимит автоматически"],
"correct": 0
},
{
"text": "Какой объект запускает задачу до завершения?",
"options": ["Deployment", "StatefulSet", "Job", "DaemonSet"],
"correct": 2
},
{
"text": "Что такое Helm Chart?",
"options": ["Тип тома", "Шаблон развёртывания приложения", "Сетевой плагин", "Контроллер безопасности"],
"correct": 1
},
{
"text": "Какой статус у пода, если он постоянно падает и перезапускается?",
"options": ["Running", "Pending", "CrashLoopBackOff", "Succeeded"],
"correct": 2
},
{
"text": "Что такое RBAC в Kubernetes?",
"options": ["Сетевой контроллер", "Система управления доступом на основе ролей", "Тип тома", "Протокол аутентификации"],
"correct": 1
},
{
"text": "Какой командой применить манифест?",
"options": ["kubectl create", "kubectl apply", "kubectl run", "kubectl start"],
"correct": 1
},
{
"text": "Сколько экземпляров Control Plane нужно для HA?",
"options": ["1", "2", "3 или нечётное число", "Зависит от количества подов"],
"correct": 2
}
]
}
],
"cicd": [
{
"title": "Основы CI/CD: что такое pipeline?",
"content": "CI/CD — это практика автоматизации этапов разработки и доставки ПО. CI (Continuous Integration) — непрерывная интеграция: при каждом коммите в Git запускается pipeline для сборки кода и запуска тестов. CD (Continuous Delivery/Deployment) — непрерывная доставка/развёртывание: после прохождения тестов артефакт автоматически доставляется в staging или сразу в production. Pipeline — последовательность этапов (stages): checkout → build → test → deploy. Основная цель: быстрая и безопасная доставка изменений с минимальным участием человека.",
"questions": [
{
"text": "Что означает CI в CI/CD?",
"options": ["Continuous Installation", "Continuous Integration", "Code Inspection", "Container Infrastructure"],
"correct": 1
},
{
"text": "В чём разница между Continuous Delivery и Continuous Deployment?",
"options": ["Delivery — ручной релиз, Deployment — автоматический", "Delivery — только для тестов, Deployment — для продакшена", "Нет разницы", "Deployment не использует Git"],
"correct": 0
},
{
"text": "Когда запускается CI pipeline?",
"options": ["Раз в день", "При каждом коммите в Git", "Только при релизе", "Вручную администратором"],
"correct": 1
}
]
},
{
"title": "Git, ветвление и триггеры",
"content": "Git — основа CI/CD. Популярные стратегии ветвления: GitFlow (feature → develop → release → main) и trunk-based development (все работают в main, используют фича-флаги). CI pipeline запускается по триггеру: push в ветку, pull request, тег. Например, в GitHub Actions: `on: [push, pull_request]`. Важно: pipeline должен быть идемпотентным (повторный запуск даёт тот же результат) и быстрым (идеально — <10 минут). Для ускорения — кэширование зависимостей (npm, pip) и параллельное выполнение задач.",
"questions": [
{
"text": "Какая стратегия ветвления предполагает частые коммиты в main?",
"options": ["GitFlow", "Trunk-based development", "Release branching", "Feature toggling"],
"correct": 1
},
{
"text": "Что может быть триггером для CI pipeline?",
"options": ["Только ручной запуск", "Push в Git-ветку", "Изменение DNS", "Перезагрузка сервера"],
"correct": 1
},
{
"text": "Как ускорить CI pipeline?",
"options": ["Убрать все тесты", "Использовать кэширование и параллельные задачи", "Запускать ночью", "Использовать самые дешёвые runner'ы"],
"correct": 1
}
]
},
{
"title": "GitHub Actions и GitLab CI: основы",
"content": "GitHub Actions и GitLab CI — встроенные системы CI/CD в Git-платформы. Workflow (в GH Actions) или Pipeline (в GitLab CI) описывается в YAML-файле в папке `.github/workflows/` или `.gitlab-ci.yml`. Основные блоки: jobs (задачи), steps (шаги), runners (машины для выполнения). Пример: собрать Docker-образ → прогнать тесты → отправить в registry. Secrets (секреты) хранятся в настройках репозитория и подставляются в pipeline как переменные окружения. Важно: никогда не храните секреты в коде!",
"questions": [
{
"text": "Где описывается pipeline в GitHub Actions?",
"options": [".gitlab-ci.yml", ".github/workflows/*.yml", "Dockerfile", "package.json"],
"correct": 1
},
{
"text": "Где в GitLab CI хранится конфигурация pipeline?",
"options": [".github/workflows/ci.yml", ".gitlab-ci.yml", "Jenkinsfile", "Makefile"],
"correct": 1
},
{
"text": "Как безопасно использовать пароли/API-ключи в CI?",
"options": ["Хранить в коде", "Передавать в коммитах", "Использовать Secrets в настройках репозитория", "Писать в логи"],
"correct": 2
}
]
},
{
"title": "Артефакты, образы и стратегии деплоя",
"content": "Артефакт — результат сборки: исполняемый файл, Docker-образ, пакет. Docker-образы пушатся в registry (Docker Hub, GitLab Registry, AWS ECR). Важно: тегировать образы по Git-хешу или версии (не использовать latest!). Стратегии деплоя: 1) Rolling update — постепенная замена подов (K8s по умолчанию). 2) Blue/Green — два идентичных окружения, переключение трафика. 3) Canary — выпуск новой версии части пользователей. Выбор зависит от требований к uptime и риску. Canary позволяет быстро откатиться при ошибках.",
"questions": [
{
"text": "Почему не стоит использовать тег latest для образов в CI/CD?",
"options": ["Он самый большой", "Он нестабилен и ломает воспроизводимость", "Он не поддерживается в K8s", "Он бесплатный"],
"correct": 1
},
{
"text": "Какая стратегия деплоя подразумевает переключение трафика между двумя окружениями?",
"options": ["Rolling update", "Blue/Green", "Canary", "Recreate"],
"correct": 1
},
{
"text": "Что такое артефакт в CI/CD?",
"options": ["Исходный код", "Результат сборки (образ, бинарник)", "Лог ошибок", "Git-коммит"],
"correct": 1
},
{
"text": "Какая стратегия деплоя выпускает новую версию для части пользователей?",
"options": ["Blue/Green", "Rolling", "Canary", "Hotfix"],
"correct": 2
}
]
},
{
"title": "Безопасность и продвинутые практики",
"content": "Безопасность в CI/CD: 1) Secrets — только через защищённые переменные, никогда в коде. 2) SAST (Static Application Security Testing) — анализ кода на уязвимости (например, через Snyk, Trivy, SonarQube). 3) Сканирование Docker-образов на CVE. 4) Минимальные права для runner'ов. Продвинутые практики: 1) GitOps — деплой через Git (FluxCD, ArgoCD). 2) Infrastructure as Code (Terraform) в pipeline. 3) Тесты в production-подобной среде (staging). 4) Откат по Git-тегу или Helm-релизу. CI/CD — не просто автоматизация, а культура доставки ценности быстро и безопасно.",
"questions": [
{
"text": "Что такое SAST?",
"options": ["Сканирование образов", "Статический анализ кода на уязвимости", "Тестирование нагрузки", "Балансировка трафика"],
"correct": 1
},
{
"text": "Какой подход использует Git как единственный источник истины для деплоя?",
"options": ["CI/CD", "GitOps", "DevSecOps", "Trunk-based"],
"correct": 1
},
{
"text": "Где НЕЛЬЗЯ хранить секреты (пароли, ключи)?",
"options": ["В Secrets репозитория", "В переменных окружения CI", "В исходном коде", "В HashiCorp Vault"],
"correct": 2
}
]
},
{
"title": "Итоговый тест: CI/CD (Junior)",
"content": "Финальный тест по CI/CD. 15 вопросов на основы, Git, пайплайны, деплой и безопасность.",
"questions": [
{
"text": "Что такое CI/CD?",
"options": ["Система мониторинга", "Практика автоматизации сборки, тестов и деплоя", "Тип виртуальной машины", "Протокол передачи данных"],
"correct": 1
},
{
"text": "Когда запускается CI pipeline в идеальном сценарии?",
"options": ["Раз в неделю", "При ручной команде", "При каждом коммите в Git", "Только в продакшене"],
"correct": 2
},
{
"text": "Где в GitHub хранится конфигурация Actions?",
"options": [".gitlab-ci.yml", ".github/workflows/", "Jenkinsfile", "/ci/"],
"correct": 1
},
{
"text": "Что такое артефакт в CI/CD?",
"options": ["Исходный код", "Результат сборки (например, Docker-образ)", "Git-ветка", "Лог ошибки"],
"correct": 1
},
{
"text": "Какой стратегией деплоя K8s использует по умолчанию?",
"options": ["Blue/Green", "Canary", "Rolling update", "Recreate"],
"correct": 2
},
{
"text": "Почему важно не использовать latest-тег для образов?",
"options": ["Он медленнее", "Он нарушает воспроизводимость и стабильность", "Он не поддерживается", "Он занимает больше места"],
"correct": 1
},
{
"text": "Как безопасно передать API-ключ в pipeline?",
"options": ["Закодировать в base64 в коде", "Использовать Secrets в настройках репозитория", "Написать в README", "Передать через коммит"],
"correct": 1
},
{
"text": "Что такое trunk-based development?",
"options": ["Работа в долгоживущих ветках", "Частые коммиты в main/trunk", "Использование только тегов", "Отказ от Git"],
"correct": 1
},
{
"text": "Какой инструмент относится к GitOps?",
"options": ["Jenkins", "GitHub Actions", "ArgoCD", "Prometheus"],
"correct": 2
},
{
"text": "Что делает SAST-инструмент?",
"options": ["Сканирует образы", "Анализирует исходный код на уязвимости", "Тестирует производительность", "Балансирует нагрузку"],
"correct": 1
},
{
"text": "Какая стратегия деплоя позволяет быстро откатиться, протестировав на части пользователей?",
"options": ["Rolling", "Blue/Green", "Canary", "Recreate"],
"correct": 2
},
{
"text": "Где в GitLab CI описывается pipeline?",
"options": [".github/workflows/ci.yml", ".gitlab-ci.yml", "Makefile", "Dockerfile"],
"correct": 1
},
{
"text": "Что такое Continuous Deployment?",
"options": ["Ручной релиз после тестов", "Автоматический деплой в продакшен после прохождения тестов", "Только сборка кода", "Только запуск тестов"],
"correct": 1
},
{
"text": "Какой принцип CI/CD помогает избежать 'integration hell'?",
"options": ["Редкие коммиты", "Частая интеграция и тестирование", "Использование только main-ветки", "Отказ от тестов"],
"correct": 1
},
{
"text": "Что такое runner в CI/CD?",
"options": ["Автор пайплайна", "Машина, на которой выполняются задачи", "Тип артефакта", "Сервис мониторинга"],
"correct": 1
}
]
}
],
"monitoring": [
{
"title": "Основы мониторинга: Observability и её три кита",
"content": "Observability (наблюдаемость) — способность понимать внутреннее состояние системы по её внешним сигналам. Три кита observability: 1) Метрики — числовые данные во времени (CPU, память, количество запросов). 2) Логи — текстовые записи о событиях (ошибки, запросы). 3) Трейсы — цепочки вызовов в распределённой системе (как запрос прошёл через микросервисы). Мониторинг — сбор и анализ этих данных для выявления проблем до того, как их заметят пользователи. Health-checks (liveness/readiness) — часть мониторинга: они говорят оруркестратору (K8s), живо ли приложение и готово ли к трафику.",
"questions": [
{
"text": "Какие три компонента составляют observability?",
"options": ["CPU, RAM, Disk", "Метрики, логи, трейсы", "HTTP, TCP, ICMP", "Pods, Services, Deployments"],
"correct": 1
},
{
"text": "Что такое liveness probe в Kubernetes?",
"options": ["Проверка готовности к трафику", "Проверка, живо ли приложение (перезапуск при сбое)", "Сбор логов", "Измерение latency"],
"correct": 1
},
{
"text": "Зачем нужен readiness probe?",
"options": ["Для перезапуска пода", "Чтобы Kubernetes не отправлял трафик, пока приложение не готово", "Для сбора метрик CPU", "Для резервного копирования"],
"correct": 1
}
]
},
{
"title": "Prometheus: сбор и хранение метрик",
"content": "Prometheus — система мониторинга с открытым исходным кодом, специально созданная для сбора метрик. Работает по pull-модели: опрашивает (scrape) цели (targets) по HTTP-эндпоинту `/metrics` с заданной периодичностью. Метрики хранятся в собственной TSDB (time-series базе данных). Поддерживает мощный язык запросов PromQL для анализа и агрегации. Экспортеры (node_exporter, cadvisor) собирают метрики с хостов, контейнеров, баз данных. В Kubernetes Prometheus обнаруживает сервисы через ServiceMonitor или ingress.",
"questions": [
{
"text": "Как работает Prometheus?",
"options": ["Push-модель (приложение отправляет метрики)", "Pull-модель (Prometheus опрашивает эндпоинты)", "Через логи", "Только в облаке"],
"correct": 1
},
{
"text": "Какой эндпоинт использует Prometheus для сбора метрик?",
"options": ["/health", "/logs", "/metrics", "/status"],
"correct": 2
},
{
"text": "Какой инструмент собирает метрики с Linux-хоста для Prometheus?",
"options": ["Filebeat", "node_exporter", "Loki", "Alertmanager"],
"correct": 1
}
]
},
{
"title": "Grafana: визуализация данных",
"content": "Grafana — платформа для визуализации метрик, логов и трейсов. Она подключается к источникам данных (например, Prometheus, Loki, Elasticsearch) и отображает информацию на дашбордах. Дашборды состоят из панелей: графики, таблицы, статусные индикаторы. Grafana позволяет строить сложные визуализации, задавать переменные (например, выбор ноды), настраивать аннотации (деплои, инциденты). В DevOps Grafana — стандарт для отображения состояния инфраструктуры и приложений в реальном времени.",
"questions": [
{
"text": "Какой источник данных чаще всего используется с Grafana для метрик?",
"options": ["Loki", "Prometheus", "Filebeat", "Kibana"],
"correct": 1
},
{
"text": "Что такое дашборд в Grafana?",
"options": ["Скрипт для сбора метрик", "Веб-интерфейс для визуализации данных", "Тип алерта", "Экспортёр"],
"correct": 1
},
{
"text": "Можно ли в Grafana отображать логи и метрики на одном дашборде?",
"options": ["Нет, только метрики", "Да, если настроены соответствующие источники", "Только через Kibana", "Это невозможно по архитектуре"],
"correct": 1
}
]
},
{
"title": "Алертинг: Alertmanager и реакция на инциденты",
"content": "Алертинг — система уведомлений о проблемах. В экосистеме Prometheus за это отвечает Alertmanager. Правила алертов (alerting rules) задаются в Prometheus: например, 'если CPU > 90% 5 минут, создать алерт'. Prometheus отправляет алерты в Alertmanager, который дедуплицирует, группирует и отправляет уведомления в Slack, Email, PagerDuty и т.д. Важно: алерты должны быть actionable (можно предпринять действие), избегать шума (alert fatigue). Пример полезного алерта: 'HTTP-ошибки 5xx > 1% за 5 минут'.",
"questions": [
{
"text": "Какой компонент отвечает за отправку уведомлений в экосистеме Prometheus?",
"options": ["Grafana", "node_exporter", "Alertmanager", "kube-state-metrics"],
"correct": 2
},
{
"text": "Где задаются правила алертов?",
"options": ["В Alertmanager", "В Grafana", "В Prometheus", "В самом приложении"],
"correct": 2
},
{
"text": "Что такое 'alert fatigue'?",
"options": ["Усталость от большого количества бесполезных алертов", "Сбой в Alertmanager", "Задержка уведомлений", "Ошибка в PromQL"],
"correct": 0
}
]
},
{
"title": "Логи: от сбора до анализа",
"content": "Логи — текстовые записи о событиях в приложении или системе. Сбор логов в Kubernetes часто делают через sidecar-контейнеры или демонсеты (Fluentd, Fluent Bit). Популярные стеки: ELK (Elasticsearch, Logstash, Kibana) и EFK (Fluentd вместо Logstash). Лёгкая альтернатива — Grafana Loki: хранит логи без полного индексирования (дешевле), интегрируется с Grafana. LogQL — язык запросов для Loki. Важно: структурированные логи (JSON) проще парсить и фильтровать. Не храните всё — задайте политику ретеншена (например, 7 дней).",
"questions": [
{
"text": "Какой стек включает Elasticsearch, Fluentd и Kibana?",
"options": ["ELK", "EFK", "PLG", "GEL"],
"correct": 1
},
{
"text": "Какой инструмент является лёгкой альтернативой ELK для логов?",
"options": ["Prometheus", "Loki", "Alertmanager", "cadvisor"],
"correct": 1
},
{
"text": "Почему структурированные логи (JSON) лучше?",
"options": ["Они занимают меньше места", "Их проще парсить и фильтровать", "Они шифруются автоматически", "Они не требуют сбора"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Мониторинг (Junior)",
"content": "Финальный тест по мониторингу. 15 вопросов на observability, Prometheus, Grafana, алертинг и логи.",
"questions": [
{
"text": "Что из перечисленного НЕ является частью observability?",
"options": ["Метрики", "Логи", "Трейсы", "Бэкапы"],
"correct": 3
},
{
"text": "Какой компонент собирает метрики с хостов для Prometheus?",
"options": ["Grafana", "Alertmanager", "node_exporter", "Loki"],
"correct": 2
},
{
"text": "Как Prometheus получает метрики от приложений?",
"options": ["Приложение отправляет метрики (push)", "Prometheus опрашивает эндпоинт /metrics (pull)", "Через логи", "Через Kubernetes API"],
"correct": 1
},
{
"text": "Какой инструмент визуализирует данные из Prometheus?",
"options": ["Kibana", "Loki", "Grafana", "Elasticsearch"],
"correct": 2
},
{
"text": "Что делает Alertmanager?",
"options": ["Собирает метрики", "Хранит логи", "Отправляет уведомления об алертах", "Строит дашборды"],
"correct": 2
},
{
"text": "Где задаются правила для создания алертов?",
"options": ["В Grafana", "В Alertmanager", "В конфигурации Prometheus", "В самом приложении"],
"correct": 2
},
{
"text": "Какой стек использует Fluentd вместо Logstash?",
"options": ["ELK", "EFK", "PLG", "Loki-Grafana"],
"correct": 1
},
{
"text": "Какой инструмент хранит логи и интегрируется с Grafana?",
"options": ["Prometheus", "Loki", "node_exporter", "cadvisor"],
"correct": 1
},
{
"text": "Что проверяет readiness probe в Kubernetes?",
"options": ["Живо ли приложение", "Готово ли приложение принимать трафик", "Сколько памяти использует приложение", "Есть ли ошибки в логах"],
"correct": 1
},
{
"text": "Какой язык запросов используется в Prometheus?",
"options": ["SQL", "LogQL", "PromQL", "Elasticsearch DSL"],
"correct": 2
},
{
"text": "Почему важно избегать 'alert fatigue'?",
"options": ["Это замедляет Grafana", "Команда игнорирует важные алерты", "Это увеличивает стоимость хранения", "Это ломает Prometheus"],
"correct": 1
},
{
"text": "Какой компонент Kubernetes предоставляет метрики о подах и нодах?",
"options": ["kube-proxy", "kubelet", "kube-state-metrics", "coredns"],
"correct": 2
},
{
"text": "Что такое дашборд в Grafana?",
"options": ["Сервер для хранения логов", "Коллекция визуализаций на одной странице", "Правило для алертов", "Экспортёр метрик"],
"correct": 1
},
{
"text": "Какой формат логов предпочтительнее для автоматического анализа?",
"options": ["Plain text", "XML", "JSON", "CSV"],
"correct": 2
},
{
"text": "Какой минимальный полезный алерт вы бы настроили для веб-сервиса?",
"options": ["CPU > 50%", "Доступность /health = false", "Количество логов > 1000/мин", "Изменение версии образа"],
"correct": 1
}
]
}
]
}