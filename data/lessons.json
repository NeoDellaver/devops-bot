{
  "linux": [
    {
      "title": "Load Average: что это и как интерпримировать в реальных системах",
      "content": "**Рик говорит: Load Average в Linux — разжёвываю для особо тугих**\n\nЭй, пацаны, слушайте сюда! Сегодня дед Рик объяснит вам, что такое Load Average в Linux. Не вздумайте путаться — это не какой-то там процент загрузки процессора, как некоторые дебилы думают. Нет, это среднее количество процессов, которые либо уже в деле (состояние R — running), либо ждут своих ресурсов (состояние D — uninterruptible sleep), скажем, пока диск что-то там обработает. И считается это за последние 1, 5 и 15 минут.\n\nПонимаете, если у вас сервер с тысячей процессоров и Load Average показывает 900, 900, 900 — это ещё ничего, вполне себе норм. Система просто параллельно ворочает тысячу задач. А вот если у вас сервак на четырёх ядрах и там такие же цифры — всё, пипец, катастрофа! Система перегружена, не справляется.\n\nА ещё фишка в том, что процессы в состоянии D (те, что в «беспробудном сне» и ждут дискового I/O, например) тоже учитываются в Load Average. Поэтому, если видите высокий показатель, не спешите орать: «Процессор перегружен!» Может, у вас просто диск тормозит или NFS лагает.\n\nКак это диагностировать? Держите, пацаны, мои любимые команды:\n\n1. **top** — смотрите колонку с CPU (%us, %sy, %wa). Там увидите, кто и сколько жрёт ресурсов.\n2. **iostat -x 1** — глядите на %util и await. Это покажет, как ваш диск работает, нет ли там заторов.\n3. **vmstat 1** — смотрите поля r (число процессов в runnable состоянии) и b (процессы в uninterruptible). Это даст вам представление о том, что творится в системе.\n\nDevOps-инженер, слушай сюда: ты должен уметь отличать «здоровую» нагрузку от «больной». «Здоровая» — это когда у тебя на многопроцессорной системе полно R-процессов, и все работают как надо. «Больная» — когда у тебя куча D-процессов, и всё из-за проблем с диском.\n\nИ ещё, пацаны, запомните: Load Average не подстраивается под количество ядер. Это абсолютное число, и его надо всегда рассматривать в контексте вашей аппаратуры. Не забывайте смотреть, с чем имеете дело!\n\n**Хэштеги:** #Linux #LoadAverage #DevOps #Сервер #Диагностика\n\n**Советы от деда Рика:**\n1. Не путай Load Average с процентом загрузки CPU.\n2. Всегда учитывай количество ядер при анализе Load Average.\n3. Используй команды top, iostat и vmstat для детальной диагностики.\n4. Учись отличать «здоровую» нагрузку от «больной».\n5. Не игнорируй проблемы с I/O — они могут быть причиной высокого Load Average.",
      "questions": [
        {
          "text": "Текущая load average на сервере — 900, 900, 900. Сервер работает с незначительной потерей производительности. Как понять, нормально ли это?",
          "options": [
            "Это всегда авария",
            "Нужно сравнить с количеством CPU — если их ~1000, то норма",
            "Load average не может быть больше 100",
            "Это означает, что сломан мониторинг"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой можно увидеть, сколько процессов в состоянии runnable (R)?",
          "options": [
            "ps aux",
            "top",
            "vmstat",
            "iostat"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Swap: виртуальная память, swappiness и её влияние на производительность",
      "content": "**Рик говорит о swap: зачем он нужен и как с ним обращаться**\n\nЭй, пацанва! Рик тут, и я вам сейчас объясню, что такое swap и как с ним не облажаться. Короче, swap — это такая штука в Linux, которая позволяет системе использовать диск как дополнительную оперативку (RAM). Понял? Если у тебя в системе заканчивается физическая память, ядро Linux берёт и перекидывает редко используемые кусочки памяти из RAM на специальный swap-раздел или файл. Это, типа, спасательный круг, чтобы система не начала аварийно завершать процессы (OOM Killer, слыхали?). Но есть нюанс — диск работает намного медленнее, чем RAM, так что если ты слишком часто будешь пользоваться swap, система начнёт тормозить.\n\nЕсть такой параметр — `vm.swappiness`, он регулирует, насколько активно ядро будет использовать swap. Шкала от 0 до 100. Если стоит 60 (а по умолчанию именно так), то ядро будет агрессивно использовать swap, даже если в RAM ещё есть свободное место. Для баз данных типа PostgreSQL или MySQL лучше поставить `swappiness=1`, чтобы своппинг был минимальным. Но вот что вам скажу: полностью отключать swap — плохая идея. Если вдруг памяти не хватит, OOM Killer может прикончить какой-нибудь критический процесс, и всё, привет, проблемы.\n\nА ещё swap нужен для гибернации — когда ты выключаешь комп, а система сохраняет состояние RAM на диск. В контейнерных средах swap часто отключают, потому что там управление памятью ложится на cgroups.\n\nКак понять, что там у тебя с swap? Есть несколько команд:\n1. `free -h` — покажет, сколько swap используется.\n2. `vmstat 1` — тут смотри на поля `si` (swap in) и `so` (swap out).\n3. `cat /proc/sys/vm/swappiness` — покажет текущее значение параметра `vm.swappiness`.\n\nDevOps, слушай сюда! Тебе нужно настраивать `swappiness` в зависимости от того, какая у тебя нагрузка:\n1. Для stateful-сервисов — своп должен быть минимальным.\n2. Для batch-обработки — можно поставить значение повыше.\n\n**Хэштеги:** #Linux #swap #оперативнаяПамять #DevOps #системныйАдминистратор\n\n**Советы от Рика:**\n1. Не отключай swap полностью — чревато неприятностями.\n2. Для баз данных настрой `swappiness` на минимум.\n3. Регулярно проверяй состояние swap, чтобы не было сюрпризов.\n4. Учитывай тип нагрузки при настройке `swappiness`.\n5. Помни, что swap — это не панацея, а скорее костыль, так что лучше оптимизировать использование памяти.",
      "questions": [
        {
          "text": "Почему полностью отключать swap может быть опасно?",
          "options": [
            "Система не загрузится",
            "При нехватке памяти OOM Killer может убить важный процесс",
            "Диск перестанет работать",
            "Это нарушает POSIX"
          ],
          "correct": 1
        },
        {
          "text": "Какой параметр ядра регулирует агрессивность использования swap?",
          "options": [
            "vm.overcommit_memory",
            "vm.dirty_ratio",
            "vm.swappiness",
            "fs.file-max"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Процессы, файл /proc и статусы (R, S, D, Z): взгляд изнутри ядра",
      "content": "**Рик говорит: «Процессы в Linux? Пф, раз плюнуть!»**\n\nСлушай сюда, малой, я тебе объясню, как всё работает в этой вашей Linux. Каждый процесс там — это как маленький робот, который делает своё дело. У каждого робота есть свой уникальный номер, PID называется. Это как номер на футболке у футболиста — по нему можно понять, кто есть кто.\n\nВсе эти процессы живут в ядре системы, и информация о них хранится в виртуальной файловой системе /proc. Представь себе, что это такая секретная комната в памяти компьютера (RAM), где хранятся все данные о процессах. Если тебе нужно узнать, что делает какой-то процесс, просто загляни в /proc — там всё написано.\n\nНапример, хочешь узнать, что делает процесс с PID 1234? Заглядывай в `/proc/1234/status` — там ты найдёшь всю нужную инфу: имя процесса, сколько памяти он жрёт, UID (это типа идентификатора пользователя) и его статус.\n\nА статусы у процессов бывают разные, слушай:\n1. **R (running/runnable)** — процесс либо вовсю использует процессор (CPU), либо ждёт своей очереди. Типа как спортсмен на старте — готов рвануть.\n2. **S (sleeping)** — процесс ждёт какого-то события, например, пока ты что-нибудь введёшь. Как будто задремал и ждёт, когда его разбудят.\n3. **D (uninterruptible sleep)** — процесс ждёт операции ввода-вывода (I/O) и не реагирует на никакие сигналы. Это как если бы кто-то заснул так крепко, что даже громкая музыка его не разбудит.\n4. **Z (zombie)** — процесс уже завершился, но родительский процесс не обработал его завершение (не вызвал `wait()`). Получается такой «зомби» — вроде бы умер, но всё ещё болтается в системе. Это часто признак бага в родительском процессе.\n5. **T (stopped)** — процесс приостановлен, например, если ты нажал `Ctrl+Z`. Как будто нажал паузу на плеере.\n\nЗнаешь, почему это важно? Потому что процессы в состоянии D могут сделать систему «неподконтрольной». Их даже `kill -9` не берёт! А зомби-процессы — это вообще признак того, что что-то пошло не так в родительском процессе.\n\nЧтобы посмотреть, что за процессы у тебя бегают, можешь использовать команды:\n1. `ps aux` — покажет список процессов с их статусами (статус будет в колонке `STAT`).\n2. `top` — ещё одна команда, которая показывает процессы и их состояние в реальном времени.\n3. Или можешь напрямую заглянуть в /proc — там всё как на ладони.\n\nА PID 1 — это вообще царь всех процессов, init-процесс (systemd или init). Он как папа для всех остальных процессов. Если какой-то процесс остался без родителя, init-процесс его «усыновляет».\n\nDevOps-ы, слушайте сюда: если хотите быть крутыми, научитесь анализировать /proc. Там можно найти всё — от утечек памяти до зависаний и других аномалий.\n\n**Хэштеги:** #Linux #Процессы #PID #/proc #DevOps #РикЗнаетВсё\n\n**Советы:**\n1. Регулярно проверяй состояние процессов в системе — это поможет избежать многих проблем.\n2. Если видишь много «зомби», ищи проблему в родительском процессе.\n3. Изучай /proc — это твой ключ к пониманию того, что происходит в системе.\n4. Не пренебрегай командами `ps` и `top` — они могут спасти тебе жизнь (или, по крайней мере, много времени).",
      "questions": [
        {
          "text": "Какой статус процесса означает «uninterruptible sleep»?",
          "options": [
            "R",
            "S",
            "D",
            "Z"
          ],
          "correct": 2
        },
        {
          "text": "Где хранится информация о процессах в Linux?",
          "options": [
            "/etc/passwd",
            "/var/log",
            "/proc",
            "/sys"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Зомби и сироты: когда процессы не умирают до конца",
      "content": "**Рик говорит: зомби-процессы и сироты — разберёмся без лишних соплей!**\n\nХа-ха, слушай сюда, малыш! Сегодня я расскажу тебе про зомби-процессы и процессы-сироты. Звучит как сюжет для какого-нибудь дрянного фильма, но на самом деле это про то, что творится у тебя в системе, пока ты там в игры играешь или ещё чем занимаешься.\n\nИтак, представь: процесс в системе — это как какой-то там Морти, который бегает и делает свои дела. Но когда его «работа» заканчивается, он не исчезает просто так. Нет, он превращается в зомби! Ну, почти. В смысле, он становится «зомби-процессом». Его запись остаётся в таблице процессов, пока родительский процесс не скажет: «Эй, я знаю, что ты закончил, давай я заберу у тебя код завершения». Для этого родительский процесс должен вызвать системный вызов `wait()` или `waitpid()`.\n\nЗомби-процессы — это такие «полуживые» процессы, которые уже ничего не делают, не потребляют CPU или RAM, только занимают слот в таблице процессов. Но если их слишком много, они могут исчерпать PID-пространство — это как если бы у тебя было ограниченное количество мест для парковки, и все они были заняты бесполезными тачками.\n\nА теперь про сирот. Процесс-сирота — это процесс, чей родитель завершился. Представь, что твой родитель вдруг исчез, и ты остался один в этом безумном мире. Но не волнуйся, ядро системы не оставит тебя в беде! Оно передаёт управление таким «сиротам» PID 1 — это может быть systemd или init. Эти ребята периодически вызывают `wait()`, поэтому сироты не превращаются в зомби.\n\nЗомби же появляются, когда родительский процесс — полный неудачник и не обрабатывает сигнал SIGCHLD. Например, если он просто игнорирует этот сигнал, то его «дети» превращаются в зомби и болтаются в системе, занимая место.\n\nКак диагностировать зомби? Да легко! Используй команду `ps aux | grep 'Z'` или посмотри поле `STAT` в `top`. Но вот что важно: убить зомби напрямую нельзя. Нужно либо «разбудить» родителя, чтобы он обработал завершение своего «ребёнка», либо убить самого родителя. Тогда зомби станет сиротой, и PID 1 уберёт его из системы.\n\nА теперь про контейнеры. В контейнерах эта проблема может быть ещё хуже. Представь, что PID 1 — это не init-система, а просто какой-нибудь `nginx`. Он не обрабатывает SIGCHLD, и все дочерние процессы становятся зомби. Поэтому в Docker-образах часто используют `tini` как init-процесс. Это как иметь специального человека, который следит за тем, чтобы все «дети» были в порядке и не превращались в зомби.\n\n**Советы:**\n следи за своими процессами, чтобы не допустить «зомби-апокалипсиса» в системе;\n",
      "questions": [
        {
          "text": "Что такое зомби-процесс?",
          "options": [
            "Процесс, потребляющий 100% CPU",
            "Завершённый процесс, чей родитель не вызвал wait()",
            "Процесс без родителя",
            "Процесс в состоянии D"
          ],
          "correct": 1
        },
        {
          "text": "Почему в Docker-контейнерах часто возникают зомби?",
          "options": [
            "Docker блокирует сигналы",
            "PID 1 в контейнере не обрабатывает SIGCHLD",
            "Ядро не поддерживает зомби в namespace",
            "Контейнеры не имеют /proc"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Файловые системы в Linux: ext4, XFS, Btrfs и особенности работы",
      "content": "**Рик говорит о файловых системах: разжёвываю для самых тупых**\n\nЭй, пацаны, слушайте сюда! Сейчас дед Рик объяснит вам, что такое файловая система и как с ней не облажаться. Так что заткните свои порталы и слушайте внимательно!\n\nИтак, файловая система (ФС) — это, по сути, способ организации данных на диске. Представьте себе библиотеку, где всё аккуратно разложено по полкам. Вот примерно так и работает ФС. В Linux есть несколько популярных файловых систем: ext4, XFS и Btrfs. Давайте разберём их по полочкам.\n\n**ext4** — это как старый добрый надёжный автомобиль. Стабильная, журналируемая (записывает все изменения, чтобы в случае чего можно было восстановиться), поддерживает до 1 ЭБ данных. В общем, для универсального использования — самое то!\n\n**XFS** — это уже спорткар. Высокая производительность, особенно когда дело касается больших файлов. Часто используется в RHEL. Если у вас большие базы данных или логи — XFS будет отличным выбором.\n\n**Btrfs** — тут уже посложнее. Эта ФС поддерживает copy-on-write (при изменении файла создаётся его копия) и снапшоты (моментальные снимки состояния системы). Но будьте осторожны — в продакшене с ней нужно обращаться аккуратно.\n\nТеперь про inode (index node). Это такая структура, которая хранит метаданные файла: права доступа, владельца, временные метки, указатели на блоки данных. Представьте себе карточку в библиотеке, где написано, кто взял книгу, когда и на сколько. Вот это и есть inode.\n\nВажно понимать: имя файла хранится не в inode, а в директории. Директория — это просто список «имя → inode». То есть она связывает имя файла с его inode.\n\nЖёсткая ссылка (hard link) — это как ещё одна карточка в библиотеке, которая указывает на ту же книгу. То есть ещё одно имя, которое указывает на тот же inode. Когда вы удаляете файл, уменьшается счётчик ссылок. Данные удаляются только тогда, когда счётчик становится равен нулю.\n\nЧасто бывает такая ситуация: место на диске вроде есть, а система выдаёт «no space left on device». В чём дело? Скорее всего, закончились inodes. Проверить это можно командой `df -i`. В ext4 число inodes фиксировано при создании ФС, а XFS и Btrfs поддерживают динамические inodes.\n\nДля диагностики используйте следующие команды:\n* `df -h` — чтобы посмотреть, сколько места занято;\n* `df -i` — чтобы проверить количество inodes;\n* `du -sh /path` — чтобы узнать реальный размер файлов в указанной директории.\n\nDevOps-ы, слушайте сюда! Выбирайте ФС под задачу:\n* ext4 — для универсального использования;\n* XFS — если у вас большие файлы (базы данных, логи);\n* Btrfs — если нужны снапшоты, но помните — в продакшене с ней нужно быть осторожным.\n\n**Хэштеги:** #файловаясистема #Linux #ext4 #XFS #Btrfs #inode #DevOps\n\n**Советы от деда Рика:**\n1. Не забывайте проверять количество inodes, а не только свободное место на диске.\n2. Выбирайте файловую систему с учётом специфики задачи — не используйте один тип ФС для всего подряд.\n3. Изучите команды для диагностики файловой системы — они могут спасти вас в сложных ситуациях.\n4. С Btrfs будьте осторожны в продакшене — она может подкинуть вам пару сюрпризов.",
      "questions": [
        {
          "text": "При создании файла система возвращает ошибку 'no space left on device', но df показывает свободное место. В чём причина?",
          "options": [
            "Сломан диск",
            "Закончились inodes",
            "Нет прав на запись",
            "ФС не смонтирована"
          ],
          "correct": 1
        },
        {
          "text": "Где хранится информация об именах файлов?",
          "options": [
            "В inode",
            "В суперблоке",
            "В директории",
            "В журнале ФС"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Жёсткие и символьные ссылки: различия, применение и ограничения",
      "content": "**Рик говорит о ссылках в Linux: жёсткие и символьные — разберёмся!**\n\nЭй, пацаны, давайте я вам объясню, что такое ссылки в Linux. Я, Рик, знаю об этом всё, так что слушайте внимательно.\n\nВ Linux есть два типа ссылок: жёсткие (hard links) и символьные (symbolic или soft links). Давайте разберёмся, что это такое и в чём разница.\n\n**Жёсткие ссылки (hard links)** — это, по сути, новое имя для существующего файла. Представьте, что у вас есть файл, и вы даёте ему ещё одно имя. Оба имени — это как два указателя на один и тот же объект. Пока есть хотя бы одна ссылка, файл не удалится. То есть если вы удалите одно имя, файл всё равно останется доступным через другое имя.\n\nНо есть ограничения:\n* жёсткие ссылки работают только с файлами, а не с каталогами;\n* они не могут пересекать границы файловых систем (ФС).\n\nЧтобы создать жёсткую ссылку, используйте команду:\n```\nln file hardlink\n```\n\n**Символьные ссылки (symbolic links, или symlinks)** — это уже совсем другое дело. Это отдельный файл, который содержит путь к целевому файлу или каталогу. То есть это как ярлык на рабочем столе — он указывает на что-то, но сам по себе не является этим объектом.\n\nОсобенности символьных ссылок:\n могут указывать на каталоги;\n**Как проверить, какая ссылка перед вами?**\n\nИспользуйте команду `ls -l`. Символьные ссылки будут помечены как `lrwxrwxrwx` и покажут «-> цель». Жёсткие ссылки выглядят как обычные файлы, но если вы используете команду `ls -i`, то увидите, что у всех жёстких ссылок, указывающих на один файл, будет одинаковый inode.\n\n**Зачем всё это нужно?**\n\nДля DevOps-шников это особенно полезно:\n* жёсткие ссылки помогают экономить место на диске, например, в пакетных менеджерах;\n* символьные ссылки позволяют гибко организовывать пути, например, `/usr/bin/python -> python3.11`.\n\nНо есть нюанс: когда вы используете команду `cp`, по умолчанию она копирует файл, на который ссылается символьная ссылка, а не саму ссылку. Если вам нужно сохранить ссылку, используйте `cp -P`.\n\n**Советы от Рика:**\n внимательно проверяйте, с каким типом ссылки вы работаете, чтобы избежать неожиданных результатов;\n",
      "questions": [
        {
          "text": "В чём разница между жёсткой и символьной ссылкой?",
          "options": [
            "Жёсткая ссылка — это путь к файлу, символьная — inode",
            "Жёсткая ссылка указывает на inode, символьная — на путь",
            "Символьная ссылка не может быть удалена",
            "Жёсткая ссылка работает между ФС, символьная — нет"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой создаётся символьная ссылка?",
          "options": [
            "ln file link",
            "link file link",
            "ln -s target link",
            "symlink target link"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Процесс загрузки Linux: от кнопки питания до пользовательской сессии",
      "content": "**Рик говорит: «Загрузка Linux? Пфф, раз плюнуть!»**\n\nСлушай сюда, пацан, я тебе объясню, как загружается Linux. Только не скули, если что-то не поймёшь — это ж не твоя вина, просто мозги у тебя не такие крутые, как у меня.\n\nИтак, начнём с самого начала. Когда ты включаешь комп, процессор делает сброс и запускает код из прошивки. Да-да, есть два варианта: старый добрый BIOS и модный UEFI. BIOS — это как дедушка, который всё ещё носит подтяжки и не понимает, как работает смартфон. А UEFI — это уже что-то более современное, типа последних моделей космических кораблей, которые я конструирую.\n\nBIOS инициализирует железо — то есть проверяет, всё ли на месте и работает ли. Потом ищет MBR — это такие первые 512 байт диска. И запускает загрузчик, например, GRUB Stage 1. А UEFI использует FAT32-раздел (ESP) и запускает EFI-приложение, например, grubx64.efi.\n\nДальше GRUB 2 загружает конфигурацию, показывает тебе меню и загружает ядро (vmlinuz) и initramfs — это такой временный RAM-диск с драйверами. Зачем? А чтобы смонтировать корневую файловую систему, особенно если у тебя там LVM, RAID или шифрование.\n\nПотом ядро распаковывает initramfs, монтирует корневую файловую систему и запускает init-процесс (PID 1). Раньше это был SysVinit, а сейчас — systemd. Systemd — это такой крутой парень, который параллельно стартует сервисы, настраивает сеть и запускает графический интерфейс (GUI).\n\nКаждый этап важен. Если что-то пойдёт не так в initramfs, система просто не загрузится. А если проблема в systemd, то сервисы не запустятся. Так что DevOps должен уметь:\n диагностировать зависание на этапе initramfs (например, добавить нужные драйверы в образ);\n**Совет от Рика:** не бойся сложных вещей — они просто ждут, когда ты их покоришь. И помни, что даже самые крутые системы могут дать сбой, если не следить за ними. Так что будь начеку и не забывай про резервные копии!",
      "questions": [
        {
          "text": "Какой компонент загружается до монтирования корневой ФС?",
          "options": [
            "GRUB",
            "systemd",
            "initramfs",
            "ядро"
          ],
          "correct": 2
        },
        {
          "text": "Что делает initramfs?",
          "options": [
            "Управляет сервисами",
            "Содержит драйверы для монтирования корневой ФС",
            "Это альтернатива ядру",
            "Хранит пользовательские данные"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Дисковый I/O, iowait и диагностика проблем с производительностью",
      "content": "**Рик говорит: дисковый I/O и iowait — разберёмся, внучок!**\n\nЭй, пацан, слушай сюда! Ты думаешь, когда приложение тормозит, сразу CPU виноват? Ха, наивный! Часто всё дело в дисковом I/O. Вот тебе расклад по iowait — штука, которая покажет, сколько времени твой CPU просто торчит без дела, ждёт, пока диск закончит свои дела.\n\nКороче, гляди: если iowait высокий — значит, процессы зависли в состоянии D (uninterruptible sleep) и ждут, когда диск наконец-то отработает. Почему так может быть? Да куча причин:\n* медленный HDD — ну, тут всё понятно, старичок еле ворочается;\n* перегруженный SSD — даже самый быстрый диск может затормозить, если на него навешать слишком много задач;\n* сетевое хранилище (NFS, iSCSI) лагает — бывает, что проблема не в самом диске, а в сети;\n* ошибки на диске — вдруг там что-то сломалось.\n\nКак это диагностировать? Давай разбираться:\n1. Используем `iostat -x 1` — тут смотри на несколько показателей:\n   * `%util` — показывает, насколько загружено твоё устройство;\n   * `await` — среднее время, которое операция ждёт своей очереди. Если на SSD `await` больше 20 мс — это уже звоночек, что что-то не так;\n   * `svctm` — время, которое уходит на обслуживание каждой операции.\n\n2. `iotop` — крутая утилита, которая покажет, какие процессы сейчас генерируют I/O. Сразу увидишь, кто жрёт ресурсы.\n\n3. `dmesg` — глянь туда, может, там есть сообщения об ошибках диска. Иногда там можно найти интересные детали.\n\nА если ты в облаке работаешь, то высокий iowait часто связан с ограничениями burst-баланса, например, на AWS gp2/gp3. Там свои приколы, чувак.\n\nТак что, DevOps, слушай сюда:\n* настраивай мониторинг iowait — не дай ему выйти из-под контроля;\n* под базы и логи используй быстрые диски — не экономь на том, что реально влияет на производительность;\n* проектируй архитектуру с учётом латентности хранилища — не забывай, что даже SSD имеет свой предел IOPS!\n\nЗапомни, пацан: не всё так просто, как кажется на первый взгляд. Иногда нужно копнуть глубже, чтобы найти настоящую причину проблем.\n\n#iowait #дисковыйI/O #CPU #DevOps #диагностика #производительность #SSD #HDD #облако\n\n**Совет:** не игнорируй показатели iowait — они могут многое рассказать о состоянии твоей системы. И помни: даже самые крутые технологии имеют свои ограничения, так что всегда учитывай особенности оборудования и архитектуры при настройке системы.",
      "questions": [
        {
          "text": "Что означает высокий iowait?",
          "options": [
            "CPU перегружен",
            "Процессы ожидают завершения операций ввода-вывода",
            "Сеть перегружена",
            "Закончилась память"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой посмотреть, какие процессы активно используют диск?",
          "options": [
            "top",
            "vmstat",
            "iostat",
            "iotop"
          ],
          "correct": 3
        }
      ]
    },
    {
      "title": "Специальные переменные Bash: $@, $!, $?, $$ и их применение в скриптах",
      "content": "**Рик говорит: спецпеременные в Bash — раз плюнуть!**\n\nЭй, пацанва, Рик тут! Сейчас расскажу, как крутиться с этими вашими спецпеременными в Bash. Ну, типа, вы же знаете, я во всём шарю, так что слушайте внимательно.\n\nИтак, в Bash есть куча специальных переменных, которые помогут вам управляться со скриптами. Давайте разберём самые полезные.\n\nПервая — `$@`. Это такая штука, которая хранит все аргументы командной строки, но каждое слово — отдельно. То есть если вы запустите скрипт с аргументами, то `$@` будет что-то типа `(\"$1\" \"$2\" ...)`. Поняли? Это важно, потому что есть ещё `$`, который всё сливает в одну строку. И вот тут начинается самое интересное: если в аргументах есть пробелы, `$` всё испортит, а `$@` справится на ура. Так что запомните: если хотите работать с аргументами аккуратно — используйте `$@`.\n\nДальше — `$!`. Это PID последнего фонового процесса. Ну, типа, запустили вы какую-то задачу в фоне, а потом хотите проверить, закончила она работу или нет. Вот тут `$!` и пригодится. Можно, например, использовать команду `wait $!`, чтобы подождать, пока процесс завершит работу. Удобно, правда?\n\nЕщё есть `$?` — это код возврата последней команды. Если команда выполнилась успешно, `$?` будет равен 0. А если что-то пошло не так — будет какое-то другое число. Это очень важно, чтобы проверять, всё ли окей. Например, можно написать что-то вроде `if [ $? -ne 0 ]; then ...`, чтобы выполнить какие-то действия, если команда провалилась.\n\nНе забудем про `$$` — это PID текущего shell-процесса. Полезная штука, когда нужно создать уникальный временный файл. Например, можно сделать что-то типа `/tmp/script.$$`. Гарантированно будет уникальный файл, ха-ха!\n\nЕсть ещё несколько прикольных переменных:\n `$#` — показывает, сколько аргументов вы передали скрипту;\n**Советы от Рика:**",
      "questions": [
        {
          "text": "Какая переменная содержит PID последнего фонового процесса?",
          "options": [
            "$$",
            "$@",
            "$!",
            "$?"
          ],
          "correct": 2
        },
        {
          "text": "Чем отличается $@ от $*?",
          "options": [
            "Ничем",
            "$@ объединяет аргументы в строку, $* — нет",
            "$@ сохраняет аргументы как отдельные слова, $* — объединяет",
            "$@ работает только в функциях"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Сигналы в Linux: SIGTERM, SIGKILL, обработка и перехват",
      "content": "**Рик говорит о сигналах в Unix: разжёвываю для тугодумов**\n\nЭй, пацанва, слушайте сюда! Сейчас дед Рик объяснит вам, что такое сигналы в Unix, и почему это не просто какая-то там ерунда. Короче, сигналы — это такой механизм, который позволяет процессам общаться друг с другом и сообщать, что случилось какое-то событие. Понял? Если нет, то слушай дальше, я разжую.\n\nПредставь, что у тебя есть несколько процессов, которые работают на компе, и им надо как-то друг друга уведомлять. Вот тут-то и приходят на помощь сигналы. Есть разные сигналы, и каждый из них означает что-то своё. Давай разберём самые популярные.\n\nПервый — `SIGTERM` (15). Это такой вежливый способ сказать процессу: «Чувачок, заканчивай свои дела, сохраняй данные и закрывай соединения, пора заканчивать работу». Процесс может обработать этот сигнал, всё аккуратно сохранить и спокойно закрыться. Понял, да?\n\nВторой — `SIGKILL` (9). Это уже не просьба, а прямой приказ: «Всё, ты труп, закрывайся немедленно!» Этот сигнал нельзя перехватить или проигнорировать. Получил `SIGKILL` — всё, туши свет, закрывайся и не отсвечивай.\n\nТретий — `SIGINT` (2). Этот сигнал отправляется, когда ты нажимаешь `Ctrl+C` в терминале. Обычно он работает так же, как `SIGTERM`, то есть просит процесс корректно завершиться.\n\nЕщё есть `SIGHUP` (1). Исторически это означало «hang up» (отбой), но сейчас часто используется для перезагрузки конфигурации. Например, если ты хочешь перезагрузить конфигурацию nginx или sshd, можешь использовать этот сигнал.\n\nПроцессы могут обрабатывать сигналы через специальные обработчики (signal handlers). Но есть сигналы, которые обработать нельзя, например, `SIGKILL` и `SIGSTOP`. Понял, почему? Потому что они предназначены для того, чтобы сразу остановить процесс, без всяких там «погоди, я сохраню данные».\n\nТеперь про диагностику. Если хочешь посмотреть список всех сигналов, можешь использовать команду `kill -l`. А если хочешь узнать, какие сигналы получает какой-то процесс, используй `strace -p PID`. Просто укажи PID процесса, и `strace` покажет тебе все сигналы, которые он получает.\n\nВ скриптах можно использовать команду `trap 'cleanup' TERM`, чтобы процесс корректно завершал работу. Это полезно, чтобы перед закрытием выполнить какие-то дополнительные действия, например, сохранить данные или закрыть соединения.\n\nА теперь про контейнеры. Тут всё серьёзно, пацаны. Если PID 1 в контейнере не обрабатывает `SIGTERM`, то Docker не сможет корректно завершить работу контейнера. Поэтому DevOps-ы должны тестировать graceful shutdown своих сервисов и настраивать таймауты в оркестраторах, например, в Kubernetes можно использовать параметр `terminationGracePeriodSeconds`.\n\nJava-приложения, кстати, часто требуют специальной обработки сигналов. Для этого можно использовать параметр `-XX:+UseContainerSupport`. Так что, если работаешь с Java в контейнерах, не забывай про это.\n\n**Хэштеги:** #Unix #Сигналы #DevOps #Контейнеры #Kubernetes #Java\n\n**Советы:**\n1. Всегда тестируй graceful shutdown своих сервисов.\n2. Изучи список сигналов и их назначение, это пригодится в работе.\n3. Настраивай таймауты в оркестраторах, чтобы избежать неожиданных сбоев.\n4. Обращай внимание на обработку сигналов в контейнерах, особенно для PID 1.\n5. Используй `strace` для диагностики проблем с сигналами.",
      "questions": [
        {
          "text": "Какой сигнал получает процесс при нажатии Ctrl+C?",
          "options": [
            "SIGKILL",
            "SIGTERM",
            "SIGINT",
            "SIGHUP"
          ],
          "correct": 2
        },
        {
          "text": "Какие сигналы нельзя проигнорировать или перехватить?",
          "options": [
            "SIGTERM и SIGINT",
            "SIGKILL и SIGSTOP",
            "SIGHUP и SIGUSR1",
            "Все сигналы можно обработать"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Права доступа, sudo и управление файловыми дескрипторами",
      "content": "**Рик говорит о Linux: права доступа, sudo и файловые дескрипторы**\n\nПривет, пацаны! Рик тут, и сегодня я расскажу вам про некоторые фишки в Linux. Ну, знаете, я ж гений, так что слушайте внимательно, а то потом не разберётесь.\n\nИтак, начнём с прав доступа в Linux. Там всё строится на триаде: владелец, группа и остальные. И у каждого из них могут быть свои права: чтение (r), запись (w) и выполнение (x). Например, команда `chmod 755` — это как раз про права. Она означает, что для владельца будут права rwx (то есть можно читать, писать и выполнять), а для группы и остальных — только rx (читать и выполнять).\n\nА что такое право x для каталогов, спросите вы? Да просто разрешение на вход в каталог! Всё просто, как дважды два.\n\nТеперь про sudo. Это такая штука, которая позволяет запускать команды от имени другого пользователя, чаще всего от имени root. Конфигурация sudo хранится в файле `/etc/sudoers`, и редактировать его надо только через `visudo`. Почему? Да потому что `visudo` помогает избежать синтаксических ошибок — ну, знаете, чтобы не напортачить.\n\nПравила в `/etc/sudoers` выглядят так: `user host = (runas) command`. Например, можно написать что-то вроде `arstan ALL = (root) /usr/bin/systemctl restart nginx`. Это значит, что пользователь arstan может перезапускать nginx от имени root на всех хостах.\n\nДля DevOps-шников очень важно ограничивать права. Не надо давать полный root, достаточно предоставить доступ только к тем командам, которые реально нужны. Это как давать ребёнку молоток — можно позволить стучать по деревяшке, но не давать разбирать весь дом.\n\nТеперь про файловые дескрипторы (FD). Это такие целые числа, через которые процесс обращается к открытым файлам, сокетам и pipes. Если файловые дескрипторы утекают, то можно наткнуться на ошибку «too many open files». Чтобы диагностировать проблему, можно использовать несколько команд:\n `lsof -p PID` — покажет список файловых дескрипторов процесса;\n**Хэштеги:** #Linux #DevOps #правадоступа #sudo #файловыедескрипторы\n\n**Советы:**\n1. Всегда проверяйте права доступа перед тем, как что-то менять.\n2. Используйте `visudo` для редактирования `/etc/sudoers`, чтобы не накосячить с синтаксисом.\n3. Следите за файловыми дескрипторами — утечка может привести к неприятным последствиям.\n4. Настраивайте лимиты под реальную нагрузку, а не ставьте их «на глаз».",
      "questions": [
        {
          "text": "Приложение пишет в логи 'too many opened files'. Как диагностировать?",
          "options": [
            "Проверить df -h",
            "Использовать lsof -p PID",
            "Перезагрузить сервер",
            "Установить больше RAM"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой правильно редактировать /etc/sudoers?",
          "options": [
            "nano /etc/sudoers",
            "vim /etc/sudoers",
            "visudo",
            "sudoedit"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Docker и ядро Linux: namespaces, cgroups и copy-on-write",
      "content": "**Рик говорит: «Docker? Пф, раз плюнуть!»**\n\nСлушай сюда, малой, я тебе объясню, что такое Docker. Не надо тут думать, что это какая-то там магия — просто обёртка над старыми технологиями Linux. Представь, что у тебя есть куча инструментов в ящике, и Docker просто делает так, чтобы ими было удобнее пользоваться.\n\nИтак, основа всего этого дела — namespaces. Это такая штука, которая позволяет каждому контейнеру думать, что он единственный на компьютере. Типа как если бы ты жил в своей собственной вселенной, где нет никого, кроме тебя. Есть разные виды namespaces: для процессов (PID), для сети (NET), для монтирования (MNT), для пользователей (USER) и так далее. Каждый контейнер видит свой изолированный мир — никаких тебе конфликтов и проблем.\n\nДальше идут cgroups (control groups). Это уже про ресурсы — CPU, память, I/O. Представь, что у тебя есть ограниченный бюджет, и ты должен распределить деньги между разными проектами. Вот cgroups и делают примерно то же самое — ограничивают и измеряют ресурсы, чтобы какой-нибудь контейнер не сожрал всю память хоста. Без cgroups твой компьютер быстро превратится в хаос.\n\nА ещё есть Union File Systems — например, overlay2 или aufs. Они позволяют создавать слои образов. Вот представь: у тебя есть базовый слой — операционная система, а сверху ты добавляешь слой с приложением. Когда ты запускаешь контейнер, создаётся записываемый слой поверх read-only слоёв. Это называется copy-on-write: все изменения записываются только в новый слой. Понимаешь? Образы — это не полноценные ОС, а просто архивы с файлами.\n\nКогда ты пишешь `docker run`, ядро Linux делает следующее:\n* создаёт новые namespaces;\n* ограничивает ресурсы через cgroups;\n* монтирует слои через overlayfs;\n* запускает процесс (часто без PID 1, как systemd!).\n\nDevOps-шники должны понимать, что контейнер — это просто процесс в изоляции, а не виртуальная машина. Безопасность в Docker достигается через правильные настройки namespaces, cgroups, seccomp, AppArmor. Если ты не понимаешь, как это всё работает, то можешь столкнуться с проблемами — например, сетевые правила не будут работать так, как ты ожидаешь.\n\nТак что, если хочешь быть крутым DevOps-щиком, изучай эти технологии. Понимание того, как работают namespaces, cgroups и Union File Systems, критически важно для отладки и проектирования систем.\n\n**Хэштеги:** #Docker #контейнеризация #Linux #DevOps #namespaces #cgroups #UnionFileSystems\n\n**Советы:**\n1. Изучай основы Linux — без понимания того, как работает система, сложно разобраться в Docker.\n2. Практикуйся в настройке namespaces и cgroups — это поможет тебе лучше понять, как работают контейнеры.\n3. Читай документацию и статьи о Docker — там много полезной информации.\n4. Экспериментируй с контейнерами — создавай свои образы, запускай контейнеры и смотри, как они работают.",
      "questions": [
        {
          "text": "Какие ядерные технологии лежат в основе Docker?",
          "options": [
            "Виртуализация CPU",
            "namespaces и cgroups",
            "Гипервизор KVM",
            "LXC только"
          ],
          "correct": 1
        },
        {
          "text": "Что происходит при записи в файл внутри контейнера?",
          "options": [
            "Файл перезаписывается в образе",
            "Создаётся копия в записываемом слое (copy-on-write)",
            "Запись идёт напрямую на хост",
            "Операция запрещена"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "systemd: революция в управлении сервисами и её критика",
      "content": "**Рик говорит о systemd: зачем он нужен и почему все его используют****journald****socket activation** — сервис запускается, когда к нему подключаются через сокет. Удобно, правда?\n автоматический рестарт сервисов — если что-то пошло не так, systemd сам перезапустит сервис.\n контроль через cgroups — это помогает управлять ресурсами, которые используют сервисы.\n таймеры — альтернатива cron, чтобы запускать задачи по расписанию.\n\nПлюсы systemd:\n скорость — всё запускается быстрее;\n надёжность — система работает стабильнее;\n унификация — всё становится более стандартизированным.\n\nНо есть и минусы:\n монолитность — некоторые говорят, что systemd нарушает UNIX-философию «делай одну вещь хорошо», потому что он слишком многофункциональный;\n сложность отладки — иногда бывает непросто разобраться, что пошло не так;\n зависимость от D-Bus — это ещё одна система, от которой зависит systemd.\n\nНо факт остаётся фактом: в современном Linux без systemd — как без рук. Для DevOps-шников systemd — это стандарт. Они используют такие команды:\n `systemctl start/enable/status` — чтобы запускать, включать и проверять статус сервисов;\n `journalctl -u service` — чтобы смотреть логи конкретного сервиса;\n `systemd-analyze blame` — чтобы диагностировать проблемы с загрузкой системы.\n\nА ещё умение писать юнит-файлы — это must-have навык. Без него в современном мире DevOps никуда!\n\nНесмотря на всю критику, systemd решил кучу реальных проблем:\n race condition при старте — когда несколько сервисов пытаются получить доступ к ресурсам одновременно;\n**Совет:** если хотите разобраться в systemd, начните с изучения основных команд `systemctl` и `journalctl`. Потом переходите к написанию юнит-файлов — это немного сложнее, но очень полезно. И не бойтесь экспериментировать!",
      "questions": [
        {
          "text": "Какая команда показывает логи конкретного сервиса в systemd?",
          "options": [
            "cat /var/log/syslog",
            "journalctl -u nginx",
            "systemctl logs nginx",
            "tail /var/log/nginx"
          ],
          "correct": 1
        },
        {
          "text": "Почему systemd критиковали в сообществе Linux?",
          "options": [
            "Он слишком медленный",
            "Он нарушает UNIX-философию 'делай одну вещь хорошо'",
            "Он не поддерживает сетевые сервисы",
            "Он написан на Perl"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Диагностика проблем с диском: iowait, иноды и 'no space left'",
      "content": "**Рик говорит: проблемы с дисковым пространством — разберёмся!**\n\nЭй, пацаны, слышали про такую дичь? Сидишь ты, значит, работаешь, и вдруг бац — «no space left on device», хотя по всем признакам место должно быть. Ну, типа, `df` показывает, что занято всего ничего, а `du` вообще говорит, что там пара мегабайт. Что за хрень, да? Сейчас я вам, тупоголовым, объясню, в чём тут дело.\n\nИтак, есть несколько причин, почему может возникать эта проблема:\n\n1. **Закончились inodes.** Чё за inodes, спросите вы? Да это такие штуки, которые файловая система использует для хранения информации о файлах и папках. Когда ты создаёшь файловую систему (например, ext4), ты задаёшь определённое количество inodes. И вот если у тебя куча мелких файлов, эти inodes могут закончиться раньше, чем закончится место на диске. Проверяешь это дело командой `df -i`. Понял, да?\n\n2. **Зарезервированное место для root.** Слушай сюда, братан: по умолчанию система резервирует примерно 5 % диска для root. Это значит, что обычные пользователи не могут использовать это место. Но не беда, можно настроить с помощью `tune2fs -m`. Так что если у тебя вдруг заканчивается место, проверь, сколько там зарезервировано.\n\n3. **Открытый, но удалённый файл.** Вот это вообще жесть. Представь: ты удалил файл, а место не освободилось. Почему? Да потому что какой-то процесс всё ещё держит дескриптор этого файла. Пока процесс не завершится, место не освободится. Как найти такие файлы? Используй команду `lsof +L1`. Она покажет тебе все открытые файлы, которые уже были удалены.\n\n4. **Квоты.** Да, бывают такие приколы, когда у пользователей или групп есть ограничения на использование дискового пространства. Проверяешь квоты с помощью `quota -u user`. Просто и эффективно.\n\n**Как диагностировать проблему?**\n\n- Используй `df -i`, чтобы проверить количество свободных inodes.\n- Запусти `lsof +L1`, чтобы увидеть открытые, но удалённые файлы.\n- Проверь зарезервированное место с помощью `tune2fs -l /dev/sda1 | grep 'Reserved'`.\n- Посмотри квоты с помощью `quota -u user`.\n\nЕсли ты работаешь с облаком (например, AWS), не забывай проверять burst balance.\n\n**Советы от Рика:**\n\n- DevOps, слушай сюда: монитори не только свободное место, но и inodes, особенно на серверах с почтой или кэшем. Там обычно куча мелких файлов, и inodes могут закончиться быстрее, чем ты думаешь.\n- Настрой автоматические алерты на уровень занятости inodes выше 80 %. Это must-have, пацаны!\n\n#РикЗнаетВсё #ДисковоеПространство #Inodes #DevOps #СерверныеПроблемы #МониторингСистемы",
      "questions": [
        {
          "text": "Почему df и du могут показывать разный объём занятого места?",
          "options": [
            "du не считает скрытые файлы",
            "Процесс держит удалённый файл",
            "df считает только ext4",
            "du работает медленнее"
          ],
          "correct": 1
        },
        {
          "text": "Как проверить, не закончились ли inodes?",
          "options": [
            "df -h",
            "du -sh",
            "df -i",
            "ls -i"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Память в Linux: физическая, виртуальная, OOM Killer и available",
      "content": "**Рик говорит о памяти в Linux: разберёмся, пока не взорвалась вселенная!****Хэштеги:** #Linux #Память #OOMKiller #cgroups #DevOps\n\n**Советы от Рика:**\n1. Всегда следите за `available` памятью, а не за `used`.\n2. Настройте мониторинг и алерты, чтобы не допустить нехватки памяти.\n3. Используйте cgroups для ограничения памяти в контейнерах — это спасёт вас от неожиданных «взрывов».\n4. Не игнорируйте инструменты вроде `top`, `htop` и `smem` — они помогут вам вовремя заметить проблемы с памятью.",
      "questions": [
        {
          "text": "Почему available памяти больше free?",
          "options": [
            "Потому что free не считает swap",
            "Потому что available включает кэши, которые можно освободить",
            "Это ошибка в ядре",
            "Available считает только RAM, free — RAM+swap"
          ],
          "correct": 1
        },
        {
          "text": "Что делает OOM Killer?",
          "options": [
            "Перезагружает сервер",
            "Убивает процесс при нехватке памяти",
            "Включает swap",
            "Блокирует новые процессы"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Сетевые и системные утилиты: netstat, ss, iptables, lsof",
      "content": "**Рик говорит: диагностика сети в Linux — раз плюнуть!**\n\nЭй, пацанва, слушайте сюда! Я, Рик, сейчас объясню вам, как диагностировать сеть в Linux. Не думайте, что это сложно — я вам сейчас всё разжую, даже самый туповатый поймёт.\n\nИтак, начнём с утилит. В Linux есть несколько крутых инструментов для диагностики сети. Например, `netstat` и `ss`. Только `netstat` уже устаревает, так что лучше пользоваться `ss` — он из пакета `iproute2` и работает быстрее. С помощью этих утилит можно посмотреть сетевые соединения, сокеты и маршруты.\n\nНапример, если вам нужно узнать, какие TCP или UDP порты сейчас «слушают» (то есть ожидают входящих соединений), можно использовать команду `ss -tuln`. Просто запустите её в терминале, и вы увидите список всех портов, которые сейчас активны.\n\nЕщё есть утилита `lsof -i`, которая показывает, какие процессы используют сеть. Это полезно, если вы хотите понять, какой процесс «захватил» определённый порт.\n\nА теперь поговорим о файрволе. В Linux для фильтрации пакетов на уровне ядра используется `iptables`. С его помощью можно задавать правила, которые будут определять, какие пакеты пропускать, а какие — нет. Например, можно разрешить подключения по SSH с помощью правила `-A INPUT -p tcp --dport 22 -j ACCEPT`. А если вы хотите, чтобы по умолчанию все входящие пакеты блокировались, можно установить политику `DROP` с помощью команды `-P INPUT DROP`.\n\nНо учтите, что в современных системах `iptables` часто заменяют на `nftables` — это более современная и гибкая система управления правилами файрвола.\n\nЕсли вам нужно захватить и проанализировать трафик, используйте `tcpdump` или `Wireshark`. Эти инструменты помогут вам «подсмотреть», что происходит в сети, и выявить возможные проблемы.\n\nДля DevOps-шников особенно важно уметь:\n определять, какой процесс «слушает» определённый порт (для этого можно использовать `ss -tulnp`);\n**Хэштеги:** #Linux #ДиагностикаСети #DevOps #РикЗнаетВсё\n\n**Советы от Рика:**\n1. Всегда используйте самые современные инструменты — так вы сэкономите время и силы.\n2. Регулярно проверяйте правила файрвола и состояние сетевых соединений — это поможет избежать многих проблем.\n3. Изучайте документацию и примеры использования утилит — так вы быстрее станете профи.\n4. Не бойтесь экспериментировать — иногда самые неожиданные решения оказываются самыми эффективными!",
      "questions": [
        {
          "text": "Какой командой посмотреть, какие порты слушает система?",
          "options": [
            "ps aux",
            "netstat -tuln",
            "df -h",
            "free -h"
          ],
          "correct": 1
        },
        {
          "text": "Какая утилита является современной заменой netstat?",
          "options": [
            "ifconfig",
            "ip",
            "ss",
            "route"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Безопасность и мониторинг: chroot, SSH, syslog и инструменты",
      "content": "**Рик говорит: безопасность Linux — это вам не шутки, пацаны!****Совет от Рика:** всегда будь на шаг впереди потенциальных угроз и не доверяй никому — даже самому себе! И помни: если что-то кажется слишком сложным, значит, ты просто не до конца понял, как это работает. Разбирайся, экспериментируй и не бойся ломать — главное, чтобы потом уметь чинить!",
      "questions": [
        {
          "text": "Что такое chroot jail?",
          "options": [
            "Полная виртуализация",
            "Смена корневой директории для изоляции процесса",
            "Шифрование диска",
            "Файрвол на уровне ядра"
          ],
          "correct": 1
        },
        {
          "text": "Где обычно хранятся системные логи в Linux?",
          "options": [
            "/etc/log",
            "/var/log",
            "/tmp/log",
            "/home/logs"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "POSIX, PXE, LVM и разграничение userspace/kernelspace",
      "content": "**Рик говорит: «О, внучок, давай я тебе объясню, что тут за хрень с этими POSIX, PXE, LVM и всем остальным!»**\n\nСлушай сюда, пацан! POSIX — это такой стандарт, который позволяет программам работать на разных Unix-системах. Ну типа, если ты написал прогу по POSIX, то она будет бегать и на Linux, и на BSD, и даже на macOS. Понял? Это как универсальный ключ, который подходит к разным замкам. Удобно, да?\n\nА теперь про PXE. Это такая штука, которая позволяет загружать операционную систему по сети. Представь: твой комп включается, BIOS или UEFI получает IP-адрес через DHCP, потом скачивает загрузчик через TFTP, а потом уже ядро и initramfs по HTTP или NFS. Круто, правда? Это используется, чтобы быстро развернуть кучу компов, например, с помощью MAAS или Foreman. Удобно для больших компаний, где надо много машин настроить.\n\nТеперь про LVM — Logical Volume Manager. Это такая система, которая позволяет тебе управлять дисками, как будто они — конструктор. Ты берёшь физические диски или разделы (Physical Volumes), объединяешь их в пул (Volume Group), а потом создаёшь логические тома (Logical Volumes). И вот тут самое интересное: ты можешь менять размер этих томов на лету, без остановки сервиса! Представляешь? Добавляешь диски в пул, увеличиваешь объём — и всё это без простоев. Очень удобно для серверов и всяких там дата-центров.\n\nА ещё есть такое разделение: userspace и kernelspace. Это как два разных мира в компьютере. Kernelspace — это привилегированный режим, где живёт ядро системы. Оно управляет железом, памятью, процессами — всем, что нужно для работы компа. А userspace — это где живут обычные приложения. Они изолированы и имеют ограниченный доступ к ресурсам. Они общаются с ядром через системные вызовы (syscalls) — типа open(), read(), fork(). Это нужно, чтобы если какое-то приложение зависнет или упадёт, оно не потянуло за собой всё ядро. Понял? Это как если бы ты играл в игру, и она зависла — ты просто закрываешь её, а комп продолжает работать.\n\nТак что, если ты DevOps, тебе надо знать всё это:\n* LVM — чтобы ловко управлять дисками;\n* PXE — чтобы автоматизировать развёртывание систем;\n* POSIX — чтобы писать скрипты, которые будут работать везде;\n* про userspace и kernelspace — чтобы понимать, почему некоторые вещи медленные и как отлаживать производительность.\n\n**Хэштеги:** #POSIX #PXE #LVM #Userspace #Kernelspace #DevOps #IT #Программирование\n\n**Советы от Рика:**\n1. Запоминай стандарты — они твой хлеб в IT.\n2. Изучай, как работает система — это сэкономит тебе кучу времени в будущем.\n3. Не бойся сложных вещей — просто разбей их на простые кусочки, и всё станет понятно.\n4. Практикуйся — теория без практики ни о чём не говорит.",
      "questions": [
        {
          "text": "Что такое POSIX?",
          "options": [
            "Тип файловой системы",
            "Стандарт совместимости Unix-систем",
            "Протокол сетевой загрузки",
            "Менеджер логических томов"
          ],
          "correct": 1
        },
        {
          "text": "Какие три абстракции использует LVM?",
          "options": [
            "Disk, Partition, File",
            "Block, Sector, Cylinder",
            "Physical Volume, Volume Group, Logical Volume",
            "RAID0, RAID1, RAID5"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Итоговый тест: полная проверка знаний Linux",
      "content": "**Рик говорит: «Эй, пацан, слушай сюда!»**\n\nСлушай, малой, я тут глянул на твой тест и скажу тебе так: это тебе не шутки. Тут целых 73 вопроса! И они охватывают всё: от загрузки до архитектуры ядра. Да уж, материал — жесть, но я-то знаю, как с этим разобраться.\n\nПредставь себе: загрузка — это как запуск космического корабля. Процессы — это команды на борту, которые должны работать слаженно, чтобы корабль летел куда надо. Память — это как бортовой компьютер, который хранит все данные и не даёт забыть, куда мы летим и что надо сделать. Диск — это склад, где хранятся все нужные штучки. Файловые системы — это система организации этого склада, чтобы быстро найти то, что нужно. Bash — это как пульт управления кораблём, с помощью которого ты даёшь команды. Сигналы — это сообщения между разными системами корабля, которые помогают ему работать как надо. Безопасность — это защита корабля от пиратов и космических угроз. Сеть — это связь с другими кораблями и базами, а архитектура ядра — это основа, на которой всё держится.\n\nИ вот ты получаешь случайный вопрос из всего этого пула. Это как если бы тебе каждый раз давали новое задание на борту корабля — никогда не знаешь, что будет дальше. Но если ты разберёшься со всеми этими темами, то сможешь управлять любым кораблём во Вселенной!\n\n**Советы от Рика:**\n* не пытайся выучить всё за один раз — разбей материал на части и изучай постепенно;\n* практикуйся в использовании bash и других инструментов — теория без практики ни к чему не приведёт;\n* представляй себе аналогии из реальной жизни (или из космоса, как я тебе сейчас рассказал) — так будет проще запомнить информацию;\n* не бойся задавать вопросы — даже у меня были учителя, когда-то.\n\n#тесты #обучение #IT #программирование #РикИМорти #космос #технологии\n\nТак, пацан, теперь давай, шевелись, а то у меня ещё куча дел во Вселенной!",
      "questions": [
        {
          "text": "Как посмотреть нагрузку на диски?",
          "options": [
            "iostat -x 1, iotop, vmstat 1",
            "df -h",
            "free -h",
            "ps aux"
          ],
          "correct": 0
        },
        {
          "text": "Что означают поля bi и bo в vmstat?",
          "options": [
            "bi — блоки, полученные с диска (чтение); bo — блоки, отправленные на диск (запись)",
            "bi — байты входящие, bo — байты исходящие",
            "bi — буферы inodes, bo — блоки объектов",
            "bi — background I/O, bo — blocked operations"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $@ в bash?",
          "options": [
            "Все аргументы командной строки как отдельные слова",
            "Статус последней команды",
            "PID текущего процесса",
            "PID последнего фонового процесса"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $! в bash?",
          "options": [
            "PID последнего фонового процесса",
            "Все аргументы",
            "Статус последней команды",
            "PID текущего shell"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $? в bash?",
          "options": [
            "Статус завершения последней команды (0 — успех)",
            "PID фонового процесса",
            "Все аргументы",
            "Текущий каталог"
          ],
          "correct": 0
        },
        {
          "text": "Что такое $$ в bash?",
          "options": [
            "PID текущего shell-процесса",
            "Статус команды",
            "Аргументы скрипта",
            "Имя скрипта"
          ],
          "correct": 0
        },
        {
          "text": "Что такое load average?",
          "options": [
            "Среднее количество процессов в состоянии R или D за 1/5/15 минут",
            "Процент загрузки CPU",
            "Количество активных пользователей",
            "Скорость диска в IOPS"
          ],
          "correct": 0
        },
        {
          "text": "Где посмотреть load average?",
          "options": [
            "uptime, top, cat /proc/loadavg, w",
            "df -h",
            "free -h",
            "ls /proc"
          ],
          "correct": 0
        },
        {
          "text": "Что такое swap?",
          "options": [
            "Область на диске для расширения RAM при её нехватке",
            "Тип файловой системы",
            "Механизм сетевой балансировки",
            "Кэш процессора"
          ],
          "correct": 0
        },
        {
          "text": "Для чего нужен swap?",
          "options": [
            "Резерв памяти, гибернация, оптимизация RAM",
            "Ускорение загрузки системы",
            "Шифрование данных",
            "Создание резервных копий"
          ],
          "correct": 0
        },
        {
          "text": "Где хранится информация о процессах в Linux?",
          "options": [
            "/proc",
            "/etc",
            "/var/log",
            "/sys"
          ],
          "correct": 0
        },
        {
          "text": "Что такое процесс в Linux?",
          "options": [
            "Экземпляр выполняющейся программы с собственным адресным пространством",
            "Файл на диске",
            "Пользователь системы",
            "Сетевое соединение"
          ],
          "correct": 0
        },
        {
          "text": "Какие статусы процессов бывают?",
          "options": [
            "R, S, D, T, Z",
            "A, B, C, D",
            "1, 2, 3, 4",
            "RUN, STOP, KILL"
          ],
          "correct": 0
        },
        {
          "text": "Что означает статус D у процесса?",
          "options": [
            "Uninterruptible sleep (ожидание I/O)",
            "Зомби",
            "Остановлен",
            "Выполняется"
          ],
          "correct": 0
        },
        {
          "text": "Что такое зомби-процесс?",
          "options": [
            "Завершённый процесс, чей родитель не вызвал wait()",
            "Процесс без родителя",
            "Процесс с высоким потреблением CPU",
            "Процесс в состоянии sleeping"
          ],
          "correct": 0
        },
        {
          "text": "Что такое процесс-сирота?",
          "options": [
            "Процесс, чей родитель завершился — усыновляется PID 1",
            "Завершённый процесс",
            "Процесс в состоянии D",
            "Процесс без прав"
          ],
          "correct": 0
        },
        {
          "text": "Как создать файловую систему на блочном устройстве?",
          "options": [
            "mkfs.ext4 /dev/sdX1",
            "mount /dev/sdX1",
            "fdisk /dev/sdX",
            "lsblk"
          ],
          "correct": 0
        },
        {
          "text": "В чём разница между hardlink и symlink?",
          "options": [
            "Hardlink указывает на inode, symlink — на путь",
            "Hardlink работает между ФС, symlink — нет",
            "Symlink не может быть удалён",
            "Hardlink — это ярлык"
          ],
          "correct": 0
        },
        {
          "text": "Как создать жёсткую ссылку?",
          "options": [
            "ln file link",
            "ln -s file link",
            "link file link",
            "cp -l file link"
          ],
          "correct": 0
        },
        {
          "text": "Как создать символьную ссылку?",
          "options": [
            "ln -s file link",
            "ln file link",
            "mklink file link",
            "symlink file link"
          ],
          "correct": 0
        },
        {
          "text": "Опишите процесс загрузки Linux.",
          "options": [
            "BIOS/UEFI → GRUB → ядро + initramfs → init (PID 1) → сервисы",
            "Ядро → GRUB → BIOS",
            "GRUB → systemd → ядро",
            "init → ядро → загрузчик"
          ],
          "correct": 0
        },
        {
          "text": "Что такое BIOS?",
          "options": [
            "16-битная прошивка с поддержкой MBR",
            "Современная 64-битная прошивка",
            "Тип файловой системы",
            "Менеджер пакетов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое UEFI?",
          "options": [
            "32/64-битная прошивка с GPT и Secure Boot",
            "Устаревшая 16-битная прошивка",
            "Сетевой протокол",
            "Тип диска"
          ],
          "correct": 0
        },
        {
          "text": "Что такое systemd?",
          "options": [
            "Современная init-система с параллельным запуском сервисов",
            "Тип файловой системы",
            "Менеджер пакетов",
            "Загрузчик"
          ],
          "correct": 0
        },
        {
          "text": "Чем systemd лучше init?",
          "options": [
            "Параллельный запуск, зависимости, логирование через journald",
            "Меньше функций",
            "Работает только в облаке",
            "Не поддерживает сервисы"
          ],
          "correct": 0
        },
        {
          "text": "Как проверить, используется ли systemd?",
          "options": [
            "ps -p 1 -o comm=",
            "ls /etc",
            "df -h",
            "free -h"
          ],
          "correct": 0
        },
        {
          "text": "Что такое sudo?",
          "options": [
            "Команда для выполнения действий с правами другого пользователя",
            "Менеджер пакетов",
            "Тип файловой системы",
            "Сетевой инструмент"
          ],
          "correct": 0
        },
        {
          "text": "Что такое Docker?",
          "options": [
            "Платформа контейнеризации на основе namespaces и cgroups",
            "Гипервизор",
            "Менеджер пакетов",
            "Тип виртуальной машины"
          ],
          "correct": 0
        },
        {
          "text": "Какие ядерные технологии лежат в основе Docker?",
          "options": [
            "namespaces, cgroups, UnionFS",
            "KVM, QEMU",
            "BIOS, UEFI",
            "ext4, XFS"
          ],
          "correct": 0
        },
        {
          "text": "Что такое физическая память?",
          "options": [
            "RAM — быстрая энергозависимая память для активных данных",
            "Swap на диске",
            "Файловая система",
            "Кэш процессора"
          ],
          "correct": 0
        },
        {
          "text": "Что такое виртуальная память?",
          "options": [
            "Механизм расширения RAM за счёт swap и изоляции процессов",
            "Тип диска",
            "Сетевой протокол",
            "Файловая система"
          ],
          "correct": 0
        },
        {
          "text": "Что такое файловая система?",
          "options": [
            "Способ организации данных на диске: имена, права, структура",
            "Тип процессора",
            "Сетевой протокол",
            "Менеджер пакетов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое inode?",
          "options": [
            "Структура с метаданными файла: права, владелец, указатели на данные",
            "Имя файла",
            "Содержимое файла",
            "Тип диска"
          ],
          "correct": 0
        },
        {
          "text": "Где хранятся имена файлов?",
          "options": [
            "В директории",
            "В inode",
            "В суперблоке",
            "В ядре"
          ],
          "correct": 0
        },
        {
          "text": "Почему может быть 'no space left on device', если место есть?",
          "options": [
            "Закончились inodes",
            "Сломан диск",
            "Нет прав",
            "Ошибка в df"
          ],
          "correct": 0
        },
        {
          "text": "Как проверить, не закончились ли inodes?",
          "options": [
            "df -i",
            "df -h",
            "du -sh",
            "ls -l"
          ],
          "correct": 0
        },
        {
          "text": "Что такое POSIX?",
          "options": [
            "Стандарт совместимости Unix-систем",
            "Тип файловой системы",
            "Сетевой протокол",
            "Менеджер томов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое PXE?",
          "options": [
            "Загрузка ОС по сети через DHCP + TFTP",
            "Шифрование диска",
            "Тип файловой системы",
            "Менеджер пакетов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое LVM?",
          "options": [
            "Logical Volume Manager: PV → VG → LV",
            "Тип загрузчика",
            "Сетевой протокол",
            "Менеджер процессов"
          ],
          "correct": 0
        },
        {
          "text": "Что такое userspace и kernelspace?",
          "options": [
            "Kernelspace — привилегированный режим ядра, userspace — обычные приложения",
            "Это типы дисков",
            "Сетевые зоны",
            "Режимы работы CPU"
          ],
          "correct": 0
        },
        {
          "text": "Что такое системные вызовы?",
          "options": [
            "Механизм обращения из userspace в kernelspace",
            "Команды в терминале",
            "Сигналы между процессами",
            "Типы файлов"
          ],
          "correct": 0
        },
        {
          "text": "Какой сигнал отправляется при Ctrl+C?",
          "options": [
            "SIGINT",
            "SIGKILL",
            "SIGTERM",
            "SIGHUP"
          ],
          "correct": 0
        },
        {
          "text": "Чем отличается SIGTERM от SIGKILL?",
          "options": [
            "SIGTERM можно перехватить, SIGKILL — нет",
            "SIGKILL мягче",
            "SIGTERM используется только для root",
            "SIGKILL отправляется первым"
          ],
          "correct": 0
        },
        {
          "text": "Какие сигналы нельзя проигнорировать?",
          "options": [
            "SIGKILL и SIGSTOP",
            "SIGTERM и SIGINT",
            "SIGHUP и SIGUSR1",
            "Все можно"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть, какие файлы открыл процесс?",
          "options": [
            "ls -l /proc/PID/fd/",
            "ps aux",
            "df -h",
            "free -h"
          ],
          "correct": 0
        },
        {
          "text": "Как узнать, где программа ищет конфиг?",
          "options": [
            "strace -e open program",
            "cat /etc/program.conf",
            "ps aux",
            "netstat"
          ],
          "correct": 0
        },
        {
          "text": "Что делать, если chmod лишён прав на исполнение?",
          "options": [
            "Запустить через /lib64/ld-linux-x86-64.so.2 /bin/chmod +x /bin/chmod",
            "Перезагрузить",
            "Установить заново",
            "Использовать альтернативу"
          ],
          "correct": 0
        },
        {
          "text": "Почему available > free в free -h?",
          "options": [
            "Available учитывает, что кэш можно сбросить",
            "Это ошибка",
            "Available включает swap",
            "Free не считает RAM"
          ],
          "correct": 0
        },
        {
          "text": "Как работает OOM Killer?",
          "options": [
            "Убивает процесс с наибольшим oom_score при нехватке памяти",
            "Перезагружает систему",
            "Блокирует новые процессы",
            "Переносит всё в swap"
          ],
          "correct": 0
        },
        {
          "text": "Что такое iowait?",
          "options": [
            "Процент времени, которое CPU ждал завершения I/O",
            "Загрузка сети",
            "Использование swap",
            "Потребление RAM"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть, какие процессы используют диск?",
          "options": [
            "iotop",
            "top",
            "ps aux",
            "df -h"
          ],
          "correct": 0
        },
        {
          "text": "Как проверить, слушает ли сервис порт?",
          "options": [
            "ss -tuln",
            "ps aux",
            "df -h",
            "free -h"
          ],
          "correct": 0
        },
        {
          "text": "Что такое iptables?",
          "options": [
            "Фильтрация пакетов на уровне ядра",
            "Менеджер пакетов",
            "Тип файловой системы",
            "Сетевой монитор"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть историю команд?",
          "options": [
            "history",
            "cat ~/.bash_history",
            "journalctl",
            "ls /var/log"
          ],
          "correct": 0
        },
        {
          "text": "Где хранятся системные логи?",
          "options": [
            "/var/log/",
            "/etc/log/",
            "/tmp",
            "/home"
          ],
          "correct": 0
        },
        {
          "text": "Как отследить системные вызовы?",
          "options": [
            "strace -p PID",
            "lsof",
            "netstat",
            "ps"
          ],
          "correct": 0
        },
        {
          "text": "Как управлять сервисами в systemd?",
          "options": [
            "systemctl start/stop/enable",
            "service start",
            "init.d",
            "run"
          ],
          "correct": 0
        },
        {
          "text": "Как установить пакет из исходного кода?",
          "options": [
            "./configure → make → make install",
            "apt install",
            "yum install",
            "pip install"
          ],
          "correct": 0
        },
        {
          "text": "Что такое initramfs?",
          "options": [
            "Временная ФС в RAM с драйверами для монтирования корня",
            "Загрузчик",
            "Тип ядра",
            "Лог-файл"
          ],
          "correct": 0
        },
        {
          "text": "Как работает fork()?",
          "options": [
            "Создаёт копию процесса (copy-on-write)",
            "Запускает новый терминал",
            "Перезагружает систему",
            "Убивает процесс"
          ],
          "correct": 0
        },
        {
          "text": "Как работать с файлами >2GB на 32-битной системе?",
          "options": [
            "Требуется поддержка large file support (LFS)",
            "Невозможно",
            "Только через swap",
            "Автоматически работает"
          ],
          "correct": 0
        },
        {
          "text": "Что такое softirq?",
          "options": [
            "Нижняя половина обработки прерываний в ядре",
            "Тип сигнала",
            "Сетевой пакет",
            "Ошибка диска"
          ],
          "correct": 0
        },
        {
          "text": "Как посмотреть дерево процессов?",
          "options": [
            "pstree",
            "ps aux",
            "top",
            "htop"
          ],
          "correct": 0
        },
        {
          "text": "Как найти процесс по имени?",
          "options": [
            "pgrep имя",
            "ps aux | grep имя",
            "top",
            "htop"
          ],
          "correct": 0
        },
        {
          "text": "Как убить процесс по имени?",
          "options": [
            "pkill имя",
            "kill PID",
            "stop имя",
            "exit имя"
          ],
          "correct": 0
        },
        {
          "text": "Как проверить целостность ФС?",
          "options": [
            "fsck /dev/sdX1",
            "df -h",
            "du -sh",
            "lsblk"
          ],
          "correct": 0
        },
        {
          "text": "Как монтировать ФС постоянно?",
          "options": [
            "Добавить запись в /etc/fstab",
            "Выполнить mount",
            "Создать скрипт",
            "Использовать systemd"
          ],
          "correct": 0
        },
        {
          "text": "Как узнать UUID раздела?",
          "options": [
            "blkid /dev/sdX1",
            "lsblk",
            "df -h",
            "fdisk -l"
          ],
          "correct": 0
        }
      ]
    }
  ],
  "networking": [
    {
      "title": "IP-адресация и маски подсети",
      "content": "**Рик о сетевых штучках**\n\nЭй, пацаны, слушайте сюда! Сейчас дед Рик объяснит вам, что такое IP-адрес и зачем он нужен. Короче, представьте: вы в какой-то там вселенной, где все устройства в сети должны как-то друг друга узнавать. Вот тут-то и выручают IP-адреса!\n\nIP-адрес, или IPv4, — это такой 32-битный идентификатор, который позволяет устройству болтать в сети. Записывается он в виде четырёх десятичных чисел, разделённых точками. Например, 192.168.1.10 — вот так вот! Понятное дело, что это не просто набор цифр, а целая система, которая помогает устройствам находить друг друга.\n\nА теперь про маску подсети. Это такая штука, которая определяет, какая часть IP-адреса относится к сети, а какая — к конкретному хосту (то есть устройству). Например, маска /24 (или 255.255.255.0) говорит нам, что первые 24 бита в адресе — это сеть, а оставшиеся 8 бит — это уже хосты. То есть в такой подсети теоретически может быть 256 адресов. Но есть нюанс: два адреса зарезервированы — первый (например, 192.168.1.0) — это сетевой адрес, а последний (192.168.1.255) — широковещательный. Поэтому реально доступных хостов — 254.\n\nЕщё есть такие прикольные вещи — приватные диапазоны. Это такие диапазоны IP-адресов, которые используются только во внутренних сетях и не маршрутизируются в интернете. Например, 10.0.0.0/8, 172.16.0.0/12 и 192.168.0.0/16. Они как секретные каналы для общения внутри сети — никто извне их не увидит.\n\nТак что, пацаны, теперь вы знаете, как работают IP-адреса и маски подсети. Это как карта в незнакомом мире — без неё никуда!\n\n#IPадрес #маскаподсети #сетевыетехнологии #РикИМорти #дедРикЗнаетВсё\n\n**Совет:** если хотите разобраться в сетях получше, начните с основ — изучите, как работают IP-адреса и маски подсети. Это как с космосом: сначала нужно понять базовые вещи, а потом уже можно покорять галактики! И не бойтесь спрашивать — лучше задать глупый вопрос, чем потом путаться в сложных вещах.",
      "questions": [
        {
          "text": "Сколько хостов доступно в сети 192.168.1.0/24?",
          "options": [
            "256",
            "254",
            "255",
            "128"
          ],
          "correct": 1
        },
        {
          "text": "Какой из адресов является приватным?",
          "options": [
            "8.8.8.8",
            "172.15.0.1",
            "192.168.10.5",
            "203.0.113.1"
          ],
          "correct": 2
        },
        {
          "text": "Что означает маска /23?",
          "options": [
            "512 адресов всего, 510 для хостов",
            "256 адресов",
            "1024 адреса",
            "128 адресов"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Модели OSI и TCP/IP",
      "content": "**Рик говорит: «Сетевые модели — детская забава!»**\n\nЭй, пацаны, слушайте сюда! Сегодня я вам расскажу про сетевые модели — OSI и TCP/IP. Не думайте, что это какая-то заумная хрень, которую только гении могут понять. Я вам всё объясню так, что даже Морти сообразит (хотя с ним, конечно, порой непросто).\n\nИтак, начнём с OSI — это такая модель, которая описывает, как сетевые протоколы взаимодействуют друг с другом. Представьте себе бутерброд с семью слоями — вот так и здесь: семь уровней, каждый из которых отвечает за свои задачи. Давайте разберём их по порядку:\n\n1. **Физический уровень** — это самый нижний слой, где всё начинается. Тут речь идёт о кабелях, сигналах и прочей физической лабуде. Без этого уровня ничего работать не будет, так что не забывайте про основы!\n\n2. **Канальный уровень** — здесь данные упаковываются в кадры и отправляются дальше. Представьте себе, что вы кладёте письмо в конверт — вот примерно так и работает этот уровень.\n\n3. **Сетевой уровень** — тут уже начинается магия маршрутизации. Данные находят свой путь к цели, как если бы вы прокладывали маршрут на карте. Если у вас не работает ping, то проблема, скорее всего, именно здесь.\n\n4. **Транспортный уровень** — здесь данные делятся на пакеты и отправляются получателю. Тут работает протокол TCP — он как курьер, который гарантирует, что все пакеты дойдут до адресата в целости и сохранности. В модели TCP/IP этот уровень — третий.\n\n5. **Сеансовый уровень** — отвечает за установление, поддержание и завершение сеансов связи. Представьте себе телефонный разговор — кто-то звонит, вы разговариваете, потом прощаетесь и кладёте трубку. Вот примерно так и здесь.\n\n6. **Представительский уровень** — тут данные преобразуются в формат, который может понять получатель. Это как перевод текста с одного языка на другой — чтобы все могли разобраться.\n\n7. **Прикладной уровень** — самый верхний слой, с которым взаимодействует пользователь. Здесь работают такие протоколы, как HTTP, DNS и SSH. Если у вас не открывается сайт, то проблема, скорее всего, на этом уровне.\n\nТеперь про TCP/IP — это более упрощённая модель, которая используется на практике. Она состоит из четырёх уровней:\n\n- **Link (Link Layer)** — это что-то вроде физического и канального уровней в OSI. Здесь всё связано с передачей данных по физической среде.\n\n- **Internet (IP)** — здесь происходит маршрутизация данных, как на сетевом уровне в OSI.\n\n- **Transport (TCP/UDP)** — транспортный уровень, где данные делятся на пакеты. TCP гарантирует доставку пакетов, а UDP — более простой протокол, который не заморачивается на этом.\n\n- **Application (HTTP, DNS, SSH)** — прикладной уровень, где работают протоколы, с которыми мы сталкиваемся в повседневной жизни.\n\nНапример, SSH работает на прикладном уровне, но использует TCP для передачи данных — вот такая вот синергия.\n\nПонимание этих уровней помогает диагностировать проблемы в сети. Если у вас что-то не работает, просто определите, на каком уровне может быть проблема, и решайте её поэтапно. Это как с машиной: если она не едет, сначала проверьте бензин, потом — аккумулятор, затем — двигатель и так далее.\n\n**Советы от Рика:**\n- не бойтесь разбираться в сложных вещах — зачастую они проще, чем кажутся;\n- разбивайте большие задачи на маленькие — так их легче решать;\n- всегда ищите логические связи — они помогут вам понять, как всё работает.\n\n#РикИМорти #СетевыеМодели #OSI #TCPIP #СетевыеПротоколы #ДиагностикаСети\n\nНу что, теперь вы немного больше знаете о сетевых моделях? Если что, я всегда готов помочь — Рик никогда не бросает своих в беде!",
      "questions": [
        {
          "text": "На каком уровне OSI работает протокол TCP?",
          "options": [
            "Сетевой (3-й)",
            "Транспортный (4-й)",
            "Канальный (2-й)",
            "Прикладной (7-й)"
          ],
          "correct": 1
        },
        {
          "text": "На каком уровне OSI работает SSH?",
          "options": [
            "Прикладной (7-й)",
            "Транспортный (4-й)",
            "Сетевой (3-й)",
            "Сеансовый (5-й)"
          ],
          "correct": 0
        },
        {
          "text": "Сколько уровней в модели OSI?",
          "options": [
            "4",
            "5",
            "7",
            "8"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "TCP vs UDP",
      "content": "**Рик говорит: «Про протоколы — разжёвываю для особо тупых»**\n\nЭй, пацаны, слушайте сюда! Сейчас дед Рик объяснит вам про протоколы — TCP и UDP. Не скучайте, это будет эпично!\n\nИтак, начнём с TCP, или Transmission Control Protocol. Это такой протокол, который типа «надёжный пацан». Он как почтальон, который точно доставит ваше письмо, и не просто доставит, а ещё и проследит, чтобы все кусочки письма (пакеты данных) пришли в правильном порядке. И чтоб без дубликатов — типа «я уже прислал, не надо повторять». Как он это делает? Да просто: использует подтверждения (ACK — acknowledgement), если пакет не дошёл, шлёт его снова. И ещё он умеет управлять потоком данных, чтобы не перегружать сеть.\n\nГде используется TCP? Да везде, где нужна надёжность! Например, когда вы серфите по интернету (HTTP), проверяете почту или пользуетесь SSH — всё это работает благодаря TCP. В общем, если вам надо, чтобы данные дошли точно и без косяков — TCP ваш выбор.\n\nА теперь про UDP, или User Datagram Protocol. Это уже другой персонаж — быстрый и безбашенный. Он не заморачивается на доставке, не устанавливает соединение, просто шлёт данные и надеется, что они дойдут. Понятно, что такой подход не гарантирует доставку, но зато скорость — огонь! Поэтому UDP используют там, где важна скорость, а не стопроцентная надёжность. Например, в DNS (система доменных имён), VoIP (голосовая связь), потоковом видео и онлайн-играх.\n\nА вот интересный момент: DNS обычно использует UDP, потому что для стандартных запросов это быстро и эффективно — объём данных небольшой. Но если дело касается больших ответов, например, при использовании DNSSEC (это такая штука для безопасности DNS) или при передаче целой зоны, то DNS переключается на TCP. Почему? Да потому что TCP лучше справится с большими объёмами данных и гарантирует, что всё дойдёт как надо.\n\n**Советы от деда Рика:**\n Если вам нужна надёжность и порядок — выбирайте TCP.\n",
      "questions": [
        {
          "text": "Почему DNS использует UDP?",
          "options": [
            "Потому что запросы короткие и UDP быстрее",
            "Потому что UDP надёжнее TCP",
            "DNS не поддерживает TCP",
            "Для шифрования запросов"
          ],
          "correct": 0
        },
        {
          "text": "Какой протокол гарантирует доставку пакетов?",
          "options": [
            "UDP",
            "ICMP",
            "TCP",
            "ARP"
          ],
          "correct": 2
        },
        {
          "text": "Какой протокол используется для VoIP?",
          "options": [
            "TCP",
            "UDP",
            "HTTP",
            "SSH"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "DNS: как это работает",
      "content": "**Рик говорит: «О, DNS? Да это проще пареной репы, внучок!»**\n\nСлушай сюда, юный падаван, сейчас дед Рик объяснит тебе, как работает эта DNS-штука. Представь, что ты хочешь попасть на сайт yandex.ru. Ты вбиваешь адрес в браузер, и тут начинается магия… ну, или почти магия, тут больше про технику, ха-ха!\n\nИтак, когда ты вводишь адрес сайта, твой браузер не знает, куда тебя отправлять. Ему нужен IP-адрес — такой цифровой адрес сайта. Но ты-то помнишь только доменное имя, типа yandex.ru, а не набор цифр. Вот тут-то на сцену выходит DNS — Domain Name System, или система доменных имён. Она как телефонная книга: ты говоришь имя, а она даёт тебе номер.\n\n**Как это работает?**\n\n1. **Браузер проверяет кеш ОС.** Сначала твой браузер смотрит в свой «блокнот» (кеш операционной системы) — вдруг там уже есть нужный IP-адрес. Если есть — отлично, сразу подключаемся к сайту. Если нет — идём дальше.\n\n2. **Обращение к рекурсивному DNS-резолверу.** Если в «блокноте» ничего нет, браузер идёт к рекурсивному DNS-резолверу — это такой «помощник», который знает, куда дальше идти. Например, у Google есть свой DNS-сервер с адресом 8.8.8.8. Резолвер — это как консьерж в большом здании: ты говоришь ему, куда хочешь попасть, а он знает, к кому дальше обратиться.\n\n3. **Запрос к корневым серверам.** Рекурсивный DNS-резолвер идёт к корневым серверам — это такие «главные двери» в мире DNS. Они не знают точного IP-адреса сайта, но могут сказать, к каким серверам зоны (например, .ru) нужно обратиться.\n\n4. **Запрос к серверам зоны.** Серверы зоны (.ru, .com и т. д.) знают, где находятся авторитетные серверы конкретного домена (например, yandex.ru). Они как указатели на карте: показывают, куда идти дальше.\n\n5. **Запрос к авторитетным серверам.** Авторитетные серверы — это «хозяева» домена. У них есть все необходимые записи:\n A — для IPv4-адресов (старые добрые IP-адреса из четырёх чисел);\n AAAA — для IPv6-адресов (новые, более длинные адреса);\n CNAME — для алиасов (когда одно доменное имя указывает на другое);\n**Рекурсивный DNS кэширует результат.** Когда рекурсивный DNS-резолвер получает нужный IP-адрес, он сохраняет его в кэше. Это как если бы консьерж запомнил, где находится нужная тебе квартира, чтобы в следующий раз сразу сказать тебе адрес. Так система работает быстрее и не тратит время на повторные запросы.\n\n7. **Локальный DNS в браузере/ОС.** Твой браузер или операционная система тоже могут хранить некоторые DNS-записи в локальном кэше. Это как если бы ты сам запомнил некоторые часто используемые адреса — чтобы не спрашивать каждый раз у консьержа.\n\n**Советы от деда Рика:**\n Если у тебя проблемы с доступом к сайту, проверь настройки DNS или очисти кеш браузера — вдруг там «застряла» неправильная информация.\n",
      "questions": [
        {
          "text": "Какие типы DNS-записей существуют?",
          "options": [
            "A, AAAA, CNAME, MX, TXT",
            "TCP, UDP, ICMP",
            "IPv4, IPv6, MAC",
            "SSL, TLS, HTTPS"
          ],
          "correct": 0
        },
        {
          "text": "Что такое рекурсивный DNS?",
          "options": [
            "Сервер, выполняющий полную цепочку запросов за клиента",
            "Сервер, отдающий только кэш",
            "Локальный резолвер в ОС",
            "Корневой сервер"
          ],
          "correct": 0
        },
        {
          "text": "Что такое authority в DNS?",
          "options": [
            "Авторитетный сервер, хранящий оригинальные записи",
            "Центр сертификации",
            "Администратор домена",
            "Тип записи"
          ],
          "correct": 0
        },
        {
          "text": "На каком протоколе работает DNS?",
          "options": [
            "В основном UDP, при больших ответах — TCP",
            "Только TCP",
            "Только HTTP",
            "Только ICMP"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "HTTP и HTTPS",
      "content": "**Рик говорит: «HTTP и HTTPS — разжёвываю для тугодумов!»****GET****POST****PUT****DELETE****2xx****3xx****4xx****5xx****User-Agent****Cookie****Authorization****Content-Type** — говорит, в каком формате передаётся данные, например, HTML, JSON и так далее.\n\nА теперь про HTTPS. Это, пацаны, HTTP, но с дополнительным слоем безопасности. Он работает поверх TLS/SSL и обеспечивает шифрование, целостность и аутентификацию. То есть все данные, которые передаются по HTTPS, зашифрованы, и никто не сможет их перехватить и прочитать. Понял, да?\n\nА вот базовая HTTP-аутентификация — это уже прошлый век. Она передаёт логин и пароль в заголовке Authorization в формате base64. Но без HTTPS это полный провал, потому что данные можно перехватить. Так что если хочешь безопасности — используй HTTPS!\n\n**Хэштеги:** #HTTP #HTTPS #безопасность #веб-технологии #РикЗнаетВсё\n\n**Советы от деда Рика:**\n1. Всегда используй HTTPS на своих сайтах, чтобы защитить данные пользователей.\n2. Изучай статус-коды HTTP — это поможет тебе быстрее находить и исправлять ошибки.\n3. Не храни чувствительную информацию в Cookie без шифрования.\n4. Помни про безопасность — не передавай логины и пароли через HTTP.\n\nНу вот, пацаны, теперь вы знаете про HTTP и HTTPS чуть больше. Держите ухо востро и не дайте себя обмануть!",
      "questions": [
        {
          "text": "Какие основные типы HTTP-запросов существуют?",
          "options": [
            "GET, POST, PUT, DELETE",
            "TCP, UDP, ICMP",
            "A, AAAA, CNAME",
            "SSL, TLS, SSH"
          ],
          "correct": 0
        },
        {
          "text": "Что означает статус-код 404?",
          "options": [
            "Успех",
            "Перенаправление",
            "Ошибка клиента (не найдено)",
            "Ошибка сервера"
          ],
          "correct": 2
        },
        {
          "text": "Что может содержаться в заголовках HTTP?",
          "options": [
            "User-Agent, Cookie, Authorization",
            "MAC-адрес, TTL",
            "SSL-ключ",
            "DNS-записи"
          ],
          "correct": 0
        },
        {
          "text": "Как работает базовая HTTP-аутентификация?",
          "options": [
            "Логин/пароль в base64 в заголовке Authorization",
            "Через TLS-сертификат",
            "Через отдельный порт",
            "С двухфакторной авторизацией"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "SSL/TLS и безопасность",
      "content": "**Рик говорит: «О, протоколы шифрования? Да я в этом как рыба в воде!»**\n\nСлушай сюда, малыш, я тебе объясню, что такое SSL, TLS и вся эта шифровальная ерунда. Только не вздумай засыпать — тема серьёзная!\n\nИтак, SSL и TLS — это такие протоколы, которые помогают шифровать данные в интернете. SSL, кстати, уже устарел, так что забудь про него, а вот TLS — это то, что нужно.\n\nПредставь, ты хочешь зайти на какой-нибудь сайт по HTTPS. Чтобы всё было безопасно, клиент (это твой браузер, например) и сервер (это машина, на которой сайт живёт) должны договориться о том, как они будут шифровать данные. Вот тут-то и начинается TLS-handshake — рукопожатие, которое помогает им всё обсудить.\n\n**Как это работает:**\n\n1. **Клиент и сервер выбирают версию протокола и шифры.** То есть они решают, каким способом будут шифровать данные. Это как если бы вы с другом выбирали язык, на котором будете разговаривать.\n\n2. **Сервер отправляет клиенту сертификат.** Сертификат — это такая «удостоверение личности» сайта. Он говорит: «Да, я — это я, вот мои документы».\n\n3. **Клиент проверяет сертификат у доверенного центра сертификации (CA).** CA — это такая организация, которая выдаёт сертификаты сайтам. Клиент говорит: «Погоди-ка, а этот сертификат настоящий? Давайте спросим у CA». Если CA подтверждает, что сертификат настоящий, то всё окей, можно продолжать.\n\n4. **Генерируется сессионный ключ.** Это такой ключ, который используется для симметричного шифрования. То есть один и тот же ключ используется и для шифрования, и для дешифрования данных. Это как если бы у вас с другом был один и тот же замок, чтобы отправлять друг другу секретные послания.\n\nА теперь давай поговорим о некоторых крутых фишках:\n\n- **SNI (Server Name Indication)** — это такая штука, которая позволяет одному IP-адресу обслуживать несколько HTTPS-сайтов. Представь, что у тебя есть один телефон, но на него могут звонить люди с разными номерами. Вот примерно так и работает SNI. Она передаёт имя хоста на этапе handshake, чтобы сервер знал, какой сайт показывать.\n\n- **PFS (Perfect Forward Secrecy)** — это гарантия того, что если кто-то получит доступ к долгосрочному ключу, то он не сможет расшифровать прошлые сессии. То есть даже если злоумышленник получит ключ, он не сможет узнать, что ты делал в интернете раньше. Это как если бы ты каждый раз использовал новый замок для своих посланий, и даже если кто-то взломает один замок, он не сможет открыть предыдущие.\n\n- **mTLS (mutual TLS)** — это когда и клиент, и сервер предъявляют свои сертификаты. То есть они оба подтверждают свою личность. Это часто используется во внутренних микросервисах, где нужно обеспечить высокий уровень безопасности.\n\nНу вот, теперь ты знаешь немного больше о протоколах шифрования. Не так уж и сложно, правда?\n\n#шифрование #TLS #SSL #безопасность #интернет #технологии\n\n**Совет:** если хочешь разобраться в теме глубже, почитай документацию по TLS и посмотри, как работают сертификаты. И не забывай, что в мире технологий всегда есть место для новых открытий и крутых фишек! А если что-то непонятно — не бойся спрашивать, ведь знание — сила!",
      "questions": [
        {
          "text": "Что такое SNI?",
          "options": [
            "Расширение TLS для передачи имени хоста",
            "Тип DNS-записи",
            "Метод шифрования в SSH",
            "Протокол VoIP"
          ],
          "correct": 0
        },
        {
          "text": "Что такое Perfect Forward Secrecy (PFS)?",
          "options": [
            "Каждая сессия использует уникальный ключ",
            "Полное шифрование данных",
            "Метод сжатия сертификатов",
            "Тип аутентификации"
          ],
          "correct": 0
        },
        {
          "text": "Как работает TLS-handshake?",
          "options": [
            "Договор о шифрах, обмен сертификатами, генерация сессионного ключа",
            "Обмен паролями",
            "Через UDP",
            "С ручным подтверждением"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Сетевые инструменты: ping, traceroute, TTL",
      "content": "**Рик говорит: «О, внучок, давай-ка я тебе объясню, что тут к чему!»**\n\nСлушай сюда, пацан! Есть такая штука — Ping. Это не просто звук, когда ты в дверь стучишь, а целая система, которая помогает понять, работает ли там какой-нибудь сервер или нет. И вот что я тебе скажу: Ping — он хитрый, не пользуется обычными TCP и UDP, а работает через ICMP, то есть Internet Control Message Protocol. Понял, да? Это как если бы ты вместо того, чтобы звонить по телефону, отправлял бы сообщения через специальный секретный канал.\n\nТак вот, Ping отправляет что-то типа «Эй, ты там живой?» — это называется ICMP Echo Request. А если сервер в порядке, он отвечает: «Да, всё ок, я тут!» — это уже ICMP Echo Reply. Круто, да?\n\nА ещё есть такая штука — TTL, Time To Live. Звучит как название какого-то супергероя, но на самом деле это просто число в заголовке IP-пакета, которое ограничивает «время жизни» пакета. Обычно там стоит 64. И вот каждый маршрутизатор, через который проходит пакет, уменьшает это число на единицу. Представь, что это как обратный отсчёт: раз, два, три... и когда доходит до нуля — пакет просто отбрасывается, и отправляется сообщение ICMP Time Exceeded. Типа: «Эй, братан, твой пакет не дошёл, время вышло!»\n\nА теперь смотри, есть ещё одна крутая штука — Traceroute. Она использует TTL, чтобы построить маршрут до цели. Как это работает? Да просто! Traceroute отправляет пакеты с TTL, равным 1, потом 2, потом 3 и так далее. И по ответам ICMP строит карту маршрута. Получается, ты видишь, через какие маршрутизаторы проходит твой пакет, пока добирается до цели.\n\nА вот ещё интересный момент: если у тебя низкий latency до 8.8.8.8 (это адрес Google DNS), то это значит, что у них там всё круто настроено. Они используют глобальную CDN (Content Delivery Network) и оптимизируют маршруты, чтобы данные шли как можно быстрее. Так что если у тебя всё быстро грузится, знай — это не просто так, это результат работы умных ребят и крутых технологий!\n\n**Хэштеги:** #РикЗнаетВсё #ICMP #Ping #Traceroute #TTL #CDN #Latency\n\n**Советы от Рика:**\n1. Если хочешь разобраться в сетях, не бойся сложных терминов — просто разбей их на части и пойми, что они означают.\n2. Используй Ping и Traceroute, чтобы проверить, как работает твоя сеть — это как диагностика автомобиля, только для интернета.\n3. Помни, что в мире технологий всё меняется очень быстро, так что не останавливайся на достигнутом — учись и развивайся!\n\n**Рик добавляет:** «Ну вот, пацан, теперь ты знаешь чуть больше о том, как работает интернет. Неплохо, да?»",
      "questions": [
        {
          "text": "На каком порту работает ping?",
          "options": [
            "Ping не использует порты — работает поверх ICMP",
            "Порт 7",
            "Порт 53",
            "Порт 80"
          ],
          "correct": 0
        },
        {
          "text": "Что такое TTL?",
          "options": [
            "Поле в IP-заголовке, ограничивающее время жизни пакета",
            "Тип лицензии",
            "Метод сжатия",
            "Протокол аутентификации"
          ],
          "correct": 0
        },
        {
          "text": "Как работает traceroute?",
          "options": [
            "Отправляет пакеты с увеличивающимся TTL",
            "Делает ping до каждого узла",
            "Использует DNS",
            "Анализирует таблицу маршрутизации"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "NAT, VLAN и маршрутизация",
      "content": "**Рик говорит: «О, NAT и VLAN? Да это проще пареной репы, внучок!»**\n\nСлушай сюда, пацанва! Сейчас дед Рик объяснит вам, что такое NAT и VLAN. Не какие-то там заумные термины, а на понятном языке.\n\nИтак, NAT, или Network Address Translation. Представь, что у тебя дома целая толпа устройств: смартфоны, ноутбуки, планшеты — все хотят в интернет. Но провайдер дал тебе всего один публичный IP-адрес. Что делать? Тут-то на сцену выходит NAT!\n\nРоутер, этот хитрый малый, использует NAT, чтобы все твои устройства могли выйти в интернет через один публичный IP. Как это работает? Допустим, у тебя на ноутбуке локальный IP-адрес 192.168.1.10. Когда ты хочешь зайти, например, на YouTube, роутер говорит: «Окей, я заменю твой локальный IP на свой публичный, чтобы интернет понял, куда слать ответ». А когда сервер YouTube ответит, роутер снова подменит адрес и направит данные прямо на твой ноутбук. Круто, да?\n\nА теперь про VLAN, или Virtual LAN. Представь, что у тебя большая компания, и в ней есть разные отделы: бухгалтерия, маркетинг, IT. Каждый отдел должен иметь доступ только к своим ресурсам, чтобы не было путаницы и утечки информации. Вот тут-то VLAN и пригодится!\n\nVLAN позволяет логически разделить одну физическую сеть на несколько изолированных сегментов. То есть, даже если все компьютеры подключены к одной и той же сети, VLAN создаст виртуальные «комнаты», где каждый отдел будет как бы в своей собственной сети. Это повышает безопасность и упрощает управление сетью. Например, если кто-то из бухгалтерии попытается зайти в систему IT-отдела, у него ничего не получится — VLAN не даст.\n\nА теперь про таблицу маршрутизации. Это такая штука, которая помогает роутеру понимать, куда отправлять пакеты данных. Представь, что ты отправляешь письмо. Ты пишешь адрес на конверте, а почтовая служба решает, как его доставить. Точно так же и здесь: таблица маршрутизации определяет, куда отправить каждый пакет. Если пакет должен уйти в интернет, он идёт через шлюз (роутер), а если в локальную сеть — отправляется напрямую.\n\n**Советы от деда Рика:**\n1. Если у тебя дома много устройств, проверь настройки NAT на роутере — вдруг там что-то можно оптимизировать.\n2. Если ты работаешь в большой компании, узнай, используют ли там VLAN — это может повлиять на твой доступ к ресурсам.\n3. Изучи основы работы с таблицами маршрутизации — это пригодится, если ты захочешь покопаться в настройках сети.\n\n#NAT #VLAN #роутер #сеть #интернет #маршруты #IT #технологии\n\nНу вот, пацанва, теперь вы знаете, что такое NAT и VLAN. Не так уж и сложно, правда?",
      "questions": [
        {
          "text": "Зачем нужен VLAN?",
          "options": [
            "Для логического разделения физической сети",
            "Для увеличения скорости",
            "Для шифрования",
            "Для настройки IP"
          ],
          "correct": 0
        },
        {
          "text": "Как работает NAT?",
          "options": [
            "Позволяет многим устройствам использовать один публичный IP",
            "Шифрует трафик",
            "Блокирует соединения",
            "Ускоряет DNS"
          ],
          "correct": 0
        },
        {
          "text": "Что такое таблица маршрутизации?",
          "options": [
            "Определяет, куда направлять пакеты",
            "Хранит пароли",
            "Список DNS-серверов",
            "Журнал подключений"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Практические сценарии",
      "content": "**Рик говорит: проблемы с доступом к сервису на порту 80 — разберёмся!**\n\nЭй, пацаны, слышали про такую штуку? У тебя есть сервис, который работает на порту 80. Ты проверяешь его локально — всё пучком, curl localhost отвечает, а вот извне — тишина, как в склепе. Ну, я тут, чтобы объяснить, что к чему, и раскусить эту загадку, как орешек.\n\nИтак, давай разберёмся, почему твой сервис не виден из внешнего мира. Есть несколько вариантов, и я сейчас их все разложу по полочкам.\n\n**Первая причина: фаервол — твой недруг.**\n\nФаервол — это такая штука, которая стоит на страже твоего компьютера и решает, кому можно зайти, а кому — нет. Представь себе его как строгого охранника у входа в клуб. Он может блокировать входящие подключения, и тогда твой сервис будет недоступен извне.\n\nНапример, у тебя может быть включён Windows Defender или iptables — это такие программы, которые выполняют роль фаервола. Они могут быть настроены так, что блокируют входящие подключения на порт 80. Чтобы проверить, так ли это, нужно заглянуть в настройки фаервола и посмотреть, какие правила там установлены.\n\n**Вторая причина: сервис «слушает» только localhost.**\n\nБывает такое, что твой сервис настроен так, что «слушает» только адрес 127.0.0.1 (localhost), а не 0.0.0.0 (все интерфейсы). Это значит, что он доступен только с твоего компьютера, а извне его не видно.\n\nЧтобы проверить, так ли это, можно использовать команду netstat -tuln. Если в выводе ты видишь 127.0.0.1:80, то сервис «слушает» только localhost. А если видишь 0.0.0.0:80 — значит, он доступен со всех интерфейсов, и проблема, скорее всего, в чём-то другом.\n\n**Третья причина: провайдер или хостинг блокируют порт 80.**\n\nБывает, что провайдер или хостинг-провайдер блокируют порт 80, особенно если ты используешь VPS без белого IP-адреса. Это делается для безопасности или по каким-то другим причинам. В таком случае твой сервис просто не сможет принимать входящие подключения на этом порту.\n\n**Что делать?**\n\n1. Проверь настройки фаервола. Если он блокирует порт 80, измени правила так, чтобы разрешить входящие подключения.\n2. Проверь, на какой адрес «слушает» твой сервис. Если он «слушает» только localhost, измени настройки так, чтобы он «слушал» все интерфейсы.\n3. Если ты используешь VPS без белого IP, свяжись с хостинг-провайдером и узнай, не блокируют ли они порт 80.\n\n**Хэштеги:** #РикЗнаетВсё #ПроблемыСПортом80 #Фаервол #Хостинг #VPS\n\n**Советы:**\n всегда проверяй настройки фаервола — это первая вещь, которую нужно проверить при проблемах с доступом;\n",
      "questions": [
        {
          "text": "Сервис на 80 порту доступен локально, но не из браузера. Почему?",
          "options": [
            "Слушает только 127.0.0.1 или фаервол блокирует",
            "Порт 80 закрыт провайдером",
            "Нужен HTTPS",
            "Браузер не поддерживает HTTP"
          ],
          "correct": 0
        },
        {
          "text": "Почему latency до 8.8.8.8 всегда низкий?",
          "options": [
            "Потому что это Google DNS с глобальной CDN",
            "Потому что это локальный адрес",
            "Потому что пинг через UDP",
            "Потому что нет шифрования"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Балансировщики L4 и L7",
      "content": "**Рик говорит: о балансировщиках трафика — проще некуда!**\n\nЭй, пацанва! Сегодня дед Рик объяснит вам про балансировщики трафика — штука полезная, если вы не хотите, чтобы ваши сервера взорвались от нагрузки. Так что слушайте внимательно, а то потом сами будете разбираться, как из этого хаоса выпутаться!\n\nИтак, есть два основных типа балансировщиков: L4 и L7. Давайте разберёмся, что это за зверьки.\n\n**L4-балансировщик** (например, IPVS или HAProxy в режиме TCP) работает на транспортном уровне — это значит, что он оперирует с TCP и UDP. Представьте себе огромного дедушку, который сидит на перекрёстке и распределяет машины по разным дорогам, глядя только на номер региона и модель авто, но не заглядывая внутрь салона. Вот так и L4-балансировщик: он распределяет трафик по IP-адресу и порту, не вдаваясь в подробности содержимого пакетов. Быстро, эффективно, но, конечно, ограничен в возможностях. Если вам нужно что-то простое и быстрое — L4 будет в самый раз.\n\nА теперь поговорим про **L7-балансировщик** (например, Nginx, HAProxy в HTTP-режиме или ALB в AWS). Этот парень работает на прикладном уровне, то есть он уже не просто смотрит на «номер региона и модель авто», а заглядывает внутрь «салона» и изучает, что там за «пассажиры». L7-балансировщик читает заголовки HTTP (например, Host, User-Agent), может маршрутизировать трафик по URI, кукам и даже содержимому. Это как если бы ваш дедушка на перекрёстке не просто распределял машины, а ещё и проверял, кто сидит в машине, куда люди едут и даже что они везут.\n\nБлагодаря таким возможностям L7-балансировщик позволяет проводить канареечные релизы и A/B-тестирование — то есть тестировать новые функции или версии сайта, не рискуя всем трафиком. Но за такие продвинутые возможности приходится платить — L7 требует больше ресурсов, чем L4.\n\n**Так какой балансировщик выбрать?**\n* Если вам нужна простота и скорость — выбирайте L4. Он отлично подойдёт для базовых задач, где не требуется сложная логика маршрутизации.\n* Если вам нужны продвинутые возможности маршрутизации и тестирования — L7 будет лучшим выбором, несмотря на более высокие требования к ресурсам.\n\n**#балансировщикТрафика #L4 #L7 #IT #технологии #сервер #трафик #маршрутизация**\n\n**Совет от деда Рика:** не пытайтесь использовать L4 там, где нужен L7 — это как пытаться забить гвоздь микроскопом. И наоборот — не используйте L7 там, где вполне справится L4, иначе ваши серверы будут тратить ресурсы впустую. Выбирайте инструмент под задачу — и всё будет чики-пуки!",
      "questions": [
        {
          "text": "Чем отличаются балансировщики L4 и L7?",
          "options": [
            "L4 — по IP/порту; L7 — по содержимому (HTTP)",
            "L4 шифрует трафик",
            "L7 быстрее",
            "L4 используется только в облаке"
          ],
          "correct": 0
        },
        {
          "text": "Что даёт балансировщик трафика?",
          "options": [
            "Распределение нагрузки для отказоустойчивости",
            "Шифрование всего трафика",
            "Автоматическую настройку DNS",
            "Ускорение интернета"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "SSH и безопасный доступ",
      "content": "**Рик говорит: SSH — это вам не шутки, пацаны!**\n\nЭй, чуваки, слушайте сюда! Сейчас дед Рик объяснит вам, что такое SSH и как он работает. Не думайте, что это какая-то там мутная хрень — всё на самом деле просто, как дважды два.\n\nSSH, или Secure Shell, — это такая штука, которая позволяет вам соединяться с удалёнными компьютерами и управлять ими, причём всё это — в безопасной манере. Почему безопасной? Да потому что весь трафик шифруется, и никто не сможет подслушать ваши секретные данные. Работает эта система поверх TCP, и стандартный порт для SSH — 22. Запомните это, пригодится!\n\nИтак, давайте разберём, как происходит установка соединения по SSH. Представьте себе, что клиент (это ваш компьютер) и сервер (другой компьютер, к которому вы хотите подключиться) — это два крутых спеца, которые должны обменяться секретной информацией. Вот что происходит:\n\n1. **Обмен версиями.** Сначала клиент и сервер говорят друг другу: «Эй, братан, какая у тебя версия SSH?» Это нужно, чтобы убедиться, что они могут нормально общаться.\n\n2. **Договариваются о шифрах.** Потом они выбирают, каким способом будут шифровать данные. Это как если бы вы с другом решили, какой шифр будете использовать для секретных посланий.\n\n3. **Сервер отправляет свой публичный ключ.** Сервер говорит клиенту: «Вот мой публичный ключ, проверь его». Публичный ключ — это такая штука, которая позволяет убедиться, что вы общаетесь именно с тем сервером, с которым хотите.\n\n4. **Клиент проверяет ключ.****По паролю.** Вы просто вводите пароль, и если он совпадает с тем, что хранится на сервере, — вуаля, вы в системе. Но этот способ не самый безопасный, потому что пароль можно украсть или подобрать.\n\n2. **По ключу.** Это более крутой и безопасный способ. Клиент подписывает запрос своим приватным ключом, а сервер проверяет его публичным ключом. Приватный ключ — это ваша суперсекретная штука, которую вы никому не показываете, а публичный ключ — это то, что вы можете раздавать всем, кому угодно.\n\nПочему ключи лучше паролей? Да потому что их сложнее украсть, и они обеспечивают более высокий уровень безопасности. К тому же, с ключами вам не нужно каждый раз вводить пароль — это удобнее!\n\n**Хэштеги:** #SSH #SecureShell #РикЗнаетВсё #БезопасностьВсети\n\n**Советы от деда Рика:**",
      "questions": [
        {
          "text": "Как устанавливает соединение SSH?",
          "options": [
            "Обмен версиями, договор о шифрах, проверка ключа",
            "Через HTTP-запрос",
            "Через UDP",
            "Требует DNS TXT"
          ],
          "correct": 0
        },
        {
          "text": "Какой метод авторизации в SSH надёжнее?",
          "options": [
            "По ключу",
            "По паролю",
            "По IP",
            "По имени пользователя"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Дополнительно: mTLS, iptables, PFS",
      "content": "**Рик говорит: о mTLS, iptables и PFS**\n\nЭй, пацаны, слушайте сюда! Сегодня дед Рик расскажет вам про пару крутых штук, которые пригодятся, если вы вдруг решите покопаться в сетевых штучках. Ну, знаете, для тех, кто хочет почувствовать себя настоящим хакером (только без всех этих нелепых шапочек и очков, ха-ха!).\n\nИтак, начнём с mTLS, или mutual TLS. Это такая штука, которая помогает двум компам (или, если хотите, двум микросервисам) убедиться, что они общаются именно друг с другом, а не с каким-нибудь левым чуваком, который решил влезть в разговор. Короче, это как если бы вы с другом обменивались секретными рукопожатиями, чтобы убедиться, что это действительно ваш друг, а не какой-то самозванец. В случае с mTLS оба участника — и клиент, и сервер — предъявляют друг другу сертификаты. Это как паспорта в цифровом мире, только круче.\n\nТеперь давайте поговорим про iptables. Это такая утилита в Linux, которая позволяет управлять сетевым трафиком. Представьте себе, что у вас есть огромный поток данных, который нужно как-то направить в нужное русло. Вот тут-то и приходит на помощь iptables! С её помощью можно пробросить порты, то есть перенаправить трафик с одного порта на другой. Например, вот такая команда:\n\n```\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080\n```\n\nЧто она делает? А вот что: она перенаправляет внешний порт 80 (который обычно используется для HTTP-трафика) на внутренний порт 8080. То есть, если кто-то попытается подключиться к вашему серверу через порт 80, трафик будет перенаправлен на порт 8080, который, возможно, используется каким-то внутренним сервисом. Круто, правда?\n\nИ наконец, поговорим про PFS, или Perfect Forward Secrecy. Это такая технология, которая обеспечивает дополнительную безопасность в процессе обмена ключами. Суть в том, что каждый сеанс использует уникальный ключ, который не связан с ключами других сеансов. Это как если бы вы каждый раз, когда хотите обменяться секретной информацией с другом, придумывали новый способ шифрования, который никто раньше не использовал. Таким образом, даже если злоумышленник каким-то образом получит доступ к одному ключу, он не сможет использовать его для расшифровки других сеансов.\n\n**Советы от деда Рика:**\n1. Если вы работаете с сетевыми настройками, всегда делайте резервные копии текущих правил перед тем, как вносить изменения. Это спасёт вас от неприятных сюрпризов.\n2. Изучайте документацию и примеры использования инструментов, которые вы используете. Это поможет вам избежать ошибок и лучше понять, как всё работает.\n3. Не бойтесь экспериментировать, но всегда думайте о безопасности. В мире IT безопасность — это ключ к успеху!\n\n#mTLS #iptables #PFS #сетевыенастройки #безопасность #РикиМорти #дедРик #хакер #микросервисы",
      "questions": [
        {
          "text": "Что такое mTLS?",
          "options": [
            "Взаимная аутентификация по сертификатам",
            "Тип балансировщика",
            "Метод сжатия TLS",
            "Протокол для мобильных сетей"
          ],
          "correct": 0
        },
        {
          "text": "Как работает двусторонняя аутентификация (mTLS)?",
          "options": [
            "И клиент, и сервер проверяют сертификаты",
            "Используется только пароль",
            "Работает без сертификатов",
            "Требует физического ключа"
          ],
          "correct": 0
        },
        {
          "text": "Как настроить проброс портов через iptables?",
          "options": [
            "iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080",
            "iptables --allow-port 80",
            "Невозможно",
            "Через route add"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Итоговый тест: полная проверка знаний по сетям",
      "content": "**Рик говорит: «О, сети? Пф, я знаю о них больше, чем ты можешь себе представить!»**\n\nСлушай сюда, малыш, я, Рик, величайший ум во вселенной (ну, по крайней мере, в той части, которую я исследовал), и я могу тебе сказать: сети — это не просто провода и сигналы. Это целая вселенная возможностей, где данные летают быстрее, чем ты можешь сказать «межпространственный портал».\n\nТак что, если перед тобой тест по сетям — от простых IP-адресов до сложных штук вроде mTLS и PFS — не нервничай. Я тебе так скажу: IP — это как адрес на конверте, только для компьютеров. А mTLS и PFS — это уже уровень секретных агентов в мире данных, где каждый байт защищён лучше, чем тайная лаборатория какого-нибудь безумного учёного.\n\nПомни, в сетях, как и в путешествиях по мультивселенным, главное — не теряться и всегда иметь запасной план. Если что-то пошло не так, просто вспомни: я, Рик, всегда нахожу выход из самых сложных ситуаций. Так что и ты сможешь разобраться с этими сетями!\n\n**Советы от Рика:**\n не бойся сложных терминов — разберись, что они означают, и всё станет проще;\n",
      "questions": [
        {
          "text": "Что такое IP и маска подсети?",
          "options": [
            "IP — уникальный идентификатор устройства; маска определяет границу сети и хоста",
            "IP — MAC-адрес",
            "IP — имя домена",
            "IP — пароль от Wi-Fi"
          ],
          "correct": 0
        },
        {
          "text": "Чем отличается TCP от UDP?",
          "options": [
            "TCP — надёжный с подтверждением; UDP — быстрый, без гарантий",
            "TCP работает только локально",
            "TCP использует порты, UDP — нет",
            "TCP шифрует трафик"
          ],
          "correct": 0
        },
        {
          "text": "Как работает DNS, зачем он нужен?",
          "options": [
            "Преобразует домены в IP-адреса",
            "Шифрует трафик",
            "Блокирует сайты",
            "Ускоряет загрузку"
          ],
          "correct": 0
        },
        {
          "text": "Какие типы DNS-записей существуют?",
          "options": [
            "A, AAAA, CNAME, MX, TXT",
            "TCP, UDP, ICMP",
            "IPv4, IPv6, MAC",
            "SSL, TLS, HTTPS"
          ],
          "correct": 0
        },
        {
          "text": "Как узнать мой внешний IP-адрес?",
          "options": [
            "Через сервисы вроде ifconfig.me",
            "Командой ipconfig",
            "Командой ifconfig",
            "В настройках роутера"
          ],
          "correct": 0
        },
        {
          "text": "Какие стандартные коды ответов есть у веб-серверов?",
          "options": [
            "2xx, 3xx, 4xx, 5xx",
            "1xx, 2xx, 3xx",
            "A, B, C, D",
            "HTTP, HTTPS, FTP"
          ],
          "correct": 0
        },
        {
          "text": "В чём отличие HTTP от HTTPS?",
          "options": [
            "HTTPS — это HTTP поверх TLS",
            "HTTP только на порту 80",
            "HTTPS быстрее",
            "HTTP требует авторизации"
          ],
          "correct": 0
        },
        {
          "text": "Что такое SSL и TLS?",
          "options": [
            "Протоколы шифрования транспортного уровня",
            "Типы веб-серверов",
            "Методы сжатия",
            "СУБД"
          ],
          "correct": 0
        },
        {
          "text": "Какие основные типы HTTP-запросов существуют?",
          "options": [
            "GET, POST, PUT, DELETE",
            "TCP, UDP, ICMP",
            "A, AAAA, CNAME",
            "SSL, TLS, SSH"
          ],
          "correct": 0
        },
        {
          "text": "Как TCP устанавливает соединение?",
          "options": [
            "Через трёхэтапное рукопожатие",
            "Через двухэтапное",
            "Автоматически",
            "С DNS-запросом"
          ],
          "correct": 0
        },
        {
          "text": "Что происходит, когда в браузере вводишь yandex.ru?",
          "options": [
            "DNS-запрос, TCP-соединение, HTTP-запрос",
            "Сразу HTTPS без DNS",
            "Подключение к локальному серверу",
            "Используется только UDP"
          ],
          "correct": 0
        },
        {
          "text": "Как TCP поддерживает соединение?",
          "options": [
            "Через ACK, повторные передачи, управление потоком",
            "Через регулярные ping",
            "С DNS-кэшированием",
            "Автоматически"
          ],
          "correct": 0
        },
        {
          "text": "Что такое и зачем нужен ARP-протокол?",
          "options": [
            "Сопоставляет IP MAC-адресам в локальной сети",
            "Шифрует трафик",
            "Маршрутизирует пакеты",
            "Блокирует IP"
          ],
          "correct": 0
        },
        {
          "text": "Зачем нужен VLAN?",
          "options": [
            "Для логического разделения физической сети",
            "Для увеличения скорости",
            "Для шифрования",
            "Для настройки IP"
          ],
          "correct": 0
        },
        {
          "text": "На каком уровне OSI работает TCP?",
          "options": [
            "Транспортный (4-й)",
            "Сетевой (3-й)",
            "Канальный (2-й)",
            "Прикладной (7-й)"
          ],
          "correct": 0
        },
        {
          "text": "На каком уровне OSI работает SSH?",
          "options": [
            "Прикладной (7-й)",
            "Транспортный (4-й)",
            "Сетевой (3-й)",
            "Сеансовый (5-й)"
          ],
          "correct": 0
        },
        {
          "text": "Что такое адреса 127.0.0.0/8, 192.168.0.0/16 и т.д.?",
          "options": [
            "Приватные диапазоны для внутренних сетей",
            "Публичные DNS",
            "Корневые серверы",
            "Multicast"
          ],
          "correct": 0
        },
        {
          "text": "Как работает NAT и зачем он нужен?",
          "options": [
            "Позволяет многим устройствам использовать один публичный IP",
            "Шифрует трафик",
            "Блокирует соединения",
            "Ускоряет DNS"
          ],
          "correct": 0
        },
        {
          "text": "Что такое SNI?",
          "options": [
            "Расширение TLS для передачи имени хоста",
            "Тип DNS-записи",
            "Метод шифрования SSH",
            "Протокол VoIP"
          ],
          "correct": 0
        },
        {
          "text": "Чем симметричное шифрование отличается от асимметричного?",
          "options": [
            "Симметричное — один ключ; асимметричное — пара ключей",
            "Симметричное медленнее",
            "Симметричное только в HTTPS",
            "Асимметричное не обеспечивает целостность"
          ],
          "correct": 0
        },
        {
          "text": "Почему DNS использует UDP?",
          "options": [
            "Потому что запросы короткие и UDP быстрее",
            "Потому что UDP надёжнее",
            "DNS не поддерживает TCP",
            "Для шифрования"
          ],
          "correct": 0
        },
        {
          "text": "На каком порту работает ping?",
          "options": [
            "Ping не использует порты — работает поверх ICMP",
            "Порт 7",
            "Порт 53",
            "Порт 80"
          ],
          "correct": 0
        },
        {
          "text": "Как работает ICMP?",
          "options": [
            "Протокол для служебных сообщений (ошибки доставки)",
            "Шифрует трафик",
            "Используется для DNS",
            "Работает только в IPv6"
          ],
          "correct": 0
        },
        {
          "text": "Что такое TTL?",
          "options": [
            "Поле в IP-заголовке, ограничивающее время жизни пакета",
            "Тип лицензии",
            "Метод сжатия",
            "Протокол аутентификации"
          ],
          "correct": 0
        },
        {
          "text": "Как работает traceroute?",
          "options": [
            "Отправляет пакеты с увеличивающимся TTL",
            "Делает ping до каждого узла",
            "Использует DNS",
            "Анализирует таблицу маршрутизации"
          ],
          "correct": 0
        },
        {
          "text": "Что такое authority в DNS?",
          "options": [
            "Авторитетный сервер с оригинальными записями",
            "Центр сертификации",
            "Администратор домена",
            "Тип записи"
          ],
          "correct": 0
        },
        {
          "text": "Что такое рекурсивный DNS?",
          "options": [
            "Сервер, выполняющий полную цепочку запросов за клиента",
            "Сервер с кэшированными ответами",
            "Локальный резолвер",
            "Корневой сервер"
          ],
          "correct": 0
        },
        {
          "text": "У тебя маска /23. Сколько адресов доступно?",
          "options": [
            "512 всего, 510 для хостов",
            "256",
            "1024",
            "128"
          ],
          "correct": 0
        },
        {
          "text": "Как работает базовая HTTP-аутентификация?",
          "options": [
            "Логин/пароль в base64 в заголовке Authorization",
            "Через TLS-сертификат",
            "Через отдельный порт",
            "С двухфакторной авторизацией"
          ],
          "correct": 0
        },
        {
          "text": "Как работают сертификаты в HTTPS?",
          "options": [
            "Сервер отправляет сертификат, клиент проверяет у CA",
            "Сертификат шифрует весь трафик",
            "Сертификат генерируется браузером",
            "Используется только для SMTP"
          ],
          "correct": 0
        },
        {
          "text": "Как устанавливает соединение SSH?",
          "options": [
            "Обмен версиями, договор о шифрах, проверка ключа",
            "Через HTTP",
            "Через UDP",
            "Требует DNS TXT"
          ],
          "correct": 0
        },
        {
          "text": "Чем отличаются балансировщики L4 и L7?",
          "options": [
            "L4 — по IP/порту; L7 — по содержимому",
            "L4 шифрует трафик",
            "L7 быстрее",
            "L4 только в облаке"
          ],
          "correct": 0
        },
        {
          "text": "Почему latency до 8.8.8.8 всегда низкий?",
          "options": [
            "Потому что это Google DNS с глобальной CDN",
            "Потому что локальный адрес",
            "Потому что пинг через UDP",
            "Потому что нет шифрования"
          ],
          "correct": 0
        },
        {
          "text": "На каком протоколе работает DNS?",
          "options": [
            "В основном UDP, при больших ответах — TCP",
            "Только TCP",
            "Только HTTP",
            "Только ICMP"
          ],
          "correct": 0
        },
        {
          "text": "Сервис на 80 порту доступен локально, но не из браузера. Почему?",
          "options": [
            "Слушает только 127.0.0.1 или фаервол блокирует",
            "Порт 80 закрыт провайдером",
            "Нужен HTTPS",
            "Браузер не поддерживает HTTP"
          ],
          "correct": 0
        },
        {
          "text": "Что даёт балансировщик трафика?",
          "options": [
            "Распределение нагрузки для отказоустойчивости",
            "Шифрование всего трафика",
            "Автоматическую настройку DNS",
            "Ускорение интернета"
          ],
          "correct": 0
        },
        {
          "text": "Что такое mTLS?",
          "options": [
            "Взаимная аутентификация по сертификатам",
            "Тип балансировщика",
            "Метод сжатия TLS",
            "Протокол для мобильных сетей"
          ],
          "correct": 0
        },
        {
          "text": "Что может содержаться в заголовках HTTP?",
          "options": [
            "User-Agent, Cookie, Authorization",
            "MAC-адрес, TTL",
            "SSL-ключ",
            "DNS-записи"
          ],
          "correct": 0
        },
        {
          "text": "Как работает TLS-handshake?",
          "options": [
            "Договор о шифрах, обмен сертификатами, генерация ключа",
            "Обмен паролями",
            "Через UDP",
            "С ручным подтверждением"
          ],
          "correct": 0
        },
        {
          "text": "Как настроить проброс портов через iptables?",
          "options": [
            "iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080",
            "iptables --allow-port 80",
            "Невозможно",
            "Через route add"
          ],
          "correct": 0
        },
        {
          "text": "Что такое Perfect Forward Secrecy (PFS)?",
          "options": [
            "Каждая сессия использует уникальный ключ",
            "Полное шифрование данных",
            "Метод сжатия сертификатов",
            "Тип аутентификации"
          ],
          "correct": 0
        },
        {
          "text": "Как работает двусторонняя аутентификация (mTLS)?",
          "options": [
            "И клиент, и сервер проверяют сертификаты",
            "Используется только пароль",
            "Работает без сертификатов",
            "Требует физического ключа"
          ],
          "correct": 0
        }
      ]
    }
  ],
  "databases": [
    {
      "title": "TRUNCATE, DELETE и DROP в SQL",
      "content": "**Рик говорит: «О, внучок, давай-ка я объясню тебе про эти команды — DELETE, TRUNCATE и DROP. Слушай внимательно, а то запутаешься, как в многомерном лабиринте!»**\n\nПредставь, что у тебя есть таблица с данными — ну, типа как таблица с результатами экспериментов, только без всяких там странных существ и чёрных дыр. И вот тебе нужно что-то из этой таблицы убрать. Но как? Тут-то и приходят на помощь наши три друга: DELETE, TRUNCATE и DROP.\n\n**DELETE** — это такой «деликатный» способ убрать данные. Он позволяет тебе выбрать, какие именно строки ты хочешь удалить, а какие оставить. Например, если ты хочешь избавиться только от записей с определённым условием, то тут DELETE — твой выбор. Можно использовать WHERE, чтобы указать, какие строки тебе не нужны. Плюс, DELETE поддерживает ROLLBACK — то есть, если вдруг ты передумаешь, можно откатить изменения и вернуть всё как было. А ещё DELETE может вызывать триггеры — это такие «спусковые крючки», которые запускают дополнительные действия при удалении данных.\n\n**TRUNCATE** — это уже более радикальный метод. Он быстро очищает всю таблицу, не заморачиваясь с выбором отдельных строк. Представь, что ты взял и стёр всю доску одним махом — вот это и есть TRUNCATE. При этом он ещё и сбрасывает автоинкремент — то есть, если у тебя есть поле с автоматическим увеличением значения, TRUNCATE вернёт его к начальному состоянию. Но есть и минусы: TRUNCATE не логирует данные построчно, то есть не записывает в журнал каждую удалённую строку. И в MySQL, например, откат после TRUNCATE невозможен — так что если ты случайно очистил не ту таблицу, придётся смириться с последствиями.\n\n**DROP** — это вообще «ядерный» вариант. Он удаляет таблицу полностью: и данные, и структуру, и индексы — всё уходит в небытие. Так что если ты решил, что таблица больше не нужна вообще, DROP — твой выбор. Но будь осторожен: если ты используешь DROP, то вернуть данные уже не получится.\n\n**Так когда же что использовать?****DELETE****TRUNCATE****DROP** — когда таблица больше не нужна вообще. Например, если ты решил полностью изменить структуру базы данных и старая таблица тебе уже не пригодится.\n\n**Хэштеги:** #DELETE #TRUNCATE #DROP #базыданных #SQL #РикОбъясняет\n\n**Совет от Рика:** всегда делай резервные копии данных, прежде чем удалять что-либо. А то мало ли — вдруг понадобится что-то вернуть, а данных уже нет. И помни: в мире баз данных, как и в мире приключений, лучше перестраховаться, чем потом разбираться с последствиями!",
      "questions": [
        {
          "text": "Какая команда удаляет таблицу полностью, включая структуру?",
          "options": [
            "DELETE",
            "TRUNCATE",
            "DROP",
            "ALTER"
          ],
          "correct": 2
        },
        {
          "text": "Какая команда позволяет использовать WHERE для удаления строк?",
          "options": [
            "DELETE",
            "TRUNCATE",
            "DROP",
            "CREATE"
          ],
          "correct": 0
        },
        {
          "text": "Какая команда сбрасывает автоинкрементный счётчик?",
          "options": [
            "DELETE",
            "TRUNCATE",
            "Обе",
            "Ни одна"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Индексы в базах данных",
      "content": "**Рик говорит: «Индексы в базах данных — проще некуда!»**\n\nЧувак, слушай сюда! Индексы в базах данных — это типа оглавления в книге. Понял? Ну вот, например, ты хочешь найти какую-то инфу в толстенном талмуде. Ты же не будешь листать каждую страницу, правда? Ты заглянешь в оглавление, найдёшь нужную тему и сразу перейдёшь туда. Вот и базы данных так же работают с индексами!\n\nИндексы — это такие структуры, которые помогают ускорить поиск данных. Их создают для столбцов, которые часто используются в запросах. Например, когда ты пишешь WHERE, JOIN или ORDER BY, индексы могут сильно ускорить процесс.\n\nЕсть разные типы индексов:\n* B-дерево — это стандартный тип, который используется чаще всего.\n* Хеш-индексы — они работают только с операцией «равно» (=).\n* Составные индексы — это когда ты создаёшь индекс для нескольких столбцов сразу. Удобно, когда нужно искать по нескольким параметрам одновременно.\n* GIN и GiST — это более продвинутые типы индексов, которые используются для работы с JSON и текстовыми данными.\n\nТеперь давай поговорим о плюсах и минусах. Индексы реально ускоряют выполнение SELECT-запросов. Но есть и обратная сторона медали: они могут замедлять INSERT и UPDATE. Почему? Да потому что, когда ты добавляешь или изменяешь данные, индексы тоже нужно обновлять! Так что тут надо думать, где их использовать, а где — нет.\n\nЕщё есть такие вещи, как уникальные индексы. Они гарантируют, что в столбце не будет дубликатов. То есть если ты установишь уникальный индекс, база данных не позволит вставить повторяющиеся значения. Это полезно, когда тебе нужно обеспечить целостность данных.\n\nА как понять, используется ли индекс в твоём запросе? Тут на помощь приходит команда EXPLAIN. Ты просто добавляешь её перед своим запросом, и база данных показывает, какой план выполнения она собирается использовать. Если там есть упоминание об индексе — значит, он используется. Если нет — то, возможно, нужно что-то подправить в запросе или в структуре базы данных.\n\n**Советы от Рика:**\n не увлекайся индексами — чем больше индексов, тем медленнее будут операции вставки и обновления;\n",
      "questions": [
        {
          "text": "Какой тип индекса подходит для точного сравнения (=) и самый быстрый?",
          "options": [
            "B-дерево",
            "Хеш-индекс",
            "Составной",
            "GIN"
          ],
          "correct": 1
        },
        {
          "text": "Что ускоряет индекс на столбце `email`?",
          "options": [
            "Запросы с WHERE email = ...",
            "Запросы с WHERE age > ...",
            "INSERT в таблицу",
            "DROP TABLE"
          ],
          "correct": 0
        },
        {
          "text": "Какой индекс гарантирует уникальность значений?",
          "options": [
            "PRIMARY KEY",
            "UNIQUE INDEX",
            "Обычный индекс",
            "Хеш-индекс"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Основные операторы SQL",
      "content": "**Рик говорит: SQL — это не просто, это космически сложно (но я разберусь, а ты — вслед за мной!)**\n\nЭй, пацан, ты думаешь, что SQL — это какая-то там магия для ботанов? Ха, да я могу объяснить тебе всё так, что даже твой домашний хомяк поймёт! Так что слушай сюда, и не перебивай, пока дед не закончит вещать.\n\nИтак, SQL-операторы — это как инструменты в моём космическом наборе для взлома вселенных. Они делятся на разные категории, и каждая из них — как отдельный гаджет в моём арсенале. Давай разберёмся, что к чему.\n\n**DQL (Data Query Language)** — это как мой сканер для поиска сокровищ. Сюда входят такие операторы, как SELECT, WHERE и JOIN. SELECT — это основа всех запросов, как базовый инструмент, без которого никуда. WHERE помогает фильтровать данные, чтобы ты не рылся в куче мусора, а получал только то, что нужно. А JOIN — это вообще крутая штука, которая позволяет объединять таблицы, как если бы ты соединял разные части пазла, чтобы увидеть полную картину.\n\n**DML (Data Manipulation Language)** — это уже более серьёзный инструмент, как мой лазерный резак. С его помощью можно изменять данные. INSERT — чтобы добавить новую информацию, UPDATE — чтобы обновить уже существующую, а DELETE — чтобы избавиться от ненужного хлама. Понял, пацан?\n\n**DDL (Data Definition Language)** — это как конструктор для создания структуры базы данных. CREATE — чтобы создать новую таблицу или базу данных, ALTER — чтобы изменить уже существующую структуру, а DROP — чтобы снести всё к чёртовой бабушке, если что-то пошло не так.\n\n**TCL (Transaction Control Language)** — это как система управления полётом моего космического корабля. COMMIT — чтобы подтвердить транзакцию, а ROLLBACK — чтобы отменить её, если вдруг что-то пошло не так. Очень удобно, когда нужно контролировать процесс и не допустить катастрофы.\n\n**DCL (Data Control Language)** — это система безопасности моего корабля. GRANT — чтобы дать права доступа к данным, а REVOKE — чтобы забрать их обратно. Понял, как это важно для защиты информации?\n\nА теперь пару крутых трюков, которые тебе точно пригодятся:\n GROUP BY — это как сортировка игрушек по цветам. Он группирует данные, чтобы ты мог видеть их в удобном формате.\n**Хэштеги:** #SQL #РикИМорти #Программирование #БазыДанных #СоветыОтРика\n\n**Советы:**\n1. Не бойся экспериментировать с SQL — ошибки помогут тебе учиться.\n2. Запоминай основные операторы и их назначение — это как выучить алфавит, без этого никуда.\n3. Используй EXPLAIN — это твой лучший друг при отладке запросов.\n4. Практикуйся как можно больше — теория без практики ничто!",
      "questions": [
        {
          "text": "К какой категории относится оператор SELECT?",
          "options": [
            "DML",
            "DDL",
            "DQL",
            "TCL"
          ],
          "correct": 2
        },
        {
          "text": "Какой оператор используется для подтверждения транзакции?",
          "options": [
            "SAVEPOINT",
            "ROLLBACK",
            "COMMIT",
            "GRANT"
          ],
          "correct": 2
        },
        {
          "text": "Какой оператор добавляет новый столбец в таблицу?",
          "options": [
            "CREATE COLUMN",
            "ADD COLUMN",
            "ALTER TABLE ... ADD COLUMN",
            "UPDATE TABLE"
          ],
          "correct": 2
        },
        {
          "text": "Что делает оператор HAVING?",
          "options": [
            "Фильтрует строки до группировки",
            "Фильтрует группы после GROUP BY",
            "Сортирует результат",
            "Ограничивает количество строк"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Итоговый тест: Базы данных (Junior)",
      "content": "**Рик говорит: «Базы данных и SQL — детский лепет, внучок!»**\n\nХа-ха, Морти, глянь-ка сюда! Ты думаешь, что эти ваши «базы данных» и SQL — это что-то сложное? Да я в своё время такие системы взламывал, что ваши базы данных просто отдыхают!\n\nТак вот, слушай сюда, Морти. SQL — это язык, который позволяет работать с базами данных. Представь себе огромную библиотеку, где каждая книга — это данные, а полки — это таблицы. SQL — это как библиотекарь, который помогает тебе быстро найти нужную книгу.\n\nА теперь давай разберёмся, что там за вопросы могут быть в твоём тесте. Во-первых, наверняка спросят про основные команды SQL: SELECT, INSERT, UPDATE, DELETE. Это как четыре основных действия, которые ты можешь совершать с данными: получать, добавлять, изменять и удалять.\n\nВо-вторых, будут вопросы про таблицы и связи между ними. Представь, что у тебя есть таблица с данными о людях и таблица с данными об их любимых блюдах. С помощью SQL ты можешь связать эти таблицы и узнать, какое блюдо любит каждый человек.\n\nВ-третьих, не забудь про условия и фильтры. В SQL ты можешь задавать условия, чтобы получать только те данные, которые тебе нужны. Например, ты можешь попросить систему показать только тех людей, которые любят пиццу.\n\nИ, наконец, не удивляйся, если в тесте будут вопросы про индексы и оптимизации. Индексы — это как оглавление в книге, они помогают быстрее находить нужные данные. А оптимизация — это когда ты делаешь так, чтобы твои запросы работали быстрее и эффективнее.\n\nТак что, Морти, не нервничай перед тестом. Просто вспомни, что SQL — это всего лишь инструмент для работы с данными, и ничего сложного в нём нет. Главное — понимать основные принципы и уметь применять их на практике.\n\n**Хэштеги:** #SQL #базыданных #тесты #Морти #Рик\n\n**Советы от Рика:**\n не бойся сложных вещей — чаще всего они проще, чем кажутся;\n всегда ищи простые решения сложных задач;\n не забывай про основы — без них ты никуда не продвинешься;\n",
      "questions": [
        {
          "text": "Какая команда НЕ может использовать WHERE?",
          "options": [
            "DELETE",
            "TRUNCATE",
            "SELECT",
            "UPDATE"
          ],
          "correct": 1
        },
        {
          "text": "Что произойдёт при выполнении DROP TABLE users?",
          "options": [
            "Удалятся только данные",
            "Таблица очистится, но останется",
            "Таблица и её структура удалятся",
            "Сработает ошибка"
          ],
          "correct": 2
        },
        {
          "text": "Для чего используется индекс?",
          "options": [
            "Ускорить поиск данных",
            "Зашифровать данные",
            "Удалить дубликаты",
            "Создать резервную копию"
          ],
          "correct": 0
        },
        {
          "text": "Какой оператор возвращает уникальные значения?",
          "options": [
            "UNIQUE",
            "DISTINCT",
            "GROUP BY",
            "HAVING"
          ],
          "correct": 1
        },
        {
          "text": "Как откатить транзакцию в SQL?",
          "options": [
            "UNDO",
            "CANCEL",
            "ROLLBACK",
            "REVERT"
          ],
          "correct": 2
        },
        {
          "text": "Какой оператор изменяет структуру существующей таблицы?",
          "options": [
            "MODIFY",
            "UPDATE",
            "ALTER",
            "CHANGE"
          ],
          "correct": 2
        },
        {
          "text": "Какой тип индекса лучше всего подходит для поиска по диапазону (например, price > 100)?",
          "options": [
            "Хеш-индекс",
            "B-дерево",
            "GIN",
            "Уникальный"
          ],
          "correct": 1
        },
        {
          "text": "Что делает команда TRUNCATE TABLE?",
          "options": [
            "Удаляет таблицу",
            "Удаляет все строки быстро",
            "Удаляет строки с WHERE",
            "Создаёт копию таблицы"
          ],
          "correct": 1
        },
        {
          "text": "Какой оператор используется для объединения таблиц?",
          "options": [
            "MERGE",
            "COMBINE",
            "JOIN",
            "UNION"
          ],
          "correct": 2
        },
        {
          "text": "Как ограничить количество результатов в PostgreSQL?",
          "options": [
            "TOP",
            "LIMIT",
            "MAX",
            "FETCH"
          ],
          "correct": 1
        }
      ]
    }
  ],
  "ansible": [
    {
      "title": "Что такое Ansible и как он работает",
      "content": "**Рик говорит: «Ansible? Пф, детская игрушка!»**\n\nСлушай сюда, пацан, я, Рик, тебе сейчас объясню, что такое Ansible. Только не вздумай засыпать — тема серьёзная!\n\nИтак, Ansible — это такой инструмент, который помогает автоматизировать всю эту муть с инфраструктурой. Ну, знаешь, когда тебе надо настроить кучу серверов, а ты не хочешь бегать и делать всё вручную. Вместо этого ты просто говоришь: «Эй, Ansible, сделай вот это и вот это!» — и он всё делает за тебя. Круто, да?\n\nГлавное, что нужно запомнить про Ansible:\n Он работает без всяких там агентов на серверах (agentless-архитектура). То есть он подключается к серверам через SSH (для линукса) или WinRM (для винды) и делает своё дело. Никаких лишних программ ставить не надо — всё просто и удобно.\n Идемпотентность — это значит, что если ты запустишь скрипт два раза, система не сломается. Представь, что ты говоришь роботу: «Поставь чашку на стол». Он ставит. А если ты скажешь ещё раз — он просто проверит, что чашка уже на столе, и ничего не поменяет. Вот так и тут — повторный запуск не испортит то, что уже сделано.\n Декларативный подход — это когда ты описываешь, какое состояние системы ты хочешь получить в итоге, а не как его достичь. То есть ты говоришь: «Я хочу, чтобы на сервере был установлен Nginx и работал на порту 80», — а Ansible сам разбирается, как это сделать.\n\nТеперь разберём основные компоненты Ansible:\n Inventory — это просто список хостов (серверов), с которыми ты будешь работать. Ты пишешь в нём, какие сервера у тебя есть, и Ansible знает, куда ему нужно подключиться.\n Playbook — это сценарий, который ты пишешь на языке YAML. Там ты описываешь, что и как нужно сделать на серверах. Можно сказать, что это «план действий» для Ansible.\n**Хэштеги:** #Ansible #Автоматизация #IaC #РикЗнаетВсё\n\n**Советы от Рика:**\n1. Не бойся экспериментировать с Ansible — он довольно прост в использовании, если разобраться.\n2. Храни свои плейбуки в системе контроля версий — так ты сможешь отслеживать изменения и не потеряешь важные настройки.\n3. Используй роли для повторного использования кода — это сэкономит тебе кучу времени в будущем.\n4. И помни: если что-то пошло не так, просто скажи: «Портальная пушка, активируйся!» — и все проблемы решатся сами собой. Ха-ха!",
      "questions": [
        {
          "text": "Какая архитектура у Ansible?",
          "options": [
            "Требует агентов на хостах",
            "Агентless (работает через SSH/WinRM)",
            "Использует открытые порты кроме SSH",
            "Только для Linux"
          ],
          "correct": 1
        },
        {
          "text": "Что означает идемпотентность в Ansible?",
          "options": [
            "Задача выполняется быстрее при повторном запуске",
            "Повторный запуск не меняет систему, если она уже в нужном состоянии",
            "Задача всегда ломает систему",
            "Требует перезагрузки сервера"
          ],
          "correct": 1
        },
        {
          "text": "Как Ansible подключается к Linux-хостам?",
          "options": [
            "Через специальный агент",
            "Через SSH",
            "Через HTTP API",
            "Через Telnet"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Playbook и Inventory в Ansible",
      "content": "**Рик говорит: «О, внучок, давай-ка я тебе объясню, что такое Playbook и Inventory — раз плюнуть, честное слово!»****hosts****become (sudo)****tasks** — это сами задачи, которые мы хотим выполнить. Здесь мы указываем, какие модули нужно вызвать, чтобы выполнить нужную работу.\n\nА теперь про Inventory. Это такой файл, где перечислены все хосты (компьютеры или серверы) и их параметры. Можно представить это как адресную книгу, где у каждого хоста есть свои «координаты»: IP-адрес, порт, имя пользователя и так далее. Inventory может быть в формате INI или YAML — это просто разные способы записи данных.\n\nНапример, в Inventory можно записать так:\n```\n[webservers]\n10.0.0.1\n```\nЭто значит, что у нас есть группа серверов (webservers), и один из них имеет IP-адрес 10.0.0.1.\n\nА теперь давай посмотрим на пример Playbook. Представим, что мы хотим установить Nginx (это такой веб-сервер) и запустить его. В Playbook мы можем написать что-то вроде: «Используй apt (это менеджер пакетов в Linux) для установки Nginx, а потом запусти службу через service».\n\nЧтобы запустить Playbook, нужно использовать команду:\n```\nansible-playbook -i inventory playbook.yml\n```\nЗдесь `-i inventory` означает, что мы указываем файл Inventory, а `playbook.yml` — это наш файл с Playbook.\n\n**Вот несколько советов от дедушки Рика:**\n не бойся экспериментировать — иногда самые крутые штуки получаются именно тогда, когда ты делаешь что-то новое и необычное;\n",
      "questions": [
        {
          "text": "Какой формат файла используется для Playbook?",
          "options": [
            "JSON",
            "XML",
            "YAML",
            "INI"
          ],
          "correct": 2
        },
        {
          "text": "Как указать нестандартный SSH-порт для хоста в inventory?",
          "options": [
            "10.0.0.1:2222",
            "10.0.0.1 port=2222",
            "10.0.0.1 ansible_port=2222",
            "Нельзя указать"
          ],
          "correct": 2
        },
        {
          "text": "Какая команда запускает playbook?",
          "options": [
            "ansible run playbook.yml",
            "ansible-playbook playbook.yml",
            "ansible execute playbook.yml",
            "playbook run"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Роли (Roles) в Ansible",
      "content": "**Рик говорит: «О, малыш, давай я объясню тебе про эти ваши роли в Ansible, только не скучай, а то я могу и телепортироваться куда подальше!»****Так что, малыш, используй роли в Ansible — и твоя жизнь станет намного проще! #Ansible #роли #автоматизация #IT #РикИМорти**\n\n**Совет:** не бойся экспериментировать с ролями — они реально упрощают жизнь. И помни, что хороший админ всегда держит свои скрипты в порядке! А то знаешь, как бывает — запутаешься в своих файлах, и потом ищи-свищи, где что лежит. И да, не забывай делать бэкапы — даже у Рика бывают осечки!",
      "questions": [
        {
          "text": "Где хранятся шаблоны конфигов в роли?",
          "options": [
            "files/",
            "templates/",
            "vars/",
            "handlers/"
          ],
          "correct": 1
        },
        {
          "text": "Какая папка содержит переменные по умолчанию (низкий приоритет)?",
          "options": [
            "vars/",
            "defaults/",
            "meta/",
            "tasks/"
          ],
          "correct": 1
        },
        {
          "text": "Как подключить роль в playbook?",
          "options": [
            "import_role: nginx",
            "include: roles/nginx",
            "roles: - nginx",
            "call nginx_role"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Продвинутые возможности: Handlers, Tags, Ansible vs Terraform",
      "content": "**Рик говорит: про Ansible, Terraform и всё такое**\n\nСлушай сюда, малыш, сейчас дед объяснит тебе пару вещей про эту вашу IT-херню. Ну, типа, про Ansible, Terraform и всё такое. Запомни, я знаю об этом больше, чем ты можешь себе представить!\n\nИтак, начнём с Handlers. Это такие задачи, которые не будут просто так работать, понимаешь? Они запускаются только тогда, когда получают уведомление (notify) и только если что-то реально изменилось. Например, если ты обновил конфиг nginx, то Handlers могут перезапустить его. Это как если бы ты сказал своему роботу-помощнику: «Эй, проверь, если там что-то поменялось, тогда сделай вот это». Удобно, да?\n\nА ещё есть эта штука — Tags. С её помощью можно запускать только определённые задачи, а не всё подряд. Например, если тебе нужно только установить что-то, ты можешь использовать команду типа `--tags 'install'`. Это как если бы ты сказал: «Робот, делай только то, что связано с установкой, а остальное оставь в покое».\n\nТеперь про Ansible и Terraform. Это две разные штуки, которые используются для разных целей. Ansible — это для управления конфигурацией уже существующих серверов. Он работает по push-модели, то есть ты сам отправляешь команды на серверы. Представь, что ты даёшь инструкции своим роботам-помощникам, и они выполняют их на местах.\n\nTerraform же используется для создания и удаления облачной инфраструктуры. Это такая штука, которая помогает тебе управлять всей этой облачной мутью. Terraform — это Infrastructure as Code (IaC), то есть ты описываешь свою инфраструктуру в коде, и она автоматически создаётся или удаляется. Это как если бы ты мог нарисовать план своего дома, и он бы сам строился или разрушался по твоему желанию.\n\nAnsible — это такая штука, которая ещё и идемпотентная. Это значит, что если ты запустишь одну и ту же команду несколько раз, результат будет один и тот же. Удобно, когда не хочешь случайно накосячить. К тому же Ansible не требует установки каких-то дополнительных агентов на сервера — он просто использует модули и плагины. Это как если бы ты мог управлять своими роботами-помощниками без необходимости устанавливать на них какое-то дополнительное ПО.\n\n**Хэштеги:** #Ansible #Terraform #IT #Infrastructure #ConfigurationManagement\n\n**Советы от Рика:**\n1. Не бойся сложных вещей — зачастую они проще, чем кажутся.\n2. Всегда используй теги, если нужно управлять задачами выборочно — это сэкономит тебе кучу времени.\n3. Понимание различий между инструментами (например, Ansible и Terraform) поможет тебе выбрать правильный инструмент для конкретной задачи.\n4. И помни, малыш, в IT, как и во всём остальном, главное — не бояться экспериментировать и учиться на своих ошибках!",
      "questions": [
        {
          "text": "Когда выполняется handler?",
          "options": [
            "После каждой задачи",
            "Только если задача изменила состояние и вызвала notify",
            "Перед всеми задачами",
            "Никогда"
          ],
          "correct": 1
        },
        {
          "text": "Чем Ansible отличается от Terraform?",
          "options": [
            "Ansible создаёт инфраструктуру, Terraform настраивает её",
            "Ansible управляет конфигурацией серверов, Terraform — управляет облачными ресурсами",
            "Terraform работает через SSH, Ansible — через API",
            "Нет разницы"
          ],
          "correct": 1
        },
        {
          "text": "Как запустить только задачи с тегом 'deploy'?",
          "options": [
            "--tag deploy",
            "--tags 'deploy'",
            "-t deploy",
            "Все варианты верны"
          ],
          "correct": 3
        },
        {
          "text": "Где работают модули Ansible?",
          "options": [
            "На управляющей машине",
            "На целевых хостах",
            "В облаке",
            "В Docker-контейнере"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Итоговый тест: Ansible (Junior)",
      "content": "**Рик говорит: «Финальный тест по модулю Ansible? Пф, раз плюнуть!»**\n\nСлушай сюда, малыш, я тебе щас объясню, что такое этот ваш Ansible и как проходить тесты по нему. Я, конечно, не особо люблю всю эту земную технохрень, но пару вещей знаю — уж поверь старику.\n\nAnsible — это такая штука, которая помогает автоматизировать задачи на серверах. Ну, типа, ты пишешь скрипты, а они сами всё делают: устанавливают софт, настраивают конфиги, обновляют системы и всё такое. Удобно, если у тебя куча серверов — не надо сидеть и вручную всё делать.\n\nТак вот, твой финальный тест — это проверка того, насколько хорошо ты въехал в эту тему. 15 вопросов — это, считай, разминка для мозга. Там будут спрашивать про основные понятия, синтаксис, модули, плейбуки и, может, ещё какую-нибудь ерунду.\n\nЧтобы пройти тест без проблем, вот что тебе надо знать:\n как работает Ansible, в чём его фишка по сравнению с другими системами автоматизации;\n основные компоненты: что такое инвентори, плейбуки, задачи, модули и так далее;\n как писать простые плейбуки и выполнять их;\n",
      "questions": [
        {
          "text": "Какая команда проверяет подключение к хостам?",
          "options": [
            "ansible all -m ping",
            "ansible ping all",
            "ansible test all",
            "ping all"
          ],
          "correct": 0
        },
        {
          "text": "Что такое inventory в Ansible?",
          "options": [
            "Файл с задачами",
            "Список управляемых хостов",
            "Шаблон конфигурации",
            "Результат выполнения"
          ],
          "correct": 1
        },
        {
          "text": "Какой модуль используется для установки пакетов в Ubuntu?",
          "options": [
            "yum",
            "apt",
            "package",
            "install"
          ],
          "correct": 1
        },
        {
          "text": "Какой файл в роли содержит основные задачи?",
          "options": [
            "tasks/main.yml",
            "handlers/main.yml",
            "vars/main.yml",
            "defaults/main.yml"
          ],
          "correct": 0
        },
        {
          "text": "Что делает параметр become: yes в playbook?",
          "options": [
            "Подключается под другим пользователем",
            "Выполняет задачи с правами sudo",
            "Пропускает задачу",
            "Логирует выполнение"
          ],
          "correct": 1
        },
        {
          "text": "Какой формат inventory поддерживает вложенные группы?",
          "options": [
            "Только INI",
            "Только YAML",
            "Оба формата",
            "Ни один"
          ],
          "correct": 2
        },
        {
          "text": "Что такое facts в Ansible?",
          "options": [
            "Переменные, заданные пользователем",
            "Автоматически собранные данные о хостах",
            "Шаблоны Jinja2",
            "Результаты тестов"
          ],
          "correct": 1
        },
        {
          "text": "Какой плагин отвечает за подключение к хостам?",
          "options": [
            "callback",
            "lookup",
            "connection",
            "inventory"
          ],
          "correct": 2
        },
        {
          "text": "Где хранятся статические файлы для копирования в роли?",
          "options": [
            "templates/",
            "files/",
            "vars/",
            "meta/"
          ],
          "correct": 1
        },
        {
          "text": "Что произойдёт, если задача не изменила состояние, но вызвала notify?",
          "options": [
            "Handler выполнится",
            "Handler не выполнится",
            "Playbook завершится с ошибкой",
            "Ansible перезапустится"
          ],
          "correct": 1
        },
        {
          "text": "Какой модуль управляет службами (сервисами)?",
          "options": [
            "service",
            "systemd",
            "start",
            "run"
          ],
          "correct": 0
        },
        {
          "text": "Как создать новую роль?",
          "options": [
            "ansible role create my_role",
            "ansible-galaxy init my_role",
            "mkdir roles/my_role",
            "Все способы верны"
          ],
          "correct": 1
        },
        {
          "text": "Какой параметр inventory задаёт пользователя для SSH?",
          "options": [
            "user",
            "ssh_user",
            "ansible_user",
            "login"
          ],
          "correct": 2
        },
        {
          "text": "Что такое плагины в Ansible?",
          "options": [
            "Замена модулей",
            "Расширение функциональности на управляющей машине",
            "Агенты на хостах",
            "Графический интерфейс"
          ],
          "correct": 1
        },
        {
          "text": "Какой принцип позволяет запускать playbook много раз без вреда?",
          "options": [
            "Idempotency",
            "Agentless",
            "Declarative",
            "Modular"
          ],
          "correct": 0
        }
      ]
    }
  ],
  "docker": [
    {
      "title": "Контейнеризация vs Виртуализация",
      "content": "**Рик говорит: виртуализация против контейнеризации — разберёмся, не вставая с кресла!**\n\nЭй, пацаны, слушайте сюда! Сегодня я вам объясню, в чём разница между виртуализацией и контейнеризацией. Не думайте, что это какая-то там муть для ботаников — это реально крутые штуки, которые могут пригодиться даже такому гению, как я!\n\nИтак, начнём с виртуализации. Это такая штука, которая позволяет запускать несколько операционных систем на одном железе. Как это работает? Есть такая программа — гипервизор. Она эмулирует аппаратное обеспечение, то есть создаёт виртуальные машины (VM), на которых можно запускать разные ОС. Звучит круто, да? Но есть и минусы: это довольно ресурсоёмко, потому что каждая виртуальная машина тянет за собой целую операционную систему. Зато безопасность на высоте — каждая VM полностью изолирована от других.\n\nА теперь поговорим о контейнеризации. Тут всё попроще и побыстрее. Самый популярный инструмент для работы с контейнерами — Docker. Контейнеризация не создаёт полные виртуальные машины, а просто делит ядро хостовой операционной системы на изолированные «комнатки» с помощью namespaces и cgroups. Namespaces отвечают за изоляцию процессов, сети и файловой системы, а cgroups ограничивают ресурсы, которые контейнер может использовать.\n\nВ чём кайф контейнеров? Они запускаются за миллисекунды и потребляют минимум ресурсов. Представляете, насколько это удобно? Если вам нужно запустить микросервис — контейнер будет идеальным выбором. Но есть и недостаток: изоляция не такая сильная, как в случае с виртуальными машинами, потому что все контейнеры делят одно ядро ОС.\n\nЧасто в облаках используют гибридный подход: запускают контейнеры внутри виртуальных машин. Это позволяет сочетать преимущества обоих методов.\n\nТак когда же использовать виртуальные машины, а когда — контейнеры? Если вам нужно запустить разные операционные системы или обеспечить полную изоляцию — выбирайте VM. А если вы занимаетесь DevOps, CI/CD или разрабатываете микросервисы — контейнеры будут более подходящим вариантом.\n\n**Хэштеги:** #виртуализация #контейнеризация #Docker #VM #микросервисы #DevOps #CI/CD\n\n**Советы от Рика:**\n не бойтесь изучать новые технологии — даже если они кажутся сложными на первый взгляд;\n",
      "questions": [
        {
          "text": "В чём ключевое отличие контейнера от виртуальной машины?",
          "options": [
            "Контейнер эмулирует железо",
            "Контейнер использует ядро хоста, VM — свою ОС",
            "VM запускается быстрее",
            "Контейнер требует гипервизор"
          ],
          "correct": 1
        },
        {
          "text": "Какая технология обеспечивает изоляцию процессов в контейнере?",
          "options": [
            "Гипервизор",
            "Namespaces",
            "cgroups",
            "VirtualBox"
          ],
          "correct": 1
        },
        {
          "text": "Какая технология ограничивает CPU/RAM для контейнера?",
          "options": [
            "Namespaces",
            "cgroups",
            "KVM",
            "Docker Hub"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Образы, слои и Copy-on-Write",
      "content": "**Рик говорит: «О, Docker-образы? Пф, раз плюнуть!»**\n\nСлушай сюда, малой, я тебе объясню, что такое Docker-образ. Это, по сути, шаблон для контейнера — неизменяемый, чёткий, как мои гениальные планы по захвату галактики. Он состоит из слоёв, представляешь? Каждый слой — это как страница в книге, только вместо текста там инструкции.\n\nВот, например, есть такой файл — Dockerfile. В нём ты пишешь команды, типа FROM, RUN, COPY. И каждая из этих команд создаёт новый слой в образе. Понял? FROM — это как основа, RUN — это когда ты что-то запускаешь и устанавливаешь, а COPY — когда копируешь файлы.\n\nА знаешь, что круто? Эти слои кэшируются! То есть, если ты что-то поменял в Dockerfile, то пересобираются только текущий слой и те, что идут после него. Представляешь, какая экономия времени и ресурсов? Это как если бы я, меняя план по захвату планеты, не начинал всё с нуля, а просто корректировал уже готовые части.\n\nА когда ты запускаешь контейнер, поверх этих слоёв создаётся записываемый слой — Copy-on-Write. Всё, что ты меняешь в контейнере, сохраняется только в этом слое. Это как если бы ты взял мою суперсекретную тетрадь с планами и сделал в ней заметки на отдельном листе — оригинал остаётся нетронутым. Благодаря этому можно экономить место и ускорять сборку.\n\nХочешь посмотреть, из каких слоёв состоит твой образ? Легко! Просто введи команду `docker history <image>`, и тебе выведет всю историю слоёв.\n\nА чтобы оптимизировать работу с Docker, вот несколько советов от дедушки Рика:\n объединяй команды RUN — чем меньше слоёв, тем быстрее сборка;\n**Совет от Рика:** не бойся сложных вещей — разбивай их на простые части, и всё получится! И помни: если что-то не работает, возможно, тебе просто нужно добавить немного межгалактической магии.",
      "questions": [
        {
          "text": "Что такое слой (layer) в Docker?",
          "options": [
            "Отдельный контейнер",
            "Неизменяемый компонент образа, созданный инструкцией Dockerfile",
            "Тип сети",
            "Файл логов"
          ],
          "correct": 1
        },
        {
          "text": "Как работает Copy-on-Write в контейнере?",
          "options": [
            "Копирует весь образ при запуске",
            "При изменении файла создаёт копию в записываемом слое",
            "Запрещает изменение файлов",
            "Работает только в VM"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой посмотреть слои образа?",
          "options": [
            "docker layers",
            "docker history",
            "docker inspect",
            "docker images"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Dockerfile: инструкции, CMD vs ENTRYPOINT, оптимизация",
      "content": "**Рик говорит: «Dockerfile? Пф, раз плюнуть!»**\n\nСлушай сюда, малой, я тебе объясню, что такое Dockerfile. Это, считай, рецепт для приготовления твоего приложения в специальном «контейнере». Ну, типа как если бы ты готовил космический корабль в игрушечной лаборатории — всё чётко, по шагам.\n\nИтак, начнём с основ. В Dockerfile есть несколько ключевых команд, которые ты должен знать:\n\n1. **FROM** — это как выбор основы для твоего рецепта. Ты указываешь базовый образ, на котором будет строиться всё остальное. Например, если ты хочешь сделать приложение на Python, ты можешь выбрать образ с уже установленным Python.\n\n2. **RUN** — это команды, которые выполняются при сборке образа. Представь, что ты даёшь роботу список заданий: установить какие-то программы, настроить что-то, скачать файлы. Всё это делается с помощью RUN.\n\n3. **COPY** и **ADD** — это для копирования файлов в образ. COPY проще и понятнее, так что лучше использовать его. Это как если бы ты перекладывал ингредиенты из пакета в кастрюлю.\n\n4. **WORKDIR** — устанавливает рабочую директорию в образе. То есть ты говоришь: «Все дальнейшие действия выполняй в этой папке». Это как выбрать рабочую зону в лаборатории.\n\n5. **CMD** и **ENTRYPOINT** — это команды для запуска приложения. ENTRYPOINT — это основная команда, которая запускается при старте контейнера. Её сложно переопределить, если не использовать специальный флаг. А CMD — это аргументы по умолчанию, которые можно переопределить при запуске контейнера. Представь, что ENTRYPOINT — это кнопка «Старт», а CMD — дополнительные настройки, которые можно поменять.\n\nТеперь про многоэтапную сборку (multi-stage). Это крутая штука, которая помогает уменьшить размер итогового образа. Ты можешь собрать всё в одном образе, а потом скопировать только нужные файлы в другой, более минималистичный образ. Это как если бы ты сначала приготовил сложное блюдо, а потом переложил только готовую еду в контейнер для ланча, оставив все лишние ингредиенты.\n\nА ещё есть несколько советов по оптимизации:\n* Используй образы с суффиксом -slim. Это как облегчённые версии программ — они занимают меньше места.\n* Удаляй кэш после установки пакетов. Например, можно выполнить команду `rm -rf /var/lib/apt/lists/*`. Это как убрать мусор после готовки — место освободится.\n* Избегай использования тега latest при выборе образа. Лучше указывать конкретную версию, чтобы избежать неожиданных изменений. Это как выбирать определённую модель космического корабля, а не брать «последнюю версию», которая может оказаться с багами.\n\n**Хэштеги:** #Docker #Dockerfile #контейнеры #разработка #оптимизация\n\n**Советы от Рика:**\n* Не усложняй — чем проще твой Dockerfile, тем легче будет отладить и понять его.\n* Используй многоэтапную сборку — это реально помогает уменьшить размер образов.\n* Тестируй образы после каждой правки — так ты сможешь быстро найти и исправить ошибки.\n* Не забывай про безопасность — избегай лишних зависимостей и удаляй ненужные файлы.",
      "questions": [
        {
          "text": "В чём разница между CMD и ENTRYPOINT?",
          "options": [
            "CMD нельзя переопределить, ENTRYPOINT — можно",
            "ENTRYPOINT задаёт основную команду, CMD — аргументы по умолчанию",
            "ENTRYPOINT работает только в multi-stage",
            "Нет разницы"
          ],
          "correct": 1
        },
        {
          "text": "Зачем нужна многоэтапная сборка?",
          "options": [
            "Для запуска нескольких контейнеров",
            "Для уменьшения размера финального образа",
            "Для ускорения загрузки Docker Hub",
            "Для совместимости с Kubernetes"
          ],
          "correct": 1
        },
        {
          "text": "Почему не рекомендуется использовать образы с тегом latest?",
          "options": [
            "Они самые большие",
            "Они нестабильны и нарушают воспроизводимость",
            "Они не содержат Python",
            "Они платные"
          ],
          "correct": 1
        },
        {
          "text": "Какая инструкция предпочтительнее для копирования файлов?",
          "options": [
            "ADD",
            "COPY",
            "RUN cp",
            "WORKDIR"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Сети, тома и Docker Compose",
      "content": "**Рик говорит: «Docker — это вам не шутки, пацан»****bridge****host****none****named volumes****bind mounts** — тут ты привязываешь директорию хоста. То есть говоришь Docker: «Слушай, дружище, используй эту папку на хосте для хранения данных». Удобно, когда нужно работать с файлами на хосте.\n\nА ещё есть Docker Compose — это инструмент для запуска мультиконтейнерных приложений. Ты пишешь YAML-файл (docker-compose.yml), и Compose сам всё запустит. Основные команды, которые тебе понадобятся:\n `docker-compose up` — запускает приложения;\n**Советы от Рика:**\n1. Не бойся экспериментировать с Docker — чем больше ты будешь пробовать, тем лучше поймёшь, как всё работает.\n2. Используй Docker Compose для сложных проектов — это сильно упростит тебе жизнь.\n3. Внимательно читай документацию — там много полезной инфы, которая может сэкономить тебе время.\n\n#Docker #контейнеры #РикИМорти #IT #разработка #DevOps\n\nНу что, пацан, теперь ты знаешь про Docker побольше, чем раньше. Если что — обращайся, я всегда готов помочь!",
      "questions": [
        {
          "text": "В чём разница между bridge и host сетями?",
          "options": [
            "bridge — сеть хоста, host — изолированная",
            "bridge — изолированная (по умолчанию), host — сеть хоста",
            "host работает только в VM",
            "bridge медленнее host всегда"
          ],
          "correct": 1
        },
        {
          "text": "Когда использовать named volumes вместо bind mounts?",
          "options": [
            "Когда нужно привязать директорию хоста",
            "Когда данные должны управляться Docker (переносимость)",
            "Bind mounts безопаснее",
            "Named volumes не работают в Compose"
          ],
          "correct": 1
        },
        {
          "text": "Какая команда запускает приложение через Docker Compose?",
          "options": [
            "docker run compose",
            "docker-compose up",
            "docker compose start",
            "compose run"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Безопасность и лучшие практики",
      "content": "**Рик говорит о безопасности Docker: слушай сюда, пацанва!**\n\nЭй, пацаны, Рик тут, и я вам расскажу, как держать Docker в ежовых рукавицах. Ну, знаете, когда ты работаешь с контейнерами, нужно быть начеку, а то мало ли что может случиться. Так что слушайте сюда, и запоминайте — эти советы спасут вам жизнь (и серверы тоже)!\n\nПервое, что вам нужно знать — запускать контейнеры лучше от непривилегированного пользователя. Это как если бы вы дали кому-то пульт от телевизора, но без возможности менять настройки — можно смотреть, но не ломать. В Dockerfile для этого есть команда `USER`. Запихнули её — и уже стало спокойнее.\n\nДальше — никогда не используйте флаг `--privileged`, если только вы реально не знаете, что делаете. Это как дать кому-то ключи от вашего дома и сказать: «Делай что хочешь». Не надо так, пацаны, это опасно!\n\nИспользуйте минимальные образы — например, те, что с суффиксами `-slim` или `-alpine`. Это как если бы вы взяли не целый грузовик с инструментами, а только рюкзак с самым необходимым. Меньше места, меньше уязвимостей — всё чётко!\n\nСканируйте уязвимости с помощью trivy. Это как регулярный медосмотр — лучше узнать о проблемах заранее, чем потом разбираться с последствиями. Запустили сканер, нашли слабые места — поправили. Всё просто!\n\nСекреты (пароли, ключи и всё такое) не храните в образе. Используйте `docker secrets` или переменные окружения при запуске. Это как если бы вы не писали пин-код от карты на самой карте, а держали его в голове (или в надёжном месте).\n\nТеперь про лучшие практики:\n Всегда указывайте конкретную версию образа, а не `latest`. Это как если бы вы говорили: «Мне нужна именно эта модель телефона, а не какая-то новая, о которой я ничего не знаю».\n Используйте `.dockerignore` — это как если бы вы перед поездкой составили список того, что брать с собой не будете. Меньше мусора — быстрее сборка.\n Объединяйте `RUN`-команды — это как если бы вы делали несколько дел сразу, а не по очереди. Эффективнее и быстрее.\n**Хэштеги:** #Docker #Безопасность #Контейнеры #РикЗнаетВсё\n\n**Советы от Рика:**\n1. Не доверяйте никому (даже Docker-образам)!\n2. Всегда думайте наперёд — что может пойти не так?\n3. Используйте только то, что вам действительно нужно — меньше значит больше!\n4. Регулярно проверяйте свои системы на уязвимости — лучше предупредить проблему, чем потом её решать.\n5. Не бойтесь экспериментировать, но всегда имейте план «Б»!",
      "questions": [
        {
          "text": "Как запустить контейнер от непривилегированного пользователя?",
          "options": [
            "Использовать sudo внутри контейнера",
            "Добавить USER nobody в Dockerfile",
            "Запустить с --privileged",
            "Это невозможно"
          ],
          "correct": 1
        },
        {
          "text": "Почему не стоит хранить секреты (пароли, ключи) в Dockerfile?",
          "options": [
            "Они видны в истории слоёв образа",
            "Dockerfile не поддерживает секреты",
            "Секреты замедляют сборку",
            "Они автоматически удаляются"
          ],
          "correct": 0
        },
        {
          "text": "Какой флаг делает ФС контейнера доступной только для чтения?",
          "options": [
            "--read-only",
            "--no-write",
            "--secure",
            "--readonly"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Диагностика проблем в Docker",
      "content": "**Рик говорит: «Докер? Пф, раз плюнуть!»**\n\nСлушай сюда, пацан, я, Рик, тебе щас объясню, как разобраться с этим вашим Докером. Ты говоришь, контейнер запущен, а приложение недоступно? Ха, я такое видал миллион раз! Давай-ка разберёмся, что тут у нас.\n\nПервым делом проверь логи контейнера. Для этого используй команду `docker logs <container>`. Логи — это такая штука, где записываются все сообщения и ошибки, которые выдаёт приложение. Если там есть какие-то ошибки, то сразу будет понятно, в чём проблема.\n\nДалее можешь зайти прямо в контейнер, чтобы посмотреть, что там творится. Для этого используй команду `docker exec -it <container> sh`. Когда зайдёшь, можешь покопаться в файлах, проверить настройки — в общем, всё, что душе угодно.\n\nПотом глянь, какие порты проброшены. Для этого есть команда `docker port <container>`. Порты — это такие «двери», через которые приложение общается с внешним миром. Если порт не проброшен, то приложение будет недоступно извне.\n\nЕщё можешь посмотреть детали контейнера с помощью команды `docker inspect <container>`. Там будет куча информации, но ты можешь найти что-то полезное, например, настройки сети или объёмы (volumes).\n\nЕсли у тебя проблемы с сетью между контейнерами, то проверь, находятся ли они в одной пользовательской сети. Если нет, то они просто не смогут «увидеть» друг друга.\n\nЕсли контейнер жрёт слишком много памяти, то ограничь её с помощью параметра `--memory=512m` (или сколько тебе нужно). А чтобы следить за использованием ресурсов, используй команду `docker stats`. Она покажет, сколько памяти и CPU потребляет контейнер.\n\nЕсли у тебя ошибки сборки, то смотри вывод шага сборки. Проверяй пути в команде COPY, убеждайся, что файлы не игнорируются через .dockerignore. Часто бывает, что какой-то файл просто не включается в образ из-за этой штуки.\n\nА ещё есть несколько частых ошибок, на которые стоит обратить внимание:\n порт уже занят другим приложением;\n**Хэштеги:** #Докер #Контейнеры #РикЗнаетВсё #ПрограммированиеБезГоловнойБоли\n\n**Советы от Рика:**\n1. Не паникуй, если что-то не работает. Просто следуй этим шагам, и ты найдёшь проблему.\n2. Запоминай команды, они тебе ещё не раз пригодятся.\n3. Не стесняйся копаться в настройках и логах — иногда решение лежит на поверхности.\n4. И помни: если что-то кажется сложным, просто скажи себе: «Рик бы справился!» — и у тебя всё получится!",
      "questions": [
        {
          "text": "Как посмотреть логи контейнера?",
          "options": [
            "docker log",
            "docker logs",
            "docker inspect --logs",
            "journalctl -u docker"
          ],
          "correct": 1
        },
        {
          "text": "Почему приложение в контейнере может быть недоступно извне, даже если порт проброшен?",
          "options": [
            "Приложение слушает только 127.0.0.1, а не 0.0.0.0",
            "Docker не поддерживает TCP",
            "Нужен перезапуск хоста",
            "Порт должен быть выше 10000"
          ],
          "correct": 0
        },
        {
          "text": "Какой командой зайти в запущенный контейнер?",
          "options": [
            "docker attach",
            "docker exec -it",
            "docker shell",
            "docker run --inside"
          ],
          "correct": 1
        },
        {
          "text": "Как ограничить память контейнера?",
          "options": [
            "--ram=512m",
            "--memory=512m",
            "--mem-limit=512m",
            "Docker не позволяет ограничить память"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Итоговый тест: Docker (Junior)",
      "content": "**Рик говорит: «Финальный тест по Docker? Пф, раз плюнуть!»****архитектура Docker****образы****Dockerfile****сети****тома****безопасность****диагностика** — если что-то пошло не так, ты должен уметь быстро найти и устранить проблему. Диагностика — это как медицинский сканер для твоего космического корабля.\n\nТак что, малой, если хочешь пройти этот тест, тебе придётся хорошенько потрудиться. Но если ты освоишь Docker, то сможешь творить настоящие чудеса — создавать целые миры в виде контейнеров и управлять ими как настоящий повелитель вселенной!\n\n#Docker #контейнеры #тестирование #IT #программирование\n\n**Совет от Рика:** не пытайся выучить всё за один день — это как пытаться освоить управление звездолётом за час. Разбивай материал на части и изучай постепенно, и тогда ты сможешь покорить эту вселенную Docker! И не забывай практиковаться — теория без практики всё равно что космический корабль без топлива.",
      "questions": [
        {
          "text": "Что такое Docker?",
          "options": [
            "Гипервизор для VM",
            "Платформа контейнеризации на основе ядра Linux",
            "Менеджер пакетов",
            "Сетевой протокол"
          ],
          "correct": 1
        },
        {
          "text": "В чём разница между образом и контейнером?",
          "options": [
            "Образ — запущенный экземпляр, контейнер — шаблон",
            "Контейнер — запущенный экземпляр образа",
            "Нет разницы",
            "Образ хранится в облаке, контейнер — локально"
          ],
          "correct": 1
        },
        {
          "text": "Какая инструкция в Dockerfile задаёт базовый образ?",
          "options": [
            "BASE",
            "IMAGE",
            "FROM",
            "COPY"
          ],
          "correct": 2
        },
        {
          "text": "Что делает инструкция EXPOSE в Dockerfile?",
          "options": [
            "Открывает порт на хосте",
            "Указывает, какие порты использует приложение (документация)",
            "Блокирует порт",
            "Перенаправляет трафик"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой собрать образ из Dockerfile?",
          "options": [
            "docker run",
            "docker build",
            "docker create",
            "docker compose"
          ],
          "correct": 1
        },
        {
          "text": "Что такое multi-stage build?",
          "options": [
            "Сборка образа на нескольких серверах",
            "Многоэтапная сборка для уменьшения размера финального образа",
            "Сборка с несколькими Dockerfile",
            "Тип сети"
          ],
          "correct": 1
        },
        {
          "text": "Какой файл исключает ненужные файлы из COPY в Dockerfile?",
          "options": [
            ".gitignore",
            ".dockerignore",
            "exclude.txt",
            "Dockerfile.ignore"
          ],
          "correct": 1
        },
        {
          "text": "В чём разница между ADD и COPY?",
          "options": [
            "ADD только копирует, COPY может распаковывать",
            "COPY только копирует, ADD может распаковывать архивы и скачивать URL",
            "Нет разницы",
            "ADD работает только в Compose"
          ],
          "correct": 1
        },
        {
          "text": "Как переопределить ENTRYPOINT при запуске контейнера?",
          "options": [
            "Это невозможно",
            "Через --entrypoint",
            "Через -e",
            "Через docker update"
          ],
          "correct": 1
        },
        {
          "text": "Какой тип сети Docker используется по умолчанию?",
          "options": [
            "host",
            "none",
            "bridge",
            "overlay"
          ],
          "correct": 2
        },
        {
          "text": "Что такое bind mount?",
          "options": [
            "Том, управляемый Docker",
            "Привязка директории хоста в контейнер",
            "Тип сети",
            "Метод шифрования"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой остановить контейнер грациозно?",
          "options": [
            "docker kill",
            "docker stop",
            "docker pause",
            "docker rm"
          ],
          "correct": 1
        },
        {
          "text": "Что делает docker pause?",
          "options": [
            "Полностью останавливает контейнер",
            "Замораживает процессы, сохраняя состояние в памяти",
            "Удаляет контейнер",
            "Перезапускает контейнер"
          ],
          "correct": 1
        },
        {
          "text": "Какой флаг ограничивает CPU до 0.5 ядра?",
          "options": [
            "--cpus=0.5",
            "--cpu=0.5",
            "--cores=0.5",
            "--cpu-limit=0.5"
          ],
          "correct": 0
        },
        {
          "text": "Почему важно запускать контейнер от непривилегированного пользователя?",
          "options": [
            "Для ускорения работы",
            "Для безопасности (ограничение привилегий)",
            "Для совместимости с Windows",
            "Это требование Docker Hub"
          ],
          "correct": 1
        },
        {
          "text": "Как посмотреть использование ресурсов контейнерами?",
          "options": [
            "docker top",
            "docker stats",
            "docker ps -a",
            "docker info"
          ],
          "correct": 1
        },
        {
          "text": "Что такое Docker Compose?",
          "options": [
            "Инструмент для оркестрации кластеров",
            "Инструмент для запуска мультконтейнерных приложений из YAML",
            "Замена Docker",
            "Тип тома"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой увидеть список запущенных контейнеров?",
          "options": [
            "docker list",
            "docker ps",
            "docker containers",
            "docker show"
          ],
          "correct": 1
        },
        {
          "text": "Что делать, если сборка Dockerfile падает на шаге COPY?",
          "options": [
            "Переустановить Docker",
            "Проверить, существуют ли файлы и не исключены ли они в .dockerignore",
            "Использовать ADD вместо COPY",
            "Запустить с --force"
          ],
          "correct": 1
        },
        {
          "text": "Какой инструмент используется для сканирования уязвимостей в образах?",
          "options": [
            "docker scan",
            "trivy",
            "clair",
            "Все вышеперечисленные"
          ],
          "correct": 3
        },
        {
          "text": "Что такое cgroups в контексте Docker?",
          "options": [
            "Технология изоляции файловой системы",
            "Технология ограничения ресурсов (CPU, RAM)",
            "Тип сети",
            "Метод аутентификации"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой удалить неиспользуемые образы и тома?",
          "options": [
            "docker system prune",
            "docker clean",
            "docker rm -all",
            "docker prune"
          ],
          "correct": 0
        },
        {
          "text": "Что такое healthcheck в Docker?",
          "options": [
            "Проверка состояния диска хоста",
            "Инструкция для периодической проверки работоспособности приложения",
            "Метод шифрования",
            "Тип логов"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой подключиться к запущенному контейнеру и выполнить команду?",
          "options": [
            "docker connect",
            "docker run --inside",
            "docker exec",
            "docker attach --command"
          ],
          "correct": 2
        },
        {
          "text": "Что произойдёт, если не указать тег образа (например, nginx вместо nginx:alpine)?",
          "options": [
            "Docker выберет случайный тег",
            "Будет использован тег latest",
            "Сборка упадёт",
            "Используется самый старый тег"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой посмотреть детали контейнера (сети, тома, переменные)?",
          "options": [
            "docker info",
            "docker describe",
            "docker inspect",
            "docker details"
          ],
          "correct": 2
        },
        {
          "text": "Что делает инструкция WORKDIR в Dockerfile?",
          "options": [
            "Устанавливает права на файлы",
            "Задаёт рабочую директорию для последующих команд",
            "Копирует файлы",
            "Создаёт пользователя"
          ],
          "correct": 1
        }
      ]
    }
  ],
  "kubernetes": [
    {
      "title": "Архитектура Kubernetes: Control Plane и Worker Nodes",
      "content": "**Рик говорит: «Kubernetes? Пф, раз плюнуть!»**\n\nСлушай сюда, малыш, я тебе объясню, что такое этот ваш Kubernetes-кластер. Только не скучай, а то знаю я вас, молодёжь, сразу в телефон уткнётесь.\n\nИтак, Kubernetes-кластер — это такая штука, которая помогает управлять контейнерами с приложениями. Представь себе огромную фабрику, где всё чётко организовано: есть руководство, которое всем рулит, и есть рабочие, которые выполняют задания. В Kubernetes всё точно так же, только вместо людей — программные компоненты.\n\nНаверху у нас Control Plane — это как руководство фабрики. Тут сидят главные шишки, которые всем управляют. В Control Plane есть несколько важных ребят:\n kube-apiserver — это центральный API, через который все общаются с кластером. Представь себе диспетчера, который принимает звонки и раздаёт задания.\n etcd — это распределённое хранилище состояния кластера. Тут хранится вся важная инфа о том, как должен выглядеть кластер и что в нём происходит. Это как огромная база данных, где записано всё-всё-всё.\n kube-scheduler — этот парень распределяет поды (так называют специальные «контейнеры» с приложениями) по рабочим узлам. Он как начальник цеха, который решает, кого куда отправить работать.\n kube-controller-manager — управляет контроллерами, которые следят за репликами, узлами и прочим. Это как главный надсмотрщик, который следит, чтобы всё работало как надо.\n\nА внизу у нас Worker Nodes — это рабочие узлы, где и происходит вся работа. На каждом Worker Node бегают свои важные персонажи:\n kubelet — агент, который запускает поды. Представь себе робота, который получает задание и запускает нужное приложение.\n**Хэштеги:** #Kubernetes #кластер #контейнеры #IT #технологии\n\n**Советы от Рика:**\n1. Не бойся сложных систем — разобравшись, ты увидишь, что всё довольно логично.\n2. Используй документацию и онлайн-ресурсы — там много полезной инфы.\n3. Практикуйся — теория без практики ни к чему не приведёт.\n4. Не стесняйся спрашивать, если что-то непонятно — в IT нет глупых вопросов, только глупые ответы.",
      "questions": [
        {
          "text": "Какой компонент Kubernetes хранит всё состояние кластера?",
          "options": [
            "kube-apiserver",
            "etcd",
            "kube-scheduler",
            "kubelet"
          ],
          "correct": 1
        },
        {
          "text": "Какой компонент запускает контейнеры на рабочем узле?",
          "options": [
            "kube-proxy",
            "kubelet",
            "kube-scheduler",
            "etcd"
          ],
          "correct": 1
        },
        {
          "text": "Через какой компонент проходят все команды kubectl?",
          "options": [
            "kube-scheduler",
            "kube-controller-manager",
            "kube-apiserver",
            "kubelet"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Основные объекты Kubernetes: Pod, Service, Deployment",
      "content": "**Рик говорит: «О, малыш, давай я объясню тебе про этот ваш Kubernetes, только не скули, ладно?»**\n\nСлушай сюда, пацан, Kubernetes — это не просто набор букв, это целая вселенная, где всё крутится и вертится, как надо. Ну, типа как мой космический корабль, только без моего гениального управления, конечно.\n\nИтак, начнём с самого простого — с Pod’а. Представь, что Pod — это такая коробочка, в которой может быть один или несколько контейнеров. Они там все дружат и делятся всем: и сетью, и томами. Типа как если бы мы с Морти жили в одной квартире и делили бы холодильник и вайфай. Удобно, да?\n\nДальше у нас идёт Service. Это такая штука, которая даёт стабильный IP или DNS для доступа к группе подов. Ну, типа как адрес дома, по которому ты всегда можешь найти своих друзей. Есть разные типы сервисов: ClusterIP, NodePort, LoadBalancer. Это как разные способы добраться до дома: пешком, на машине или на космическом корабле — выбирай, что тебе больше нравится.\n\nТеперь про Deployment. Это уже серьёзная штука, братан. Deployment управляет репликами подов — то есть может увеличивать или уменьшать их количество, проводить rolling-обновления (это когда приложение обновляется, но при этом продолжает работать) и откатывать изменения, если что-то пошло не так. Deployment создаёт ReplicaSet — это такой помощник, который следит за тем, чтобы количество подов было именно такое, какое нужно.\n\nА ещё у нас есть ConfigMap и Secret. ConfigMap хранит конфигурацию, а Secret — чувствительные данные, например, пароли. Причём пароли хранятся в base64, чтобы никто не смог их прочитать. Это как если бы я хранил свои секретные формулы в зашифрованном виде, чтобы Морти не смог их стырить.\n\nPersistentVolume (PV) и PersistentVolumeClaim (PVC) — это уже про постоянное хранилище. PV — это как жёсткий диск, а PVC — как запрос на использование этого диска. Так мы можем сохранять данные даже если поды перезапустятся.\n\nNamespace — это такая штука, которая изолирует ресурсы. Например, можно создать Namespace для продакшена (prod) и для разработки (dev). Это как разные комнаты в доме: в одной ты работаешь, а в другой отдыхаешь.\n\nИ наконец, чтобы всё это запустить, нужно выполнить команду `kubectl apply -f manifest.yml`. Это как нажать кнопку «пуск» на моём космическом корабле — и всё заработает.\n\n**Хэштеги:** #Kubernetes #Pod #Service #Deployment #ConfigMap #Secret #PV #PVC #Namespace #kubectl\n\n**Советы от Рика:**\n* не пытайся понять всё сразу — это как пытаться съесть целый космический пирог за один укус;\n* используй документацию — это как инструкция к моему кораблю, без неё ты никуда не улетишь;\n* практикуйся — чем больше ты будешь работать с Kubernetes, тем лучше будешь его понимать;\n* не бойся ошибок — даже я иногда ошибаюсь, но главное — быстро исправлять свои промахи.",
      "questions": [
        {
          "text": "Что такое Pod в Kubernetes?",
          "options": [
            "Группа сервисов",
            "Минимальная единица развёртывания (1+ контейнеров)",
            "Тип сети",
            "Хранилище конфигурации"
          ],
          "correct": 1
        },
        {
          "text": "Какой тип Service открывает порт на всех узлах кластера?",
          "options": [
            "ClusterIP",
            "NodePort",
            "LoadBalancer",
            "ExternalName"
          ],
          "correct": 1
        },
        {
          "text": "Что делает Deployment?",
          "options": [
            "Хранит пароли",
            "Управляет репликами подов с поддержкой обновлений",
            "Создаёт тома",
            "Обеспечивает сетевую изоляцию"
          ],
          "correct": 1
        },
        {
          "text": "Где хранятся чувствительные данные в Kubernetes?",
          "options": [
            "ConfigMap",
            "Secret",
            "PersistentVolume",
            "Namespace"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "StatefulSet vs Deployment и управление состоянием",
      "content": "**Рик говорит: «О, внучок, давай я тебе объясню, что тут к чему с этими вашими Deployment и StatefulSet!»**\n\nСлушай сюда, Морти! Представь, что ты запускаешь какое-то приложение в космосе, ок? Есть два основных способа это сделать: один — для простых приложений, другой — для более сложных.\n\n**Deployment** — это как если бы ты запускал кучу одинаковых роботов-помощников. Они все одинаковые, взаимозаменяемые, и тебе вообще без разницы, какой из них что делает. Например, если у тебя веб-сервер или API — то есть что-то, где не важно, какой конкретно сервер обрабатывает запрос, — то Deployment подойдёт идеально.\n\nВот как это работает:\n поды (это такие маленькие контейнеры с приложениями) полностью взаимозаменяемы — один сломался, другой подхватит;\n**StatefulSet**. Это уже для более серьёзных дел, типа баз данных или Kafka. Тут уже всё серьёзно, порядок и состояние имеют значение.\n\nВот что тут важно:\n каждый под имеет фиксированное имя (типа pod-0, pod-1) — это как если бы у каждого робота был свой личный номер;\n**Headless Service**. Это сервис без ClusterIP, который позволяет обращаться напрямую к подам по DNS. Представь, что это как если бы у каждого робота был свой личный адрес в космосе, по которому ты можешь его найти и поговорить с ним напрямую.\n\nТак что вот тебе совет, Морти:\n* используй Deployment для масштабируемых сервисов, где не важно, какой конкретно под обрабатывает запрос;\n* выбирай StatefulSet для баз данных и систем, где важен порядок и состояние.\n\n**Хэштеги:** #kubernetes #Deployment #StatefulSet #HeadlessService #контейнеры #поды #базыданных\n\n**Советы от Рика:**\n1. Всегда думай о том, что тебе нужно: масштабируемость или сохранение состояния.\n2. Не усложняй там, где можно упростить — если Deployment справляется, не лезь в StatefulSet.\n3. Помни о важности порядка и состояния в сложных системах — это может спасти тебя от больших проблем в будущем.\n\nНу вот, Морти, теперь ты знаешь всё, что нужно! Лети решать свои космические задачи!",
      "questions": [
        {
          "text": "В чём ключевое отличие StatefulSet от Deployment?",
          "options": [
            "StatefulSet не поддерживает реплики",
            "StatefulSet даёт фиксированные имена подов и постоянное хранилище",
            "Deployment работает только в облаке",
            "StatefulSet не использует PersistentVolume"
          ],
          "correct": 1
        },
        {
          "text": "Для какого типа приложений подходит StatefulSet?",
          "options": [
            "Nginx",
            "REST API",
            "MySQL",
            "Фронтенд-приложение"
          ],
          "correct": 2
        },
        {
          "text": "Что такое Headless Service?",
          "options": [
            "Сервис без IP, для прямого доступа к подам по DNS",
            "Сервис только для внутреннего трафика",
            "Балансировщик нагрузки",
            "Тип тома"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Сети, Ingress и CNI в Kubernetes",
      "content": "**Рик говорит: «О, Kubernetes и вся эта сетевая лабуда — раз плюнуть!»**\n\nСлушай сюда, малыш, я тебе объясню, как эта вся Kubernetes-херня работает. Ну, типа, ты же знаешь, там всякие плагины CNI нужны, чтобы сеть настроить. Calico, Flannel, WeaveNet — вот это всё. Короче, каждый под (это такая фигня в Kubernetes) получает свой уникальный IP-адрес из диапазона podCIDR. Понял? Это как если бы каждому жителю в городе дали свой адрес, чтобы почта доходила куда надо.\n\nА сервисы в Kubernetes используют ClusterIP для внутренней балансировки. То есть трафик внутри системы распределяется так, чтобы всё работало гладко и никто не перегружался. Представь, что это как диспетчер в аэропорту, который направляет самолёты на разные взлётно-посадочные полосы.\n\nТеперь про внешний доступ. Тут у нас три основных варианта:\n* NodePort — это когда ты открываешь определённый порт на узле (компьютере в кластере), и через него можно достучаться до сервиса.\n* LoadBalancer — это уже посерьёзнее, тут подключается облачный балансировщик, который распределяет нагрузку между несколькими узлами. Типа как если бы у тебя было несколько дорог для въезда в город, и специальный чувак решал, по какой дороге ехать каждому автомобилю.\n* Ingress — это вообще крутая штука. Это такой объект, который маршрутизирует HTTP и HTTPS-трафик по определённым правилам (host, path). То есть он решает, куда отправить запрос в зависимости от того, что ты написал в браузере.\n\nНо Ingress сам по себе не работает, ему нужен Ingress Controller. Это такая программка, которая выполняет всю работу. Можно использовать Nginx или Traefik, например. Ingress Controller делает несколько вещей:\n* завершает TLS (это такая штука для шифрования трафика, чтобы никто не мог подслушать);\n* балансирует нагрузку, то есть распределяет трафик между разными подами, чтобы никто не перегружался;\n* централизует входящий трафик, то есть собирает все запросы в одном месте и потом распределяет их.\n\nА если тебе нужно ограничить трафик между подами, то тут на помощь приходит NetworkPolicy. Это как правила в школе: кто куда может ходить, кто с кем может общаться и так далее. В Kubernetes ты можешь настроить правила, которые будут ограничивать трафик между подами, чтобы одни поды не мешали другим.\n\n**Хэштеги:** #Kubernetes #CNI #Ingress #NetworkPolicy #IT\n\n**Советы от Рика:**\n1. Не бойся сложных вещей — разбивай их на простые кусочки, и всё станет понятно.\n2. Используй аналогии из реальной жизни, чтобы объяснить технические вещи — так проще запомнить.\n3. Не заморачивайся слишком сильно — если что-то не получается, просто скажи: «Да ну его, этот Kubernetes!» и иди пить космический кофе.\n\nНу вот, теперь ты знаешь про Kubernetes чуть больше. Хотя, честно говоря, это всё равно что объяснять муравью, как работает космический корабль. Но что поделаешь — приходится иногда опускаться до уровня простых смертных.",
      "questions": [
        {
          "text": "Как реализована сеть в Kubernetes?",
          "options": [
            "Через iptables напрямую",
            "Через плагины CNI (Calico, Flannel)",
            "Через Docker-сеть",
            "Сеть не поддерживается"
          ],
          "correct": 1
        },
        {
          "text": "Что делает Ingress Controller?",
          "options": [
            "Хранит конфигурацию",
            "Маршрутизирует HTTP/HTTPS-трафик по правилам Ingress",
            "Создаёт PersistentVolume",
            "Управляет репликами"
          ],
          "correct": 1
        },
        {
          "text": "Какой объект позволяет ограничить сетевое взаимодействие между подами?",
          "options": [
            "Service",
            "NetworkPolicy",
            "ConfigMap",
            "Secret"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Безопасность, ресурсы и отказоустойчивость",
      "content": "**Рик говорит: как разобраться в хитросплетениях кластера, чтобы не попасть в параллельную вселенную**\n\nЭй, чуваки! Рик тут, и я сейчас объясню вам, как всё работает в этих ваших кластерах. Не думайте, что это сложнее, чем построить межзвёздный корабль из мусора — я и не такое видел!\n\nИтак, начнём с безопасности. Есть такая штука — RBAC (Role-Based Access Control). Звучит запутанно, но на самом деле всё просто: это как если бы у вас были разные ключи от разных комнат в доме. Кому-то можно только в гостиную, а кому-то — и в подвал, где хранится самое секретное. Так и тут: RBAC ограничивает права пользователей и сервисных аккаунтов, чтобы никто не залез туда, куда не надо.\n\nА ещё есть секреты (Secret). Представьте, что вы прячете важные бумажки в сейф, а потом кодируете их, чтобы никто не смог прочитать. Вот и тут данные хранятся в base64 — это такой способ кодирования, который делает информацию непонятной для посторонних.\n\nТеперь про ресурсы. Представьте, что у вас есть кухня, и вы готовите кучу блюд одновременно. Чтобы всё получилось и ничего не сгорело, нужно правильно распределить газ, воду и электричество. В контейнерах то же самое: там указываются requests (гарантированные ресурсы) и limits (максимум). Это нужно, чтобы всё работало как надо и чтобы один под (это такая «посуда» в кластере) не «съел» все ресурсы и не оставил других без ничего — это называется «голодание» подов.\n\nПереходим к отказоустойчивости. Тут всё как в моей летающей тарелке: если один движок сломается, другие должны подхватить. В кластере для этого есть несколько master-узлов с etcd. Etcd — это такая база данных, которая хранит всю важную инфу о кластере. Если один мастер-узел выйдет из строя, другие подхватят.\n\nЕщё worker-узлы (это такие «рабочие лошадки» в кластере) размещаются в разных зонах. Это как если бы у вас были склады в разных частях города — если в одной части что-то случится, у вас ещё останутся запасы в других местах.\n\nЕсть ещё liveness/readiness-пробы — это такие «самопроверки», которые помогают подам понять, всё ли у них в порядке. Если что-то не так, они могут сами себя «починить».\n\nА HPA (Horizontal Pod Autoscaler) — это вообще крутая штука. Она автоматически масштабирует поды в зависимости от нагрузки по CPU и памяти. Представьте, что у вас есть ресторан, и в часы пик он автоматически открывает больше столиков, а когда народу мало — закрывает. Вот и тут так же!\n\nИ последнее — резервное копирование etcd. Это как страховка для вашего кластера. Если что-то пойдёт не так, вы сможете восстановить всё из резервной копии. Без этого вы рискуете потерять весь кластер, и тогда придётся начинать всё сначала — а это, поверьте, никому не хочется.\n\n**Хэштеги:** #кластер #RBAC #etcd #HPA #отказоустойчивость #ресурсы #безопасность\n\n**Советы от Рика:**\n* не недооценивайте важность резервного копирования — это может спасти вам жизнь (или, по крайней мере, кучу времени и нервов);\n* всегда думайте о безопасности — лучше перестраховаться, чем потом разбираться с последствиями утечки данных;\n* автоматизация — ваш лучший друг, особенно когда речь идёт о масштабировании и самовосстановлении;\n* помните, что даже самые сложные системы можно понять, если разбить их на простые части.\n\nТак что вперёд, покоряйте кластеры, но не забывайте иногда смотреть в небо — вдруг там притаилась какая-нибудь межгалактическая угроза!",
      "questions": [
        {
          "text": "Что такое liveness probe?",
          "options": [
            "Проверяет готовность пода к трафику",
            "Проверяет, жив ли под — перезапускает при сбое",
            "Проверяет запуск контейнера",
            "Проверяет использование CPU"
          ],
          "correct": 1
        },
        {
          "text": "Как ограничить ресурсы контейнера в Kubernetes?",
          "options": [
            "Через limits и requests в манифесте",
            "Через Dockerfile",
            "Через CNI",
            "Это невозможно"
          ],
          "correct": 0
        },
        {
          "text": "Что обеспечивает RBAC в Kubernetes?",
          "options": [
            "Сетевую изоляцию",
            "Управление правами доступа",
            "Балансировку нагрузки",
            "Хранение секретов"
          ],
          "correct": 1
        },
        {
          "text": "Что делает HPA (Horizontal Pod Autoscaler)?",
          "options": [
            "Масштабирует ноды",
            "Масштабирует количество подов по метрикам",
            "Создаёт резервные копии",
            "Управляет томами"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Диагностика и продвинутые объекты: DaemonSet, Job, Helm",
      "content": "**Рик говорит: «Kubernetes — это вам не шутки, тут надо разбираться!»**\n\nЭй, пацаны, слушайте сюда! Сейчас я вам объясню, как всё работает в этом вашем Kubernetes. Я, конечно, гений, и мне всё понятно, но и вам постараюсь растолковать, чтобы даже самый тупой смог разобраться.\n\nИтак, начнём с DaemonSet. Это такая штука, которая запускает поды на каждом узле. Зачем это нужно? А вот зачем:\n* для мониторинга используем Node Exporter — он собирает всякие метрики с узлов, чтобы мы могли видеть, что там творится;\n* для логирования — Fluentd. Он собирает логи и отправляет их куда надо, чтобы мы могли потом анализировать, что пошло не так.\n\nДальше у нас есть Job. Это когда нужно запустить под и выполнить какую-то задачу, а потом всё — можно сворачиваться. Например, нужно сделать миграцию данных или сделать резервное копирование — тут Job и пригодится.\n\nА ещё есть CronJob. Это как будильник: вы задаёте расписание, и Job запускается в нужное время. Удобно, когда нужно что-то делать регулярно — например, каждый день в полночь запускать задачу по очистке логов.\n\nТеперь про Helm. Это такой менеджер пакетов для Kubernetes. Представьте себе, что это как магазин, где вы можете выбрать готовый шаблон (Chart) и развернуть его в своём кластере. Helm упрощает развёртывание, управление версиями и откаты — короче, всё, что нужно, чтобы не сломать всё к чертям.\n\nА теперь про диагностику. Вот несколько команд, которые вам пригодятся:\n* `kubectl get pods` — покажет вам список всех подов в кластере. Вы сможете увидеть, какие поды работают, а какие — нет;\n* `kubectl describe pod` — даст вам подробную информацию о конкретном поде. Вы сможете увидеть его состояние, контейнеры, которые в нём работают, и другие детали;\n* `kubectl logs` — выведет логи пода. Если что-то пошло не так, смотрите логи — там часто можно найти причину проблемы;\n* `kubectl top pods` — покажет вам метрики использования ресурсов подами. Но для этого вам понадобится Metrics Server.\n\nЕсли под в статусе CrashLoopBackOff — значит, что-то пошло не так. Проверяйте логи и liveness-пробы. Liveness-пробы — это такие проверки, которые определяют, работает ли под нормально. Если под не проходит liveness-пробу, Kubernetes может перезапустить его.\n\nЕсли под в статусе Pending — значит, либо не хватает ресурсов на узлах, либо нет подходящего узла для развёртывания пода. В этом случае нужно либо добавить ресурсы, либо настроить ограничения для подов.\n\n**Хэштеги:** #Kubernetes #DaemonSet #Job #CronJob #Helm #Диагностика\n\n**Советы от Рика:**\n1. Всегда проверяйте логи — в них часто можно найти причину проблем.\n2. Используйте liveness- и readiness-пробы, чтобы Kubernetes мог правильно управлять вашими подами.\n3. Не бойтесь экспериментировать, но помните о возможности отката — вдруг вы что-то сломаете (а вы обязательно что-нибудь сломаете, это нормально).\n4. Изучайте документацию — там много полезной информации, которая может спасти вам жизнь (или, по крайней мере, сэкономить время).",
      "questions": [
        {
          "text": "Для чего используется DaemonSet?",
          "options": [
            "Для запуска пода на каждом узле",
            "Для масштабирования веб-приложения",
            "Для хранения конфигурации",
            "Для балансировки трафика"
          ],
          "correct": 0
        },
        {
          "text": "Что такое Helm?",
          "options": [
            "Сетевой плагин",
            "Менеджер пакетов для Kubernetes",
            "Тип тома",
            "Контроллер реплик"
          ],
          "correct": 1
        },
        {
          "text": "Какой объект запускает задачу по расписанию?",
          "options": [
            "Deployment",
            "StatefulSet",
            "CronJob",
            "Service"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Итоговый тест: Kubernetes (Junior)",
      "content": "**Рик говорит: «Kubernetes? Пф, раз плюнуть!»**\n\nСлушай сюда, малой, я тут про Kubernetes тебе поведаю. Представь, ты в космическом корабле, а Kubernetes — это система управления этим кораблём. Только вместо звёзд и астероидов у тебя контейнеры с приложениями, а вместо штурвала — куча команд и настроек.\n\nТак вот, есть там финальный тест, братан, на 25+ вопросов. И там тебе придётся разобраться во всей этой байде:\n архитектура — это как план корабля, где что находится и как всё связано;\n объекты — это разные части корабля, типа отсеков и систем жизнеобеспечения;\n сети — это как система коммуникаций на корабле, чтобы все части могли «разговаривать» друг с другом;\n**Хэштеги:** #Kubernetes #тест #IT #администрирование #контейнеры #технологии\n\n**Советы от Рика:**\n1. Не пытайся выучить всё за один день — разбей подготовку на несколько сессий, так информация лучше усвоится.\n2. Используй онлайн-курсы и туториалы — там часто объясняют сложные вещи простым языком.\n3. Практикуйся! Попробуй развернуть свой собственный кластер Kubernetes и поэкспериментировать с ним — практика лучше любого теоретического обучения.\n4. Не бойся задавать вопросы — в IT-сообществе полно опытных ребят, которые с радостью помогут новичку.\n5. И помни, малой, если ты можешь разобраться в Kubernetes, то ты можешь разобраться в чём угодно! Так что не сдавайся и двигайся вперёд!",
      "questions": [
        {
          "text": "Что такое Kubernetes?",
          "options": [
            "Менеджер пакетов",
            "Платформа для оркестрации контейнеров",
            "Тип виртуальной машины",
            "Сетевой протокол"
          ],
          "correct": 1
        },
        {
          "text": "Какой компонент выбирает узел для запуска пода?",
          "options": [
            "kubelet",
            "kube-scheduler",
            "kube-proxy",
            "etcd"
          ],
          "correct": 1
        },
        {
          "text": "Что хранится в etcd?",
          "options": [
            "Логи подов",
            "Всё состояние кластера",
            "Образы контейнеров",
            "Сетевые правила"
          ],
          "correct": 1
        },
        {
          "text": "Может ли Pod содержать несколько контейнеров?",
          "options": [
            "Нет, только один",
            "Да, обычно основной + sidecar",
            "Только в StatefulSet",
            "Только в Job"
          ],
          "correct": 1
        },
        {
          "text": "Какой объект обеспечивает стабильный доступ к подам?",
          "options": [
            "Pod",
            "Deployment",
            "Service",
            "ConfigMap"
          ],
          "correct": 2
        },
        {
          "text": "В чём разница между Deployment и ReplicaSet?",
          "options": [
            "Нет разницы",
            "ReplicaSet поддерживает обновления",
            "Deployment использует ReplicaSet и добавляет обновления/откаты",
            "Deployment не поддерживает реплики"
          ],
          "correct": 2
        },
        {
          "text": "Для чего используется readiness probe?",
          "options": [
            "Перезапускать под при сбое",
            "Определять, готов ли под к трафику",
            "Проверять запуск контейнера",
            "Измерять CPU"
          ],
          "correct": 1
        },
        {
          "text": "Какой тип Service создаёт внешний балансировщик в облаке?",
          "options": [
            "ClusterIP",
            "NodePort",
            "LoadBalancer",
            "Headless"
          ],
          "correct": 2
        },
        {
          "text": "Что такое PersistentVolumeClaim (PVC)?",
          "options": [
            "Физический диск",
            "Запрос на выделение постоянного тома",
            "Тип сети",
            "Конфигурация пода"
          ],
          "correct": 1
        },
        {
          "text": "Где хранятся пароли и ключи в Kubernetes?",
          "options": [
            "ConfigMap",
            "Secret",
            "PersistentVolume",
            "Deployment"
          ],
          "correct": 1
        },
        {
          "text": "Что делает kubelet?",
          "options": [
            "Маршрутизирует трафик",
            "Запускает и управляет подами на узле",
            "Хранит состояние кластера",
            "Планирует размещение подов"
          ],
          "correct": 1
        },
        {
          "text": "Какой объект используется для stateful-приложений?",
          "options": [
            "Deployment",
            "StatefulSet",
            "DaemonSet",
            "Job"
          ],
          "correct": 1
        },
        {
          "text": "Что такое Ingress?",
          "options": [
            "Тип тома",
            "Объект для маршрутизации HTTP/HTTPS",
            "Контроллер реплик",
            "Тип секрета"
          ],
          "correct": 1
        },
        {
          "text": "Как запустить под на каждом узле?",
          "options": [
            "Deployment",
            "StatefulSet",
            "DaemonSet",
            "ReplicaSet"
          ],
          "correct": 2
        },
        {
          "text": "Что такое Horizontal Pod Autoscaler (HPA)?",
          "options": [
            "Масштабирует ноды",
            "Масштабирует поды по CPU/памяти",
            "Балансирует трафик",
            "Управляет томами"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой посмотреть логи пода?",
          "options": [
            "kubectl logs",
            "kubectl describe",
            "kubectl get",
            "kubectl top"
          ],
          "correct": 0
        },
        {
          "text": "Что такое Namespace?",
          "options": [
            "Тип сети",
            "Логическая изоляция ресурсов",
            "Хранилище образов",
            "Контейнерный рантайм"
          ],
          "correct": 1
        },
        {
          "text": "Какой компонент управляет сетевыми правилами на узле?",
          "options": [
            "kubelet",
            "kube-proxy",
            "CNI",
            "etcd"
          ],
          "correct": 1
        },
        {
          "text": "Что произойдёт, если под не уложится в requests по памяти?",
          "options": [
            "Он не запустится",
            "Он будет убит OOM Killer",
            "Он продолжит работать",
            "Kubernetes увеличит лимит автоматически"
          ],
          "correct": 0
        },
        {
          "text": "Какой объект запускает задачу до завершения?",
          "options": [
            "Deployment",
            "StatefulSet",
            "Job",
            "DaemonSet"
          ],
          "correct": 2
        },
        {
          "text": "Что такое Helm Chart?",
          "options": [
            "Тип тома",
            "Шаблон развёртывания приложения",
            "Сетевой плагин",
            "Контроллер безопасности"
          ],
          "correct": 1
        },
        {
          "text": "Какой статус у пода, если он постоянно падает и перезапускается?",
          "options": [
            "Running",
            "Pending",
            "CrashLoopBackOff",
            "Succeeded"
          ],
          "correct": 2
        },
        {
          "text": "Что такое RBAC в Kubernetes?",
          "options": [
            "Сетевой контроллер",
            "Система управления доступом на основе ролей",
            "Тип тома",
            "Протокол аутентификации"
          ],
          "correct": 1
        },
        {
          "text": "Какой командой применить манифест?",
          "options": [
            "kubectl create",
            "kubectl apply",
            "kubectl run",
            "kubectl start"
          ],
          "correct": 1
        },
        {
          "text": "Сколько экземпляров Control Plane нужно для HA?",
          "options": [
            "1",
            "2",
            "3 или нечётное число",
            "Зависит от количества подов"
          ],
          "correct": 2
        }
      ]
    }
  ],
  "cicd": [
    {
      "title": "Основы CI/CD: что такое pipeline?",
      "content": "**Рик говорит: CI/CD — это вам не шутки, пацаны!**\n\nЭй, слушай сюда, малыш! Сейчас дед Рик объяснит тебе, что такое CI/CD. Только не вздумай засыпать — тема серьёзная!\n\nИтак, CI/CD — это такая штука, которая помогает автоматизировать всю эту муть с разработкой и доставкой программного обеспечения. Понял, да? То есть вместо того, чтобы вручную всё делать, мы используем крутые инструменты и автоматизируем процессы. Круто, правда?\n\nРазберёмся по порядку. CI — это Continuous Integration, или, если по-нашему, непрерывная интеграция. Представь, что ты пишешь код и постоянно добавляешь в него изменения. Каждый раз, когда ты делаешь коммит в Git (это такая система контроля версий, если что), запускается целый конвейер (pipeline) — он собирает твой код и запускает тесты. То есть система сама проверяет, не накосячил ли ты где. Удобно, да?\n\nА теперь про CD — Continuous Delivery или Continuous Deployment, то есть непрерывная доставка или развёртывание. После того как твои тесты прошли успешно, артефакт (то есть готовый кусочек ПО) автоматически отправляется либо в staging (это такая промежуточная среда, где всё ещё раз проверяют), либо сразу в production (то есть в боевую среду, где всё работает для пользователей). Понял теперь, как это работает?\n\nА теперь давай разберём этот самый pipeline. Это такая последовательность этапов, которые код проходит, прежде чем попасть к пользователям. Вот основные этапы:\n\n1. **Checkout** — система берёт код из репозитория.\n2. **Build** — код собирается в единый исполняемый файл или пакет.\n3. **Test** — запускаются тесты, чтобы проверить, всё ли работает как надо.\n4. **Deploy** — готовый продукт доставляется в нужную среду.\n\nГлавная цель всего этого — быстро и безопасно доставлять изменения в ПО с минимальным участием человека. То есть мы сокращаем время на релизы и уменьшаем вероятность ошибок. Здорово, правда?\n\n**Советы от Рика:**\n не бойся автоматизировать процессы — это сэкономит тебе кучу времени;\n",
      "questions": [
        {
          "text": "Что означает CI в CI/CD?",
          "options": [
            "Continuous Installation",
            "Continuous Integration",
            "Code Inspection",
            "Container Infrastructure"
          ],
          "correct": 1
        },
        {
          "text": "В чём разница между Continuous Delivery и Continuous Deployment?",
          "options": [
            "Delivery — ручной релиз, Deployment — автоматический",
            "Delivery — только для тестов, Deployment — для продакшена",
            "Нет разницы",
            "Deployment не использует Git"
          ],
          "correct": 0
        },
        {
          "text": "Когда запускается CI pipeline?",
          "options": [
            "Раз в день",
            "При каждом коммите в Git",
            "Только при релизе",
            "Вручную администратором"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Git, ветвление и триггеры",
      "content": "**Рик говорит: о CI/CD и Git****Хэштеги:** #CI/CD #Git #программирование #автоматизация #дедРикЗнаетВсё\n\n**Советы от деда Рика:**\n* не бойтесь экспериментировать с разными стратегиями ветвления — вдруг найдёте свою идеальную;\n* следите за временем выполнения pipeline — чем быстрее, тем лучше;\n* используйте кэширование и параллельное выполнение задач — это реально ускоряет процесс;\n* помните, что CI/CD — это не просто набор инструментов, а философия разработки.\n\nТак что там у вас, пацаны? Готовы покорять космические высоты программирования? Вперед, и да пребудет с вами сила кода!",
      "questions": [
        {
          "text": "Какая стратегия ветвления предполагает частые коммиты в main?",
          "options": [
            "GitFlow",
            "Trunk-based development",
            "Release branching",
            "Feature toggling"
          ],
          "correct": 1
        },
        {
          "text": "Что может быть триггером для CI pipeline?",
          "options": [
            "Только ручной запуск",
            "Push в Git-ветку",
            "Изменение DNS",
            "Перезагрузка сервера"
          ],
          "correct": 1
        },
        {
          "text": "Как ускорить CI pipeline?",
          "options": [
            "Убрать все тесты",
            "Использовать кэширование и параллельные задачи",
            "Запускать ночью",
            "Использовать самые дешёвые runner'ы"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "GitHub Actions и GitLab CI: основы",
      "content": "**Рик говорит: про CI/CD и всё такое — разжую, как для младенца!****Jobs (задачи)****Steps (шаги)****Runners (машины для выполнения)** — это сервера или машины, которые выполняют все эти задачи и шаги. Представьте себе, что это рабочие на заводе, которые делают всю грязную работу за вас.\n\nДавайте посмотрим на пример. Допустим, вам нужно сделать следующее:\n1. Собрать Docker-образ.\n2. Прогнать тесты.\n3. Отправить всё в registry.\n\nВот вы и описываете эти шаги в вашем YAML-файле, и система сама всё выполняет — красота, правда?\n\nЕщё одна важная штука — это secrets (секреты). Это всякие там пароли, ключи и прочая конфиденциальная информация. Хранятся они в настройках репозитория и подставляются в pipeline как переменные окружения. Но тут есть одно очень важное правило: **никогда не храните секреты в коде!** Это как оставлять ключ от сейфа под ковриком — любой дурак сможет воспользоваться.\n\nТак что запомните, пацаны: автоматизация — это круто, но безопасность тоже никто не отменял.\n\n**Хэштеги:** #CI/CD #GitHubActions #GitLabCI #YAML #Docker #автоматизация #безопасность\n\n**Советы от Рика:**\n* всегда используйте секреты для хранения конфиденциальной информации;\n* не храните секреты в коде — это как оставить дверь открытой для хакеров;\n* автоматизируйте всё, что только можно — меньше ручной работы, меньше ошибок;\n* изучайте документацию — там много полезного, просто нужно уметь читать между строк.\n\nНу вот, пацаны, теперь вы знаете немного больше о CI/CD. Рик всегда готов помочь — обращайтесь!",
      "questions": [
        {
          "text": "Где описывается pipeline в GitHub Actions?",
          "options": [
            ".gitlab-ci.yml",
            ".github/workflows/*.yml",
            "Dockerfile",
            "package.json"
          ],
          "correct": 1
        },
        {
          "text": "Где в GitLab CI хранится конфигурация pipeline?",
          "options": [
            ".github/workflows/ci.yml",
            ".gitlab-ci.yml",
            "Jenkinsfile",
            "Makefile"
          ],
          "correct": 1
        },
        {
          "text": "Как безопасно использовать пароли/API-ключи в CI?",
          "options": [
            "Хранить в коде",
            "Передавать в коммитах",
            "Использовать Secrets в настройках репозитория",
            "Писать в логи"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Артефакты, образы и стратегии деплоя",
      "content": "**Рик говорит: о деплое и Docker-образах**\n\nЭй, пацаны, слушайте сюда! Сейчас дед Рик объяснит вам, что к чему с этими вашими Docker-образами и деплоем. Так что заседайтесь поудобнее, сейчас будет крутая лекция от крутого чувака!\n\nИтак, начнём с азов. Артефакт — это, по сути, то, что вы получаете после того, как всё собрали. Это может быть исполняемый файл, Docker-образ или какой-нибудь пакет. Docker-образ — это такая своеобразная «упаковка» вашего приложения со всем необходимым окружением, чтобы оно могло работать где угодно, без головной боли с зависимостями.\n\nИ вот эти образы нужно куда-то складывать, чтобы потом можно было их использовать. Есть разные места для этого: Docker Hub, GitLab Registry, AWS ECR — выбирайте, что вам больше по душе. Но вот что важно: когда вы загружаете (пушите) свои образы в реестр, не забывайте их тегировать! И вот тут многие делают ошибку — используют тег latest. Не надо так! Лучше тегировать образы по Git-хешу или версии. Так вы всегда будете знать, что за версия у вас запущена, и не будет путаницы.\n\nА теперь поговорим о стратегиях деплоя. Это важно, потому что от того, как вы будете деплоить своё приложение, зависит, насколько гладко всё пройдёт и сколько проблем вам придётся решать.\n\nПервая стратегия — Rolling update. Это как замена деталей в машине, когда вы постепенно меняете одни поды (если вы работаете с K8s) на другие, новые. Kubernetes по умолчанию использует именно эту стратегию, и она довольно удобна, потому что позволяет избежать простоев.\n\nВторая стратегия — Blue/Green. Представьте, что у вас есть два полностью идентичных окружения: одно — «синее», другое — «зелёное». Вы запускаете новую версию в «зелёном» окружении и переключаете на него трафик, когда всё работает как надо. Это позволяет минимизировать риски и время простоя.\n\nТретья стратегия — Canary. Это как тестирование на небольшой группе пользователей. Вы выпускаете новую версию только для части пользователей и смотрите, как она себя ведёт. Если всё ок — раскатываете на всех, а если что-то пошло не так — быстро откатываетесь. Очень удобно, если вы не хотите рисковать и хотите быстро исправить ошибки.\n\nВыбор стратегии зависит от того, насколько вам важен uptime (время бесперебойной работы) и какой уровень риска вы готовы принять. Canary, например, хорош тем, что позволяет быстро откатиться при ошибках, но требует более тщательного мониторинга.\n\nТак что, пацаны, выбирайте стратегию с умом и не забывайте про тегирование образов. И всё у вас будет чики-пуки!\n\n#Docker #деплой #Kubernetes #IT #программирование\n\n**Совет от деда Рика:** всегда тестируйте свои изменения в изолированной среде перед деплоем в продакшен. И не бойтесь экспериментировать — иногда самые безумные идеи оказываются самыми работающими!\n\n**Ещё один совет:** автоматизируйте всё, что можно автоматизировать. Это сэкономит вам кучу времени и нервов в будущем.",
      "questions": [
        {
          "text": "Почему не стоит использовать тег latest для образов в CI/CD?",
          "options": [
            "Он самый большой",
            "Он нестабилен и ломает воспроизводимость",
            "Он не поддерживается в K8s",
            "Он бесплатный"
          ],
          "correct": 1
        },
        {
          "text": "Какая стратегия деплоя подразумевает переключение трафика между двумя окружениями?",
          "options": [
            "Rolling update",
            "Blue/Green",
            "Canary",
            "Recreate"
          ],
          "correct": 1
        },
        {
          "text": "Что такое артефакт в CI/CD?",
          "options": [
            "Исходный код",
            "Результат сборки (образ, бинарник)",
            "Лог ошибок",
            "Git-коммит"
          ],
          "correct": 1
        },
        {
          "text": "Какая стратегия деплоя выпускает новую версию для части пользователей?",
          "options": [
            "Blue/Green",
            "Rolling",
            "Canary",
            "Hotfix"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Безопасность и продвинутые практики",
      "content": "**Безопасность в CI/CD: как не облажаться**\n\nЭй, пацаны, давайте поговорим о CI/CD. Я, Рик, знаю об этом всём больше, чем кто-либо другой. Так что слушайте внимательно, а то потом пожалеете.\n\nИтак, CI/CD — это не просто какая-то там автоматизация. Это целая культура, братан! Культура быстрой и безопасной доставки ценности. Но чтобы всё было чётко и без косяков, нужно соблюдать несколько правил.\n\n**Базовые принципы:**\n\n1. **Secrets — только через защищённые переменные.** Запомните, пацаны: никогда, слышите, никогда не вставляйте секреты в код! Это как оставить ключи от своей тачки на видном месте — любой гопник воспользуется. Используйте защищённые переменные — так безопаснее.\n\n2. **SAST (Static Application Security Testing)** — это анализ кода на уязвимости. Представьте, что вы проверяете свою тачку перед долгой поездкой. Вот и тут то же самое — проверяете код, чтобы не было никаких проблем. Можно использовать такие инструменты, как Snyk, Trivy, SonarQube. Они как хорошие механики — найдут все косяки в коде.\n\n3. **Сканирование Docker-образов на CVE.** CVE — это уязвимости, которые могут испортить вам весь день. А сканирование Docker-образов — это как рентген для вашей тачки. Вы проверяете, нет ли где скрытых проблем, которые могут вылезти в самый неподходящий момент.\n\n4. **Минимальные права для runner'ов.** Представьте, что вы даёте кому-то ключи от своей тачки, но только чтобы он смог заправить её. Вы же не дадите ему права продавать вашу тачку или разбирать её на запчасти, правда? Вот и тут то же самое — давайте runner'ам только те права, которые им действительно нужны.\n\n**Продвинутые практики:**\n\n1. **GitOps — деплой через Git (FluxCD, ArgoCD).** GitOps — это как управление вашей тачкой через пульт дистанционного управления. Вы можете быстро и легко вносить изменения, не парясь с кучей лишних действий. FluxCD и ArgoCD — это как разные модели пультов, выбирайте тот, который вам больше нравится.\n\n2. **Infrastructure as Code (Terraform) в pipeline.** Представьте, что вы можете описать всю свою инфраструктуру в виде кода. Звучит круто, да? Вот именно! Terraform помогает вам сделать это. Вы можете управлять своей инфраструктурой так же легко, как писать код.\n\n3. **Тесты в production-подобной среде (staging).** Перед тем как выпустить свою тачку на большую дорогу, вы же проверите её на тестовой площадке, верно? Вот и тут то же самое — тестируйте свой код в среде, которая максимально похожа на production. Так вы сможете выявить все проблемы до того, как они вылезут в реальной жизни.\n\n4. **Откат по Git-тегу или Helm-релизу.** Иногда что-то идёт не так, и нужно быстро вернуться к предыдущей версии. Откат по Git-тегу или Helm-релизу — это как кнопка «отмена» в вашей тачке. Нажал — и вернулся к тому состоянию, которое было раньше.\n\nТак что, пацаны, помните: CI/CD — это не просто набор инструментов, это философия. Философия быстрой и безопасной доставки ценности. И если вы будете следовать этим принципам, то сможете избежать многих проблем.\n\n#CI/CD #безопасность #разработка #DevOps #программирование\n\n**Советы:**\n* не пренебрегайте безопасностью — лучше потратить время на проверку кода, чем потом разбираться с последствиями утечки данных;\n* используйте проверенные инструменты — не изобретайте велосипед, пользуйтесь тем, что уже зарекомендовало себя;\n* тестируйте в условиях, максимально приближённых к реальным — так вы сможете выявить большинство проблем ещё до того, как они появятся в production;\n* не давайте больше прав, чем нужно — это как с ключами от тачки: чем меньше людей знает, где они лежат, тем лучше.",
      "questions": [
        {
          "text": "Что такое SAST?",
          "options": [
            "Сканирование образов",
            "Статический анализ кода на уязвимости",
            "Тестирование нагрузки",
            "Балансировка трафик"
          ],
          "correct": 1
        },
        {
          "text": "Какой подход использует Git как единственный источник истины для деплоя?",
          "options": [
            "CI/CD",
            "GitOps",
            "DevSecOps",
            "Trunk-based"
          ],
          "correct": 1
        },
        {
          "text": "Где НЕЛЬЗЯ хранить секреты (пароли, ключи)?",
          "options": [
            "В Secrets репозитория",
            "В переменных окружения CI",
            "В исходном коде",
            "В HashiCorp Vault"
          ],
          "correct": 2
        }
      ]
    },
    {
      "title": "Итоговый тест: CI/CD (Junior)",
      "content": "**Рик говорит: «Финальный тест по CI/CD? Пф, раз плюнуть!»**\n\nСлушай сюда, малой, CI/CD — это тебе не шутки. Я, Рик, знаю об этом побольше твоего. Так что слушай внимательно, а то ещё запутаешься в своих пайплайнах, как в лабиринте.\n\nИтак, CI/CD — это про то, как автоматизировать сборку, тестирование и деплой твоего кода. Представь, что ты повар, а код — это ингредиенты. Ты же не будешь кидать всё в кастрюлю как попало, правда? Ты будешь следовать рецепту, чтобы в итоге получить вкусное блюдо. Вот и в программировании так же: нужно чётко следовать процессу, чтобы твой продукт работал как надо.\n\nОсновы CI/CD — это как таблица умножения в математике. Без них никуда. Ты должен понимать, как работает непрерывная интеграция (CI) и непрерывная доставка (CD). CI — это когда твой код постоянно проверяется и интегрируется в общий репозиторий, а CD — это когда после успешной интеграции код автоматически доставляется до конечного пользователя.\n\nGit — это твоя верная шпага в мире программирования. С его помощью ты можешь отслеживать изменения в коде, работать в команде и не бояться потерять свои изменения. Представь, что ты пишешь великий роман, и каждый раз, когда ты сохраняешь изменения, они записываются в особую книгу. Так и с Git — ты можешь вернуться к любой версии своего кода, если что-то пошло не так.\n\nПайплайны в CI/CD — это как конвейер на заводе. Ты настраиваешь этапы, через которые проходит твой код: сборка, тестирование, анализ и так далее. И всё это происходит автоматически, без твоего участия (ну, почти без участия). Ты просто задаёшь правила, а система всё делает за тебя. Удобно, правда?\n\nДеплой — это финальный аккорд в твоей симфонии программирования. Это процесс развёртывания твоего приложения на сервере или в облаке. Представь, что ты готовишь крутую игру и наконец-то выпускаешь её в свет. Вот это и есть деплой. Только не забывай про безопасность — ты же не хочешь, чтобы кто-то взломал твоё приложение и украл все данные?\n\nБезопасность в CI/CD — это как личная охрана для твоего кода. Ты должен защищать свои репозитории, пайплайны и конечные приложения от злоумышленников. Используй шифрование, аутентификацию, контроль доступа — всё, что поможет обезопасить твой код.\n\nТак что, малой, готовься к тесту по CI/CD. Если усвоишь эти основы, то считай, что полдела уже сделано. А если что-то будет непонятно — обращайся к Рику, я всегда готов помочь (ну, почти всегда).\n\n#CI/CD #программирование #тестирование #деплой #безопасность #Git #пайплайны\n\n**Советы от Рика:**\n1. Не бойся экспериментировать с CI/CD — практика лучший учитель.\n2. Изучай документацию и примеры — там много полезной инфы.\n3. Используй готовые инструменты и сервисы — не изобретай велосипед.\n4. Не забывай про безопасность — лучше перестраховаться, чем потом разбираться с последствиями взлома.\n5. И помни, малой, программирование — это искусство, так что не теряй чувство юмора и не воспринимай всё слишком серьёзно!",
      "questions": [
        {
          "text": "Что такое CI/CD?",
          "options": [
            "Система мониторинга",
            "Практика автоматизации сборки, тестов и деплоя",
            "Тип виртуальной машины",
            "Протокол передачи данных"
          ],
          "correct": 1
        },
        {
          "text": "Когда запускается CI pipeline в идеальном сценарии?",
          "options": [
            "Раз в неделю",
            "При ручной команде",
            "При каждом коммите в Git",
            "Только в продакшене"
          ],
          "correct": 2
        },
        {
          "text": "Где в GitHub хранится конфигурация Actions?",
          "options": [
            ".gitlab-ci.yml",
            ".github/workflows/",
            "Jenkinsfile",
            "/ci/"
          ],
          "correct": 1
        },
        {
          "text": "Что такое артефакт в CI/CD?",
          "options": [
            "Исходный код",
            "Результат сборки (например, Docker-образ)",
            "Git-ветка",
            "Лог ошибки"
          ],
          "correct": 1
        },
        {
          "text": "Какой стратегией деплоя K8s использует по умолчанию?",
          "options": [
            "Blue/Green",
            "Canary",
            "Rolling update",
            "Recreate"
          ],
          "correct": 2
        },
        {
          "text": "Почему важно не использовать latest-тег для образов?",
          "options": [
            "Он медленнее",
            "Он нарушает воспроизводимость и стабильность",
            "Он не поддерживается",
            "Он занимает больше места"
          ],
          "correct": 1
        },
        {
          "text": "Как безопасно передать API-ключ в pipeline?",
          "options": [
            "Закодировать в base64 в коде",
            "Использовать Secrets в настройках репозитория",
            "Написать в README",
            "Передать через коммит"
          ],
          "correct": 1
        },
        {
          "text": "Что такое trunk-based development?",
          "options": [
            "Работа в долгоживущих ветках",
            "Частые коммиты в main/trunk",
            "Использование только тегов",
            "Отказ от Git"
          ],
          "correct": 1
        },
        {
          "text": "Какой инструмент относится к GitOps?",
          "options": [
            "Jenkins",
            "GitHub Actions",
            "ArgoCD",
            "Prometheus"
          ],
          "correct": 2
        },
        {
          "text": "Что делает SAST-инструмент?",
          "options": [
            "Сканирует образы",
            "Анализирует исходный код на уязвимости",
            "Тестирует производительность",
            "Балансирует нагрузку"
          ],
          "correct": 1
        },
        {
          "text": "Какая стратегия деплоя позволяет быстро откатиться, протестировав на части пользователей?",
          "options": [
            "Rolling",
            "Blue/Green",
            "Canary",
            "Recreate"
          ],
          "correct": 2
        },
        {
          "text": "Где в GitLab CI описывается pipeline?",
          "options": [
            ".github/workflows/ci.yml",
            ".gitlab-ci.yml",
            "Makefile",
            "Dockerfile"
          ],
          "correct": 1
        },
        {
          "text": "Что такое Continuous Deployment?",
          "options": [
            "Ручной релиз после тестов",
            "Автоматический деплой в продакшен после прохождения тестов",
            "Только сборка кода",
            "Только запуск тестов"
          ],
          "correct": 1
        },
        {
          "text": "Какой принцип CI/CD помогает избежать 'integration hell'?",
          "options": [
            "Редкие коммиты",
            "Частая интеграция и тестирование",
            "Использование только main-ветки",
            "Отказ от тестов"
          ],
          "correct": 1
        },
        {
          "text": "Что такое runner в CI/CD?",
          "options": [
            "Автор пайплайна",
            "Машина, на которой выполняются задачи",
            "Тип артефакта",
            "Сервис мониторинга"
          ],
          "correct": 1
        }
      ]
    }
  ],
  "monitoring": [
    {
      "title": "Основы мониторинга: Observability и её три кита",
      "content": "**Рик говорит: «Observability? Пфф, раз плюнуть!»**\n\nСлушай сюда, пацан, я тебе объясню, что такое observability, или, по-нашему, «наблюдаемость». Это как когда ты смотришь на свой крутой корабль и по внешним признакам понимаешь, что там у него внутри происходит. Ну, типа, если из трубы дым валит — значит, движок работает, а если не валит — пора проверять, что там сломалось.\n\nТак вот, observability — это способность понять, что творится внутри какой-нибудь системы, по её внешним сигналам. И тут есть три главных кита, заруби себе на носу:\n\n1. **Метрики.** Это такие числовые данные, которые меняются со временем. Например, сколько у тебя там CPU загружено, сколько памяти занято, сколько запросов прилетает. Представь, что это как показатели твоего космического корабля: скорость, высота, уровень топлива. Если что-то из этого уходит в красную зону — значит, пора принимать меры.\n\n2. **Логи.** Это текстовые записи о том, что происходит в системе. Ну, типа, если у тебя в корабле что-то сломалось, ты смотришь логи и видишь: «ошибка в двигателе», «перегрев в системе охлаждения» и так далее. В IT это как записи об ошибках, о запросах — всё, что помогает понять, что происходит в системе.\n\n3. **Трейсы.** Это цепочки вызовов в распределённой системе. Представляешь, у тебя есть целая сеть микросервисов, и запрос должен пройти через них все. Трейсы показывают, как запрос путешествует по этой сети, где он задерживается, где всё ок, а где — бац! — проблема. Это как если бы ты отслеживал путь посылки через всю галактику, чтобы понять, где она застряла.\n\nА теперь про мониторинг. Это когда ты собираешь и анализируешь все эти метрики, логи и трейсы, чтобы вовремя заметить проблемы. Пока пользователи не начали звонить и орать: «У вас всё сломалось!» Ты как капитан корабля постоянно проверяешь все системы, чтобы не допустить катастрофы.\n\nЕщё есть такая штука — health-checks (liveness/readiness). Это часть мониторинга, которая говорит оркестратору (например, K8s), жив ли твой приложение и готово ли оно принимать трафик. Представь, что это как медицинский осмотр перед полётом: если всё ок — летим, если нет — чиним.\n\n**Хэштеги:****Советы от Рика:**\n* не пренебрегай мониторингом — лучше заметить проблему заранее, чем потом разбираться с последствиями;\n* учись читать логи — это как читать мысли системы;\n* не забывай про трейсы — они помогут понять, как запрос путешествует по системе и где он может застрять;\n* используй health-checks, чтобы быть уверенным, что твоё приложение в строю и готово к работе.\n\nКороче, пацан, observability — это не просто модное слово, это необходимость. Если хочешь, чтобы твоя система работала как часы, учись понимать её состояние по внешним сигналам. И помни: в космосе нет места для ошибок!",
      "questions": [
        {
          "text": "Какие три компонента составляют observability?",
          "options": [
            "CPU, RAM, Disk",
            "Метрики, логи, трейсы",
            "HTTP, TCP, ICMP",
            "Pods, Services, Deployments"
          ],
          "correct": 1
        },
        {
          "text": "Что такое liveness probe в Kubernetes?",
          "options": [
            "Проверка готовности к трафику",
            "Проверка, живо ли приложение (перезапуск при сбое)",
            "Сбор логов",
            "Измерение latency"
          ],
          "correct": 1
        },
        {
          "text": "Зачем нужен readiness probe?",
          "options": [
            "Для перезапуска пода",
            "Чтобы Kubernetes не отправлял трафик, пока приложение не готово",
            "Для сбора метрик CPU",
            "Для резервного копирования"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Prometheus: сбор и хранение метрик",
      "content": "**Рик говорит: «Прометей? Пф, детский лепет!»****Хэштеги:** #Прометей #мониторинг #метрики #Kubernetes #PromQL #экспортеры\n\n**Советы от Рика:**\n1. Не бойся сложных систем — в них всегда можно разобраться, если приложить немного усилий (и, возможно, пару бутылок межгалактического эликсира).\n2. Используй мощные инструменты — они экономят время и силы.\n3. Не забывай про документацию — иногда там можно найти ответы на все вопросы (если, конечно, ты сможешь её понять).\n4. И главное — не будь как Морти, который вечно влипает в неприятности! Будь как Рик — крутым и всезнающим!",
      "questions": [
        {
          "text": "Как работает Prometheus?",
          "options": [
            "Push-модель (приложение отправляет метрики)",
            "Pull-модель (Prometheus опрашивает эндпоинты)",
            "Через логи",
            "Только в облаке"
          ],
          "correct": 1
        },
        {
          "text": "Какой эндпоинт использует Prometheus для сбора метрик?",
          "options": [
            "/health",
            "/logs",
            "/metrics",
            "/status"
          ],
          "correct": 2
        },
        {
          "text": "Какой инструмент собирает метрики с Linux-хоста для Prometheus?",
          "options": [
            "Filebeat",
            "node_exporter",
            "Loki",
            "Alertmanager"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Grafana: визуализация данных",
      "content": "**Рик говорит: «Grafana? Пф-ф, раз плюнуть!»**\n\nСлушай сюда, малой, я тебе щас объясню, что такое Grafana. Только не вздумай засыпать — тема серьёзная!\n\nКороче, представь себе: ты сидишь в своём уютном кресле, а перед тобой — огромный экран, на котором отображается вся информация о твоей инфраструктуре и приложениях. И не просто отображается, а в удобном и понятном виде. Вот это и есть Grafana — платформа, которая поможет тебе визуализировать все эти метрики, логи и трейсы.\n\nКак она работает? Да проще пареной репы! Grafana подключается к разным источникам данных — например, к Prometheus, Loki или Elasticsearch. И что она делает дальше? Она берёт всю эту кучу информации и превращает её в красивые дашборды. Дашборды — это такие экраны с панелями, где всё наглядно показано: графики, таблицы, статусные индикаторы — всё, что душе угодно!\n\nИ вот тут начинается самое интересное. С помощью Grafana ты можешь строить сложные визуализации — то есть представлять данные так, как тебе удобно. Например, ты можешь задать переменные, чтобы выбирать конкретную ноду, или настроить аннотации, чтобы отмечать деплои и инциденты. Это как если бы ты мог настроить свой собственный космический корабль — всё под свои нужды!\n\nА в DevOps Grafana — это вообще стандарт де-факто. Там без неё никуда! Она позволяет в реальном времени отслеживать состояние инфраструктуры и приложений. Так что если ты работаешь в DevOps, то Grafana тебе просто необходима.\n\nКороче, малой, Grafana — это твой лучший друг в мире IT. С ней ты сможешь быстро находить проблемы, отслеживать изменения и просто держать руку на пульсе своей системы. Так что изучай, осваивай — и вперёд, покорять IT-мир!\n\n#Grafana #DevOps #визуализацияданных #IT #технологии\n\n**Совет от Рика:** не бойся сложных инструментов — с правильным подходом они станут твоими верными помощниками. И помни: в мире технологий нет ничего невозможного, если у тебя есть достаточно ума и смелости (и, конечно, немного безумия — без него в нашем деле никуда)!",
      "questions": [
        {
          "text": "Какой источник данных чаще всего используется с Grafana для метрик?",
          "options": [
            "Loki",
            "Prometheus",
            "Filebeat",
            "Kibana"
          ],
          "correct": 1
        },
        {
          "text": "Что такое дашборд в Grafana?",
          "options": [
            "Скрипт для сбора метрик",
            "Веб-интерфейс для визуализации данных",
            "Тип алерта",
            "Экспортёр"
          ],
          "correct": 1
        },
        {
          "text": "Можно ли в Grafana отображать логи и метрики на одном дашборде?",
          "options": [
            "Нет, только метрики",
            "Да, если настроены соответствующие источники",
            "Только через Kibana",
            "Это невозможно по архитектуре"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Алертинг: Alertmanager и реакция на инциденты",
      "content": "**Рик говорит: «Эй, пацан, давай разберёмся с этой ерундой с алертингом!»**\n\nСлушай сюда, малой, я тут покопался в этой вашей экосистеме Prometheus и понял, как всё работает. Так что слушай внимательно, а то запутаешься!\n\nИтак, алертинг — это такая система, которая тебе сигналит, когда что-то пошло не так. Типа как сигнализация в тачке, только для серверов и всего такого. В Prometheus за это отвечает чувачок по имени Alertmanager.\n\nКороче, в Prometheus ты задаёшь правила, когда надо слать алерт. Например, говоришь ему: «Если загрузка CPU больше 90 % и держится так пять минут, то кидай алерт». Понял? Prometheus, значит, видит, что что-то не так, и шлёт сигнал в Alertmanager. А тот уже умный, он не просто шлёт уведомления, а ещё и разбирается в них: убирает повторы (это называется дедуплицирует), группирует похожие алертсы и потом уже отправляет уведомления куда надо — в Slack, по email, в PagerDuty и так далее.\n\nНо вот что я тебе скажу, пацан: алертсы должны быть такими, чтобы ты мог сразу что-то сделать, понял? Не надо слать уведомления по каждому чиху, а то люди просто перестанут на них реагировать — это называется «alert fatigue», усталость от алертов. Ну типа если тебе будут звонить каждые пять минут и говорить «у тебя пылинка на столе», ты ж перестанешь обращать внимание, да?\n\nВот пример толкового алерта: «HTTP-ошибки 5xx больше 1 % за пять минут». Это уже серьёзно, это значит, что у тебя где-то что-то реально клинит, и надо разбираться. А вот если бы алерт срабатывал при каждой мелкой ошибочке, то ты бы только и делал, что разбирался с этими уведомлениями, и не успел бы заняться делом.\n\n**Советы от Рика:**\n1. Не увлекайся кучей алертов — выбирай только самые важные.\n2. Проверяй, чтобы алерт давал возможность быстро принять меры.\n3. Думай как пользователь — если тебе самому будет лень реагировать на алерт, значит, он бесполезный.\n\n#алертинг #prometheus #alertmanager #IT #мониторинг #алерты #советы\n\nНу что, пацан, теперь ты в теме! Если что, обращайся, я всегда помогу разобраться в этой вашей IT-херне!",
      "questions": [
        {
          "text": "Какой компонент отвечает за отправку уведомлений в экосистеме Prometheus?",
          "options": [
            "Grafana",
            "node_exporter",
            "Alertmanager",
            "kube-state-metrics"
          ],
          "correct": 2
        },
        {
          "text": "Где задаются правила алертов?",
          "options": [
            "В Alertmanager",
            "В Grafana",
            "В Prometheus",
            "В самом приложении"
          ],
          "correct": 2
        },
        {
          "text": "Что такое 'alert fatigue'?",
          "options": [
            "Усталость от большого количества бесполезных алертов",
            "Сбой в Alertmanager",
            "Задержка уведомлений",
            "Ошибка в PromQL"
          ],
          "correct": 0
        }
      ]
    },
    {
      "title": "Логи: от сбора до анализа",
      "content": "**Рик говорит: «О, логи в Kubernetes? Плёвое дело, внучок!»**\n\nСлушай сюда, пацанва! Разберёмся, что такое логи и как с ними обращаться в этом вашем Kubernetes. Логи — это, по сути, дневничок приложения или системы, где записываются все события. Ну, типа как я записываю все свои гениальные идеи и приключения в блокноте, только тут всё автоматизировано.\n\nВ Kubernetes логи часто собирают с помощью sidecar-контейнеров или демонсетов. Что это такое? Да просто дополнительные контейнеры или сервисы, которые сидят рядом с твоим основным приложением и собирают всю нужную инфу. Например, Fluentd или Fluent Bit — вот такие ребята и занимаются сбором логов.\n\nЕсть несколько популярных стеков для работы с логами. Один из них — ELK. Это такая троица: Elasticsearch, Logstash и Kibana. Elasticsearch — для поиска и хранения данных, Logstash — для обработки логов, а Kibana — для визуализации. Ещё есть EFK — тут вместо Logstash используется Fluentd. По сути, та же фигня, только с небольшими отличиями.\n\nА если тебе нужна более лёгкая альтернатива, глянь на Grafana Loki. Этот парень хранит логи без полного индексирования, поэтому выходит дешевле. И с Grafana он дружит, так что визуализировать данные будет проще простого. А для работы с Loki есть свой язык запросов — LogQL. Запоминай, пацан, это может пригодиться!\n\nЕщё один важный момент — структурированные логи, например, в формате JSON. Их гораздо проще парсить и фильтровать, чем обычные текстовые. Представь, что ты ищешь конкретную идею в моём блокноте — если всё будет разложено по полочкам, дело пойдёт быстрее и проще.\n\nИ вот ещё что, не храни все логи вечно. Задай политику ретеншена — это значит, определи, сколько времени ты будешь хранить данные. Например, 7 дней — вполне нормальный срок. После этого можно смело удалять старые логи, чтобы не захламлять систему.\n\n**Хэштеги:** #Kubernetes #Логи #ELK #EFK #GrafanaLoki #LogQL #JSON #Ретеншен\n\n**Советы от Рика:**\n1. Всегда используй структурированные логи — это сэкономит тебе кучу времени.\n2. Не храни логи вечно — задай разумный срок ретеншена.\n3. Изучай разные инструменты для работы с логами — у каждого свои фишки.\n4. Интегрируй системы визуализации — так ты сможешь быстрее анализировать данные.\n5. И помни, пацан, в мире IT без логов — как без рук!",
      "questions": [
        {
          "text": "Какой стек включает Elasticsearch, Fluentd и Kibana?",
          "options": [
            "ELK",
            "EFK",
            "PLG",
            "GEL"
          ],
          "correct": 1
        },
        {
          "text": "Какой инструмент является лёгкой альтернативой ELK для логов?",
          "options": [
            "Prometheus",
            "Loki",
            "Alertmanager",
            "cadvisor"
          ],
          "correct": 1
        },
        {
          "text": "Почему структурированные логи (JSON) лучше?",
          "options": [
            "Они занимают меньше места",
            "Их проще парсить и фильтровать",
            "Они шифруются автоматически",
            "Они не требуют сбора"
          ],
          "correct": 1
        }
      ]
    },
    {
      "title": "Итоговый тест: Мониторинг (Junior)",
      "content": "**Рик говорит: «Мониторинг? Пфф, детская игра!»**\n\nСлушай сюда, пацанва! Сейчас я вам расскажу, что такое этот ваш мониторинг и почему это просто раз плюнуть для такого гения, как я.\n\nИтак, мониторинг — это когда ты следишь за тем, как работает твоя система, чтобы сразу заметить, если что-то пойдёт не так. Ну, типа как я слежу за Морти, когда он в очередной раз вляпывается в неприятности. Только тут вместо Морти — сервера, приложения и прочая лабуда.\n\nObservability — это, по сути, возможность понять, что происходит внутри системы, не лазая туда с отверткой. То есть ты можешь посмотреть на кучу метрик и сразу увидеть: «О, тут что-то не так!» Это как когда я смотрю на Морти и сразу понимаю, что он опять что-то натворил, даже не спрашивая его.\n\nPrometheus — это такая штука, которая собирает все эти метрики. Представляете, она как мой универсальный пульт — может всё! Только вместо того, чтобы переключать каналы, она собирает данные о том, как работают сервера, приложения и всё остальное. А потом хранит их, чтобы можно было потом проанализировать.\n\nGrafana — это уже инструмент для визуализации данных. То есть Prometheus собирает данные, а Grafana их красиво рисует, чтобы человеку было понятно. Это как когда я объясняю Морти что-то сложное, но делаю это так, чтобы даже он понял. Только тут вместо Морти — системные администраторы, а вместо моих объяснений — красивые графики и дашборды.\n\nАлертинг — это система оповещений. То есть когда что-то идёт не так, тебе приходит уведомление: «Эй, глянь сюда!» Это как когда Морти вляпывается в неприятности, и я получаю сигнал: «Пора спасать этого идиота!» Только тут вместо Морти — сбой в системе, а вместо меня — системный администратор, который должен всё исправить.\n\nЛоги — это записи о том, что происходило в системе. Они как история браузера, только для серверов и приложений. По ним можно понять, что происходило в системе, когда и почему что-то пошло не так. Это как когда я смотрю записи с камер наблюдения, чтобы понять, как Морти умудрился вляпаться в очередную передрягу.\n\nТак что этот ваш финальный тест по мониторингу — просто раз плюнуть для такого гения, как я! Главное — понимать основы, и тогда всё будет чики-пуки.\n\n#мониторинг #observability #prometheus #grafana #алертинг #логи #системныйадминистратор\n\n**Советы от Рика:**\n1. Не бойтесь сложных терминов — за ними часто скрываются простые идеи.\n2. Изучайте основы — без них вы как Морти без моего руководства: постоянно влипаете в неприятности.\n3. Практикуйтесь — чем больше вы будете работать с инструментами мониторинга, тем лучше их поймёте.\n4. Не забывайте о логике — часто проблема решается проще, чем кажется на первый взгляд.\n5. И помните: если что-то пошло не так, просто скажите: «Морти, ты опять что-то натворил?» — и начните расследование!",
      "questions": [
        {
          "text": "Что из перечисленного НЕ является частью observability?",
          "options": [
            "Метрики",
            "Логи",
            "Трейсы",
            "Бэкапы"
          ],
          "correct": 3
        },
        {
          "text": "Какой компонент собирает метрики с хостов для Prometheus?",
          "options": [
            "Grafana",
            "Alertmanager",
            "node_exporter",
            "Loki"
          ],
          "correct": 2
        },
        {
          "text": "Как Prometheus получает метрики от приложений?",
          "options": [
            "Приложение отправляет метрики (push)",
            "Prometheus опрашивает эндпоинт /metrics (pull)",
            "Через логи",
            "Через Kubernetes API"
          ],
          "correct": 1
        },
        {
          "text": "Какой инструмент визуализирует данные из Prometheus?",
          "options": [
            "Kibana",
            "Loki",
            "Grafana",
            "Elasticsearch"
          ],
          "correct": 2
        },
        {
          "text": "Что делает Alertmanager?",
          "options": [
            "Собирает метрики",
            "Хранит логи",
            "Отправляет уведомления об алертах",
            "Строит дашборды"
          ],
          "correct": 2
        },
        {
          "text": "Где задаются правила для создания алертов?",
          "options": [
            "В Grafana",
            "В Alertmanager",
            "В конфигурации Prometheus",
            "В самом приложении"
          ],
          "correct": 2
        },
        {
          "text": "Какой стек использует Fluentd вместо Logstash?",
          "options": [
            "ELK",
            "EFK",
            "PLG",
            "Loki-Grafana"
          ],
          "correct": 1
        },
        {
          "text": "Какой инструмент хранит логи и интегрируется с Grafana?",
          "options": [
            "Prometheus",
            "Loki",
            "node_exporter",
            "cadvisor"
          ],
          "correct": 1
        },
        {
          "text": "Что проверяет readiness probe в Kubernetes?",
          "options": [
            "Живо ли приложение",
            "Готово ли приложение принимать трафик",
            "Сколько памяти использует приложение",
            "Есть ли ошибки в логах"
          ],
          "correct": 1
        },
        {
          "text": "Какой язык запросов используется в Prometheus?",
          "options": [
            "SQL",
            "LogQL",
            "PromQL",
            "Elasticsearch DSL"
          ],
          "correct": 2
        },
        {
          "text": "Почему важно избегать 'alert fatigue'?",
          "options": [
            "Это замедляет Grafana",
            "Команда игнорирует важные алерты",
            "Это увеличивает стоимость хранения",
            "Это ломает Prometheus"
          ],
          "correct": 1
        },
        {
          "text": "Какой компонент Kubernetes предоставляет метрики о подах и нодах?",
          "options": [
            "kube-proxy",
            "kubelet",
            "kube-state-metrics",
            "coredns"
          ],
          "correct": 2
        },
        {
          "text": "Что такое дашборд в Grafana?",
          "options": [
            "Сервер для хранения логов",
            "Коллекция визуализаций на одной странице",
            "Правило для алертов",
            "Экспортёр метрик"
          ],
          "correct": 1
        },
        {
          "text": "Какой формат логов предпочтительнее для автоматического анализа?",
          "options": [
            "Plain text",
            "XML",
            "JSON",
            "CSV"
          ],
          "correct": 2
        },
        {
          "text": "Какой минимальный полезный алерт вы бы настроили для веб-сервиса?",
          "options": [
            "CPU > 50%",
            "Доступность /health = false",
            "Количество логов > 1000/мин",
            "Изменение версии образа"
          ],
          "correct": 1
        }
      ]
    }
  ]
}
