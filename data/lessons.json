{
"linux": [
{
"title": "Load Average: что это и как интерпримировать в реальных системах",
"content": "Load Average — одна из самых непонятых, но критически важных метрик в Linux. Это не процент загрузки CPU, а среднее количество процессов, находящихся в состоянии выполнения (R) или ожидающих ресурсов (D) за последние 1, 5 и 15 минут. Например, значение `900, 900, 900` на сервере с 1000 CPU может быть нормальным — если система действительно параллельно обрабатывает тысячу задач. Но на 4-ядерном сервере это катастрофа. Важно понимать: процессы в состоянии D (uninterruptible sleep) — например, ожидающие дискового I/O — тоже входят в load average, поэтому высокий показатель может означать не CPU-проблему, а I/O блокировку (медленный диск, NFS-лаг). Для диагностики используйте: `top` (колонка CPU — %us, %sy, %wa), `iostat -x 1` (показатель `%util` и `await`), `vmstat 1` (поле `r` — число процессов в runnable состоянии, `b` — в uninterruptible). DevOps-инженер должен уметь отличать «здоровую» нагрузку (много R-процессов на многопроцессорной системе) от «больной» (много D-процессов из-за проблем с диском). Также помните: load average не нормируется под количество ядер — это абсолютное число. Поэтому всегда смотрите в контексте аппаратуры.",
"questions": [
{
"text": "Текущая load average на сервере — 900, 900, 900. Сервер работает с незначительной потерей производительности. Как понять, нормально ли это?",
"options": ["Это всегда авария", "Нужно сравнить с количеством CPU — если их ~1000, то норма", "Load average не может быть больше 100", "Это означает, что сломан мониторинг"],
"correct": 1
},
{
"text": "Какой командой можно увидеть, сколько процессов в состоянии runnable (R)?",
"options": ["ps aux", "top", "vmstat", "iostat"],
"correct": 2
}
]
},
{
"title": "Swap: виртуальная память, swappiness и её влияние на производительность",
"content": "Swap — это механизм виртуальной памяти, позволяющий системе использовать диск как расширение оперативной памяти (RAM). Когда физической памяти не хватает, ядро Linux перемещает редко используемые страницы памяти из RAM на выделенный swap-раздел или файл. Это предотвращает аварийное завершение процессов (OOM Killer), но сильно замедляет работу — диск на порядки медленнее RAM. Поведение системы регулируется параметром `vm.swappiness` (0–100). Значение 60 (по умолчанию) означает, что ядро агрессивно будет использовать swap даже при наличии свободной RAM. Для баз данных (PostgreSQL, MySQL) рекомендуется ставить `swappiness=1`, чтобы минимизировать своппинг. Однако полное отключение swap опасно: при пике памяти OOM Killer может убить критический процесс. Swap также используется для гибернации (сохранение состояния RAM на диск при выключении). В контейнерных средах swap часто отключён — управление памятью возлагается на cgroups. Для диагностики используйте `free -h` (показывает swap usage), `vmstat 1` (поля `si` — swap in, `so` — swap out), `cat /proc/sys/vm/swappiness`. DevOps должен настраивать swappiness в зависимости от типа нагрузки: для stateful-сервисов — минимальный своп, для batch-обработки — можно выше.",
"questions": [
{
"text": "Почему полностью отключать swap может быть опасно?",
"options": ["Система не загрузится", "При нехватке памяти OOM Killer может убить важный процесс", "Диск перестанет работать", "Это нарушает POSIX"],
"correct": 1
},
{
"text": "Какой параметр ядра регулирует агрессивность использования swap?",
"options": ["vm.overcommit_memory", "vm.dirty_ratio", "vm.swappiness", "fs.file-max"],
"correct": 2
}
]
},
{
"title": "Процессы, файл /proc и статусы (R, S, D, Z): взгляд изнутри ядра",
"content": "Каждый запущенный процесс в Linux имеет уникальный идентификатор (PID) и хранит своё состояние в ядре. Информация о процессах доступна через виртуальную файловую систему /proc — она монтируется в RAM и предоставляет «окно» в структуры ядра. Например, `/proc/1234/status` содержит детали процесса с PID 1234: имя, память, UID, статус. Статус процесса (поле `State` в `/proc/PID/status`) может быть: R (running/runnable) — процесс использует CPU или в очереди; S (sleeping) — ожидает события (например, ввода); D (uninterruptible sleep) — ожидает I/O (не реагирует на сигналы!); Z (zombie) — завершился, но родитель не вызвал `wait()`; T (stopped) — приостановлен (например, `Ctrl+Z`). Знание этих статусов критично: процессы в состоянии D делают систему «неподконтрольной» (нельзя убить `kill -9`), а зомби — признак бага в родительском процессе. Для получения списка процессов используйте `ps aux` (вывод включает статус в колонке `STAT`), `top`, или напрямую читайте `/proc`. PID 1 — это всегда init-процесс (systemd или init), он «усыновляет» сирот (процессы, чей родитель умер). DevOps должен уметь анализировать /proc для диагностики утечек, зависаний и аномалий.",
"questions": [
{
"text": "Какой статус процесса означает «uninterruptible sleep»?",
"options": ["R", "S", "D", "Z"],
"correct": 2
},
{
"text": "Где хранится информация о процессах в Linux?",
"options": ["/etc/passwd", "/var/log", "/proc", "/sys"],
"correct": 2
}
]
},
{
"title": "Зомби и сироты: когда процессы не умирают до конца",
"content": "Когда процесс завершает работу, он не исчезает мгновенно. Он переходит в состояние зомби (Z) — его запись остаётся в таблице процессов, пока родительский процесс не вызовет системный вызов `wait()` или `waitpid()`, чтобы получить код завершения. Зомби не потребляют CPU или RAM (только слот в таблице процессов), но большое их количество может исчерпать PID-пространство. Процесс-сирота — это процесс, чей родитель завершился. В этом случае ядро передаёт его под управление PID 1 (systemd или init), который периодически вызывает `wait()`, поэтому сироты не становятся зомби. Зомби появляются только при некорректной реализации родителя (например, игнорирование SIGCHLD). Для диагностики: `ps aux | grep 'Z'`, или смотреть поле `STAT` в `top`. Убить зомби напрямую нельзя — нужно либо «разбудить» родителя, либо убить самого родителя (тогда зомби станет сиротой и будет убран PID 1). В контейнерах проблема усугубляется: если PID 1 — не init-система (а просто `nginx`), он не обрабатывает SIGCHLD, и все дочерние процессы становятся зомби. Поэтому в Docker-образах часто используют `tini` как init-процесс.",
"questions": [
{
"text": "Что такое зомби-процесс?",
"options": ["Процесс, потребляющий 100% CPU", "Завершённый процесс, чей родитель не вызвал wait()", "Процесс без родителя", "Процесс в состоянии D"],
"correct": 1
},
{
"text": "Почему в Docker-контейнерах часто возникают зомби?",
"options": ["Docker блокирует сигналы", "PID 1 в контейнере не обрабатывает SIGCHLD", "Ядро не поддерживает зомби в namespace", "Контейнеры не имеют /proc"],
"correct": 1
}
]
},
{
"title": "Файловые системы в Linux: ext4, XFS, Btrfs и особенности работы",
"content": "Файловая система (ФС) — это способ организации данных на диске. В Linux наиболее распространены ext4 (стабильная, журналируемая, поддержка до 1 ЭБ), XFS (высокая производительность с большими файлами, используется в RHEL), и Btrfs (copy-on-write, снапшоты, но сложнее). Ключевое понятие — inode (index node). Это структура, хранящая метаданные файла: права, владельца, временные метки, указатели на блоки данных. Имя файла хранится не в inode, а в директории — директория — это просто список «имя → inode». Поэтому жёсткая ссылка (hard link) — это ещё одно имя, указывающее на тот же inode. Удаление файла — это уменьшение счётчика ссылок; данные удаляются, когда счётчик = 0. Проблема «no space left on device» при наличии свободного места часто вызвана исчерпанием inodes (проверяется `df -i`). ext4 имеет фиксированное число inodes при создании ФС, тогда как XFS и Btrfs поддерживают динамические inodes. Для диагностики: `df -h` (место), `df -i` (inodes), `du -sh /path` (реальный размер файлов). DevOps должен выбирать ФС под задачу: ext4 — для универсального использования, XFS — для больших файлов (базы, логи), Btrfs — для снапшотов (но с осторожностью в продакшене).",
"questions": [
{
"text": "При создании файла система возвращает ошибку 'no space left on device', но df показывает свободное место. В чём причина?",
"options": ["Сломан диск", "Закончились inodes", "Нет прав на запись", "ФС не смонтирована"],
"correct": 1
},
{
"text": "Где хранится информация об именах файлов?",
"options": ["В inode", "В суперблоке", "В директории", "В журнале ФС"],
"correct": 2
}
]
},
{
"title": "Жёсткие и символьные ссылки: различия, применение и ограничения",
"content": "В Linux существует два типа ссылок: жёсткие (hard links) и символьные (symbolic или soft links). Жёсткая ссылка — это новое имя для существующего inode. Все жёсткие ссылки равноправны: удаление одного имени не влияет на другие, пока счётчик ссылок > 0. Жёсткие ссылки не могут указывать на каталоги (только файлы) и не работают между разными ФС. Символьная ссылка — это отдельный файл, содержащий путь к целевому файлу/директории. Если целевой файл удалён, symlink становится «битым». Symlinks работают между ФС и могут указывать на каталоги. Создание: `ln file hardlink` (жёсткая), `ln -s target symlink` (символьная). Проверка: `ls -l` — symlinks помечены как `lrwxrwxrwx` и показывают «-> цель», жёсткие ссылки выглядят как обычные файлы, но `ls -i` покажет одинаковый inode. Для DevOps: жёсткие ссылки полезны для экономии места (например, в пакетных менеджерах), symlinks — для гибкой организации путей (например, `/usr/bin/python -> python3.11`). Однако в скриптах нужно учитывать: `cp` по умолчанию копирует файл, на который ссылается symlink, а не сам symlink — используйте `cp -P` для сохранения ссылки.",
"questions": [
{
"text": "В чём разница между жёсткой и символьной ссылкой?",
"options": ["Жёсткая ссылка — это путь к файлу, символьная — inode", "Жёсткая ссылка указывает на inode, символьная — на путь", "Символьная ссылка не может быть удалена", "Жёсткая ссылка работает между ФС, символьная — нет"],
"correct": 1
},
{
"text": "Какой командой создаётся символьная ссылка?",
"options": ["ln file link", "link file link", "ln -s target link", "symlink target link"],
"correct": 2
}
]
},
{
"title": "Процесс загрузки Linux: от кнопки питания до пользовательской сессии",
"content": "Загрузка Linux — это многоэтапный процесс, начинающийся с аппаратного уровня. При включении питания процессор выполняет сброс и запускает код из прошивки: BIOS (устаревший) или UEFI (современный). BIOS инициализирует железо, ищет MBR (первые 512 байт диска) и запускает загрузчик (например, GRUB Stage 1). UEFI использует FAT32-раздел (ESP) и запускает EFI-приложение (grubx64.efi). GRUB 2 загружает конфигурацию, показывает меню и загружает ядро (vmlinuz) и initramfs — временный RAM-диск с драйверами для монтирования корневой ФС (особенно с LVM, RAID, шифрованием). Ядро распаковывает initramfs, монтирует корневую ФС и запускает init-процесс (PID 1). Исторически это был SysVinit, сегодня — systemd. Systemd параллельно стартует сервисы, настраивает сеть, запускает GUI. Каждый этап критичен: ошибка в initramfs — система не загрузится, проблема в systemd — сервисы не стартанут. DevOps должен уметь: диагностировать зависание на этапе initramfs (добавить драйверы в образ), настраивать безопасную загрузку (Secure Boot), создавать cloud-init образы или iPXE-скрипты для bare-metal развёртывания.",
"questions": [
{
"text": "Какой компонент загружается до монтирования корневой ФС?",
"options": ["GRUB", "systemd", "initramfs", "ядро"],
"correct": 2
},
{
"text": "Что делает initramfs?",
"options": ["Управляет сервисами", "Содержит драйверы для монтирования корневой ФС", "Это альтернатива ядру", "Хранит пользовательские данные"],
"correct": 1
}
]
},
{
"title": "Дисковый I/O, iowait и диагностика проблем с производительностью",
"content": "Когда приложение работает медленно, первая мысль — CPU. Но часто виновник — дисковый I/O. Показатель iowait в утилитах (`top`, `vmstat`) — это процент времени, которое CPU простаивал, ожидая завершения операций ввода-вывода. Высокий iowait означает, что процессы простаивают в состоянии D (uninterruptible sleep), ожидая диск. Это может быть вызвано: медленным HDD, перегруженным SSD, сетевым хранилищем (NFS, iSCSI) с лагами, или ошибками на диске. Для диагностики: `iostat -x 1` — смотрите `%util` (загрузка устройства), `await` (среднее время ожидания операции), `svctm` (время обслуживания). Значение `await > 20ms` на SSD — уже проблема. `iotop` покажет, какие процессы генерируют I/O. `dmesg` может содержать ошибки диска. В облаке высокий iowait часто связан с ограничениями burst-баланса (AWS gp2/gp3). DevOps должен настраивать мониторинг iowait, использовать быстрые диски под базы и логи, а также проектировать архитектуру с учётом латентности хранилища. Помните: даже SSD имеет предел IOPS!",
"questions": [
{
"text": "Что означает высокий iowait?",
"options": ["CPU перегружен", "Процессы ожидают завершения операций ввода-вывода", "Сеть перегружена", "Закончилась память"],
"correct": 1
},
{
"text": "Какой командой посмотреть, какие процессы активно используют диск?",
"options": ["top", "vmstat", "iostat", "iotop"],
"correct": 3
}
]
},
{
"title": "Специальные переменные Bash: $@, $!, $?, $$ и их применение в скриптах",
"content": "Bash предоставляет множество специальных переменных для работы со скриптами. `$@` — все аргументы командной строки как отдельные слова (`\"$1\" \"$2\" ...`), в отличие от `$*`, который объединяет их в одну строку. `$!` — PID последнего фонового процесса, полезен для мониторинга или ожидания завершения (`wait $!`). `$?` — код возврата последней команды (0 — успех, неноль — ошибка), критичен для проверки результатов (`if [ $? -ne 0 ]; then ...`). `$$` — PID текущего shell-процесса, часто используется для создания уникальных временных файлов (`/tmp/script.$$`). Другие полезные: `$#` — число аргументов, `$0` — имя скрипта, `$_` — последний аргумент предыдущей команды. В DevOps-скриптах эти переменные незаменимы: `$@` для безопасной передачи аргументов в обёртку, `$!` для управления фоновыми задачами, `$?` для обработки ошибок. Неправильное использование `$*` вместо `$@` приведёт к ошибкам с аргументами, содержащими пробелы. Используйте `set -e` для аварийного завершения при ошибках, но помните, что `$?` всё равно нужно проверять в сложных цепочках.",
"questions": [
{
"text": "Какая переменная содержит PID последнего фонового процесса?",
"options": ["$$", "$@", "$!", "$?"],
"correct": 2
},
{
"text": "Чем отличается $@ от $*?",
"options": ["Ничем", "$@ объединяет аргументы в строку, $* — нет", "$@ сохраняет аргументы как отдельные слова, $* — объединяет", "$@ работает только в функциях"],
"correct": 2
}
]
},
{
"title": "Сигналы в Linux: SIGTERM, SIGKILL, обработка и перехват",
"content": "Сигналы — это механизм межпроцессного взаимодействия, позволяющий уведомить процесс о событии. `SIGTERM` (15) — запрос на корректное завершение: процесс может обработать его, сохранить данные, закрыть соединения. `SIGKILL` (9) — немедленное убийство, которое нельзя перехватить или проигнорировать. `SIGINT` (2) — отправляется при `Ctrl+C`, обычно эквивалентен SIGTERM. `SIGHUP` (1) — исторически «hang up», сейчас часто используется для перезагрузки конфигурации (nginx, sshd). Процессы могут обрабатывать сигналы через обработчики (signal handlers), но `SIGKILL` и `SIGSTOP` — нельзя. Для диагностики: `kill -l` — список сигналов, `strace -p PID` — показывает полученные сигналы. В скриптах используйте `trap 'cleanup' TERM` для корректного завершения. В контейнерах критично: если PID 1 не обрабатывает SIGTERM, Docker не сможет graceful shutdown. Пример: Java-приложения часто требуют специальной обработки сигналов через `-XX:+UseContainerSupport`. DevOps должен тестировать graceful shutdown своих сервисов и настраивать таймауты в оркестраторах (K8s: `terminationGracePeriodSeconds`).",
"questions": [
{
"text": "Какой сигнал получает процесс при нажатии Ctrl+C?",
"options": ["SIGKILL", "SIGTERM", "SIGINT", "SIGHUP"],
"correct": 2
},
{
"text": "Какие сигналы нельзя проигнорировать или перехватить?",
"options": ["SIGTERM и SIGINT", "SIGKILL и SIGSTOP", "SIGHUP и SIGUSR1", "Все сигналы можно обработать"],
"correct": 1
}
]
},
{
"title": "Права доступа, sudo и управление файловыми дескрипторами",
"content": "Права доступа в Linux основаны на триаде: владелец, группа, остальные, и правах: чтение (r), запись (w), выполнение (x). Команда `chmod 755` означает rwx для владельца, rx для группы и остальных. Для каталогов право x — разрешение на вход. sudo позволяет запускать команды от имени другого пользователя (по умолчанию root). Конфигурация — в `/etc/sudoers`, редактируется только через `visudo` (чтобы избежать синтаксических ошибок). Правила: `user host = (runas) command`. Например: `arstan ALL = (root) /usr/bin/systemctl restart nginx`. Для DevOps критично ограничивать права: не давать полный root, а только нужные команды. Файловые дескрипторы (FD) — целые числа, через которые процесс обращается к открытым файлам, сокетам, pipes. Утечка FD приводит к ошибке «too many open files». Диагностика: `lsof -p PID` — список FD процесса, `cat /proc/PID/limits` — лимиты, `sysctl fs.file-max` — системный лимит. Увеличение лимита: через `/etc/security/limits.conf`. DevOps должен мониторить FD в сервисах и настраивать лимиты под нагрузку.",
"questions": [
{
"text": "Приложение пишет в логи 'too many opened files'. Как диагностировать?",
"options": ["Проверить df -h", "Использовать lsof -p PID", "Перезагрузить сервер", "Установить больше RAM"],
"correct": 1
},
{
"text": "Какой командой правильно редактировать /etc/sudoers?",
"options": ["nano /etc/sudoers", "vim /etc/sudoers", "visudo", "sudoedit"],
"correct": 2
}
]
},
{
"title": "Docker и ядро Linux: namespaces, cgroups и copy-on-write",
"content": "Docker — не магия, а UX-обёртка над 20-летними технологиями ядра Linux. Основа контейнеризации — namespaces: изоляция процессов (PID), сети (NET), монтирования (MNT), пользователей (USER) и т.д. Каждый контейнер видит свой изолированный мир. cgroups (control groups) ограничивают и измеряют ресурсы: CPU, память, I/O. Без cgroups контейнер мог бы исчерпать всю память хоста. Union File Systems (overlay2, aufs) позволяют создавать слои образов: базовый слой (OS) + слой приложения. При запуске контейнера создаётся записываемый слой поверх read-only слоёв — это copy-on-write: изменения записываются только в новый слой. Образы — не «полные ОС», а архивы с файлами. При `docker run` ядро создаёт новые namespaces, ограничивает ресурсы через cgroups, монтирует слои через overlayfs и запускает процесс (часто без PID 1 как systemd!). DevOps должен понимать: контейнер — это процесс в изоляции, а не виртуальная машина. Безопасность достигается через правильные настройки namespaces, cgroups, seccomp, AppArmor. Знание этих технологий критично для отладки (почему сетевые правила не работают?) и проектирования.",
"questions": [
{
"text": "Какие ядерные технологии лежат в основе Docker?",
"options": ["Виртуализация CPU", "namespaces и cgroups", "Гипервизор KVM", "LXC только"],
"correct": 1
},
{
"text": "Что происходит при записи в файл внутри контейнера?",
"options": ["Файл перезаписывается в образе", "Создаётся копия в записываемом слое (copy-on-write)", "Запись идёт напрямую на хост", "Операция запрещена"],
"correct": 1
}
]
},
{
"title": "systemd: революция в управлении сервисами и её критика",
"content": "systemd, созданный Lennart Poettering в 2010 году, заменил SysVinit как init-систему по умолчанию. Главное преимущество — параллельный запуск сервисов на основе зависимостей, а не последовательный. Вместо скриптов `/etc/init.d/` используются юнит-файлы (`/etc/systemd/system/service.service`) — декларативные конфигурации. systemd предоставляет: journald (бинарные логи, привязанные к сервису), socket activation (запуск сервиса при подключении к сокету), автоматический рестарт, контроль через cgroups, таймеры (альтернатива cron). Плюсы: скорость, надёжность, унификация. Минусы: монолитность (нарушает UNIX-философию «делай одну вещь хорошо»), сложность отладки, зависимость от D-Bus. Однако факт: современный Linux без systemd — экзотика. Для DevOps systemd — стандарт: `systemctl start/enable/status`, `journalctl -u service`, `systemd-analyze blame` для диагностики загрузки. Умение писать юнит-файлы — must-have. Несмотря на критику, systemd решил реальные проблемы: race condition при старте, управление зависимостями, логирование. И да, именно systemd лег в основу cgroups v2 — будущего контейнеризации.",
"questions": [
{
"text": "Какая команда показывает логи конкретного сервиса в systemd?",
"options": ["cat /var/log/syslog", "journalctl -u nginx", "systemctl logs nginx", "tail /var/log/nginx"],
"correct": 1
},
{
"text": "Почему systemd критиковали в сообществе Linux?",
"options": ["Он слишком медленный", "Он нарушает UNIX-философию 'делай одну вещь хорошо'", "Он не поддерживает сетевые сервисы", "Он написан на Perl"],
"correct": 1
}
]
},
{
"title": "Диагностика проблем с диском: iowait, иноды и 'no space left'",
"content": "Классическая проблема: `df` показывает 20 ГБ занято, `du` — 20 МБ, но запись выдаёт «no space left on device». Причины: 1) Закончились inodes — проверьте `df -i`. ext4 выделяет фиксированное число inodes при создании ФС; если много мелких файлов — inodes исчерпаются раньше места. 2) Зарезервированное место для root — по умолчанию 5% диска недоступно обычным пользователям (настраивается `tune2fs -m`). 3) Открытый, но удалённый файл — если процесс держит дескриптор удалённого файла, место не освобождается до завершения процесса (найдите через `lsof +L1`). 4) Квоты — пользовательские или групповые. Для диагностики: `df -i`, `lsof +L1`, `tune2fs -l /dev/sda1 | grep 'Reserved'`, `quota -u user`. В облаке также проверяйте burst balance (AWS). DevOps должен мониторить не только свободное место, но и inodes, особенно на серверах с почтой или кэшем (много мелких файлов). Автоматические алерты на >80% inodes — must-have.",
"questions": [
{
"text": "Почему df и du могут показывать разный объём занятого места?",
"options": ["du не считает скрытые файлы", "Процесс держит удалённый файл", "df считает только ext4", "du работает медленнее"],
"correct": 1
},
{
"text": "Как проверить, не закончились ли inodes?",
"options": ["df -h", "du -sh", "df -i", "ls -i"],
"correct": 2
}
]
},
{
"title": "Память в Linux: физическая, виртуальная, OOM Killer и available",
"content": "Понимание памяти в Linux — ключ к стабильности. Физическая память (RAM) — быстрая, но ограниченная. Виртуальная память — адресное пространство процесса, отображаемое на RAM или swap. Команда `free` показывает: total — общая RAM, used — 'используемая' (но это вводит в заблуждение!), free — неиспользуемая, available — память, доступная для запуска новых приложений без своппинга (учитывает кэши, которые можно сбросить). Поэтому available > free — норма! Утечки памяти диагностируются через `top` (RES — физическая память процесса), `htop`, `smem`. При нехватке памяти OOM Killer (Out-Of-Memory Killer) убивает процесс с наибольшим `oom_score` (обычно самый прожорливый). Это аварийная мера — лучше настроить мониторинг и ограничения (cgroups). Для DevOps: никогда не ориентируйтесь на `used` в `free`, смотрите `available`. Настройте алерты на низкое `available`, а не на `free`. В контейнерах ограничения памяти задаются через cgroups, и OOM Killer сработает внутри контейнера.",
"questions": [
{
"text": "Почему available памяти больше free?",
"options": ["Потому что free не считает swap", "Потому что available включает кэши, которые можно освободить", "Это ошибка в ядре", "Available считает только RAM, free — RAM+swap"],
"correct": 1
},
{
"text": "Что делает OOM Killer?",
"options": ["Перезагружает сервер", "Убивает процесс при нехватке памяти", "Включает swap", "Блокирует новые процессы"],
"correct": 1
}
]
},
{
"title": "Сетевые и системные утилиты: netstat, ss, iptables, lsof",
"content": "Для диагностики сети в Linux есть мощные утилиты. netstat (устаревает) и ss (из iproute2, быстрее) показывают сетевые соединения, сокеты, маршруты. `ss -tuln` — слушающие TCP/UDP порты. lsof -i — процессы, использующие сеть. iptables — фильтрация пакетов на уровне ядра. Базовые правила: `-A INPUT -p tcp --dport 22 -j ACCEPT` (разрешить SSH), `-P INPUT DROP` (дефолтная политика DROP). В современных системах iptables часто заменён nftables. tcpdump и wireshark — захват и анализ трафика. Для DevOps критично: уметь найти, какой процесс слушает порт (`ss -tulnp`), проверить правила файрвола (`iptables -L -n -v`), диагностировать 502 ошибку (проверить, слушает ли бэкенд порт). Помните: `netstat` медленный на системах с тысячами соединений — используйте `ss`. Также настройте мониторинг открытых соединений.",
"questions": [
{
"text": "Какой командой посмотреть, какие порты слушает система?",
"options": ["ps aux", "netstat -tuln", "df -h", "free -h"],
"correct": 1
},
{
"text": "Какая утилита является современной заменой netstat?",
"options": ["ifconfig", "ip", "ss", "route"],
"correct": 2
}
]
},
{
"title": "Безопасность и мониторинг: chroot, SSH, syslog и инструменты",
"content": "Безопасность Linux начинается с базовых практик. chroot jail — смена корневой директории для процесса, изолируя его от основной ФС. Однако это не полноценная изоляция (привилегированный процесс может вырваться), поэтому сегодня используют контейнеры. SSH — защищённый удалённый доступ. Key-based authentication (публичный/приватный ключ) безопаснее паролей. Отключите вход по паролю: `PasswordAuthentication no` в `/etc/ssh/sshd_config`. sudo вместо root-логина. syslog — стандарт логирования; в systemd — journald. Логи обычно в `/var/log/`: `auth.log` (SSH, sudo), `syslog`, `kern.log`. Мониторинг: `top`/`htop` (процессы), `vmstat` (память, swap), `iostat` (диск), `netstat`/`ss` (сеть), `df`/`du` (диск). Для продвинутого мониторинга — Prometheus + Node Exporter. DevOps должен настраивать централизованное логирование (ELK, Loki), алерты на аномалии (CPU, память, диск), и регулярно обновлять систему (`apt upgrade`). Помните: безопасность — это процесс, а не продукт.",
"questions": [
{
"text": "Что такое chroot jail?",
"options": ["Полная виртуализация", "Смена корневой директории для изоляции процесса", "Шифрование диска", "Файрвол на уровне ядра"],
"correct": 1
},
{
"text": "Где обычно хранятся системные логи в Linux?",
"options": ["/etc/log", "/var/log", "/tmp/log", "/home/logs"],
"correct": 1
}
]
},
{
"title": "POSIX, PXE, LVM и разграничение userspace/kernelspace",
"content": "POSIX (Portable Operating System Interface) — стандарт IEEE, определяющий API для совместимости Unix-систем. Программы, написанные по POSIX, переносимы между Linux, BSD, macOS. PXE (Preboot eXecution Environment) — загрузка ОС по сети: BIOS/UEFI получает IP через DHCP, скачивает загрузчик через TFTP, затем ядро и initramfs по HTTP/NFS. Используется для массового развёртывания (MAAS, Foreman). LVM (Logical Volume Manager) — абстракция над дисками: Physical Volumes (диски/разделы) → Volume Group (пул) → Logical Volumes (гибкие тома, можно ресайзить онлайн). Даёт гибкость: добавляйте диски в VG, увеличивайте LV без остановки сервиса. Userspace vs kernelspace — фундаментальное разделение. Kernelspace — привилегированный режим ядра, управляет железом, памятью, процессами. Userspace — обычные приложения, изолированные, с ограниченным доступом. Взаимодействие — через системные вызовы (syscalls): `open()`, `read()`, `fork()`. Это обеспечивает стабильность: падение приложения не уронит ядро. Для DevOps: знание LVM нужно для гибкого управления дисками, PXE — для автоматизации, POSIX — для написания переносимых скриптов, а понимание userspace/kernelspace — для отладки производительности (syscalls — дорого!).",
"questions": [
{
"text": "Что такое POSIX?",
"options": ["Тип файловой системы", "Стандарт совместимости Unix-систем", "Протокол сетевой загрузки", "Менеджер логических томов"],
"correct": 1
},
{
"text": "Какие три абстракции использует LVM?",
"options": ["Disk, Partition, File", "Block, Sector, Cylinder", "Physical Volume, Volume Group, Logical Volume", "RAID0, RAID1, RAID5"],
"correct": 2
}
]
},
{
"title": "Итоговый тест: полная проверка знаний Linux",
"content": "Этот тест содержит ВСЕ 73 вопроса из вашего учебного материала. Он охватывает: загрузку, процессы, память, диск, файловые системы, bash, сигналы, безопасность, сеть и архитектуру ядра. Каждый раз вы получаете случайный вопрос из всего пула.",
"questions": [
{
"text": "Как посмотреть нагрузку на диски?",
"options": [
"iostat -x 1, iotop, vmstat 1",
"df -h",
"free -h",
"ps aux"
],
"correct": 0
},
{
"text": "Что означают поля bi и bo в vmstat?",
"options": [
"bi — блоки, полученные с диска (чтение); bo — блоки, отправленные на диск (запись)",
"bi — байты входящие, bo — байты исходящие",
"bi — буферы inodes, bo — блоки объектов",
"bi — background I/O, bo — blocked operations"
],
"correct": 0
},
{
"text": "Что такое $@ в bash?",
"options": [
"Все аргументы командной строки как отдельные слова",
"Статус последней команды",
"PID текущего процесса",
"PID последнего фонового процесса"
],
"correct": 0
},
{
"text": "Что такое $! в bash?",
"options": [
"PID последнего фонового процесса",
"Все аргументы",
"Статус последней команды",
"PID текущего shell"
],
"correct": 0
},
{
"text": "Что такое $? в bash?",
"options": [
"Статус завершения последней команды (0 — успех)",
"PID фонового процесса",
"Все аргументы",
"Текущий каталог"
],
"correct": 0
},
{
"text": "Что такое $$ в bash?",
"options": [
"PID текущего shell-процесса",
"Статус команды",
"Аргументы скрипта",
"Имя скрипта"
],
"correct": 0
},
{
"text": "Что такое load average?",
"options": [
"Среднее количество процессов в состоянии R или D за 1/5/15 минут",
"Процент загрузки CPU",
"Количество активных пользователей",
"Скорость диска в IOPS"
],
"correct": 0
},
{
"text": "Где посмотреть load average?",
"options": [
"uptime, top, cat /proc/loadavg, w",
"df -h",
"free -h",
"ls /proc"
],
"correct": 0
},
{
"text": "Что такое swap?",
"options": [
"Область на диске для расширения RAM при её нехватке",
"Тип файловой системы",
"Механизм сетевой балансировки",
"Кэш процессора"
],
"correct": 0
},
{
"text": "Для чего нужен swap?",
"options": [
"Резерв памяти, гибернация, оптимизация RAM",
"Ускорение загрузки системы",
"Шифрование данных",
"Создание резервных копий"
],
"correct": 0
},
{
"text": "Где хранится информация о процессах в Linux?",
"options": ["/proc", "/etc", "/var/log", "/sys"],
"correct": 0
},
{
"text": "Что такое процесс в Linux?",
"options": [
"Экземпляр выполняющейся программы с собственным адресным пространством",
"Файл на диске",
"Пользователь системы",
"Сетевое соединение"
],
"correct": 0
},
{
"text": "Какие статусы процессов бывают?",
"options": ["R, S, D, T, Z", "A, B, C, D", "1, 2, 3, 4", "RUN, STOP, KILL"],
"correct": 0
},
{
"text": "Что означает статус D у процесса?",
"options": [
"Uninterruptible sleep (ожидание I/O)",
"Зомби",
"Остановлен",
"Выполняется"
],
"correct": 0
},
{
"text": "Что такое зомби-процесс?",
"options": [
"Завершённый процесс, чей родитель не вызвал wait()",
"Процесс без родителя",
"Процесс с высоким потреблением CPU",
"Процесс в состоянии sleeping"
],
"correct": 0
},
{
"text": "Что такое процесс-сирота?",
"options": [
"Процесс, чей родитель завершился — усыновляется PID 1",
"Завершённый процесс",
"Процесс в состоянии D",
"Процесс без прав"
],
"correct": 0
},
{
"text": "Как создать файловую систему на блочном устройстве?",
"options": [
"mkfs.ext4 /dev/sdX1",
"mount /dev/sdX1",
"fdisk /dev/sdX",
"lsblk"
],
"correct": 0
},
{
"text": "В чём разница между hardlink и symlink?",
"options": [
"Hardlink указывает на inode, symlink — на путь",
"Hardlink работает между ФС, symlink — нет",
"Symlink не может быть удалён",
"Hardlink — это ярлык"
],
"correct": 0
},
{
"text": "Как создать жёсткую ссылку?",
"options": ["ln file link", "ln -s file link", "link file link", "cp -l file link"],
"correct": 0
},
{
"text": "Как создать символьную ссылку?",
"options": ["ln -s file link", "ln file link", "mklink file link", "symlink file link"],
"correct": 0
},
{
"text": "Опишите процесс загрузки Linux.",
"options": [
"BIOS/UEFI → GRUB → ядро + initramfs → init (PID 1) → сервисы",
"Ядро → GRUB → BIOS",
"GRUB → systemd → ядро",
"init → ядро → загрузчик"
],
"correct": 0
},
{
"text": "Что такое BIOS?",
"options": [
"16-битная прошивка с поддержкой MBR",
"Современная 64-битная прошивка",
"Тип файловой системы",
"Менеджер пакетов"
],
"correct": 0
},
{
"text": "Что такое UEFI?",
"options": [
"32/64-битная прошивка с GPT и Secure Boot",
"Устаревшая 16-битная прошивка",
"Сетевой протокол",
"Тип диска"
],
"correct": 0
},
{
"text": "Что такое systemd?",
"options": [
"Современная init-система с параллельным запуском сервисов",
"Тип файловой системы",
"Менеджер пакетов",
"Загрузчик"
],
"correct": 0
},
{
"text": "Чем systemd лучше init?",
"options": [
"Параллельный запуск, зависимости, логирование через journald",
"Меньше функций",
"Работает только в облаке",
"Не поддерживает сервисы"
],
"correct": 0
},
{
"text": "Как проверить, используется ли systemd?",
"options": ["ps -p 1 -o comm=", "ls /etc", "df -h", "free -h"],
"correct": 0
},
{
"text": "Что такое sudo?",
"options": [
"Команда для выполнения действий с правами другого пользователя",
"Менеджер пакетов",
"Тип файловой системы",
"Сетевой инструмент"
],
"correct": 0
},
{
"text": "Что такое Docker?",
"options": [
"Платформа контейнеризации на основе namespaces и cgroups",
"Гипервизор",
"Менеджер пакетов",
"Тип виртуальной машины"
],
"correct": 0
},
{
"text": "Какие ядерные технологии лежат в основе Docker?",
"options": ["namespaces, cgroups, UnionFS", "KVM, QEMU", "BIOS, UEFI", "ext4, XFS"],
"correct": 0
},
{
"text": "Что такое физическая память?",
"options": [
"RAM — быстрая энергозависимая память для активных данных",
"Swap на диске",
"Файловая система",
"Кэш процессора"
],
"correct": 0
},
{
"text": "Что такое виртуальная память?",
"options": [
"Механизм расширения RAM за счёт swap и изоляции процессов",
"Тип диска",
"Сетевой протокол",
"Файловая система"
],
"correct": 0
},
{
"text": "Что такое файловая система?",
"options": [
"Способ организации данных на диске: имена, права, структура",
"Тип процессора",
"Сетевой протокол",
"Менеджер пакетов"
],
"correct": 0
},
{
"text": "Что такое inode?",
"options": [
"Структура с метаданными файла: права, владелец, указатели на данные",
"Имя файла",
"Содержимое файла",
"Тип диска"
],
"correct": 0
},
{
"text": "Где хранятся имена файлов?",
"options": ["В директории", "В inode", "В суперблоке", "В ядре"],
"correct": 0
},
{
"text": "Почему может быть 'no space left on device', если место есть?",
"options": ["Закончились inodes", "Сломан диск", "Нет прав", "Ошибка в df"],
"correct": 0
},
{
"text": "Как проверить, не закончились ли inodes?",
"options": ["df -i", "df -h", "du -sh", "ls -l"],
"correct": 0
},
{
"text": "Что такое POSIX?",
"options": [
"Стандарт совместимости Unix-систем",
"Тип файловой системы",
"Сетевой протокол",
"Менеджер томов"
],
"correct": 0
},
{
"text": "Что такое PXE?",
"options": [
"Загрузка ОС по сети через DHCP + TFTP",
"Шифрование диска",
"Тип файловой системы",
"Менеджер пакетов"
],
"correct": 0
},
{
"text": "Что такое LVM?",
"options": [
"Logical Volume Manager: PV → VG → LV",
"Тип загрузчика",
"Сетевой протокол",
"Менеджер процессов"
],
"correct": 0
},
{
"text": "Что такое userspace и kernelspace?",
"options": [
"Kernelspace — привилегированный режим ядра, userspace — обычные приложения",
"Это типы дисков",
"Сетевые зоны",
"Режимы работы CPU"
],
"correct": 0
},
{
"text": "Что такое системные вызовы?",
"options": [
"Механизм обращения из userspace в kernelspace",
"Команды в терминале",
"Сигналы между процессами",
"Типы файлов"
],
"correct": 0
},
{
"text": "Какой сигнал отправляется при Ctrl+C?",
"options": ["SIGINT", "SIGKILL", "SIGTERM", "SIGHUP"],
"correct": 0
},
{
"text": "Чем отличается SIGTERM от SIGKILL?",
"options": [
"SIGTERM можно перехватить, SIGKILL — нет",
"SIGKILL мягче",
"SIGTERM используется только для root",
"SIGKILL отправляется первым"
],
"correct": 0
},
{
"text": "Какие сигналы нельзя проигнорировать?",
"options": ["SIGKILL и SIGSTOP", "SIGTERM и SIGINT", "SIGHUP и SIGUSR1", "Все можно"],
"correct": 0
},
{
"text": "Как посмотреть, какие файлы открыл процесс?",
"options": ["ls -l /proc/PID/fd/", "ps aux", "df -h", "free -h"],
"correct": 0
},
{
"text": "Как узнать, где программа ищет конфиг?",
"options": ["strace -e open program", "cat /etc/program.conf", "ps aux", "netstat"],
"correct": 0
},
{
"text": "Что делать, если chmod лишён прав на исполнение?",
"options": [
"Запустить через /lib64/ld-linux-x86-64.so.2 /bin/chmod +x /bin/chmod",
"Перезагрузить",
"Установить заново",
"Использовать альтернативу"
],
"correct": 0
},
{
"text": "Почему available > free в free -h?",
"options": [
"Available учитывает, что кэш можно сбросить",
"Это ошибка",
"Available включает swap",
"Free не считает RAM"
],
"correct": 0
},
{
"text": "Как работает OOM Killer?",
"options": [
"Убивает процесс с наибольшим oom_score при нехватке памяти",
"Перезагружает систему",
"Блокирует новые процессы",
"Переносит всё в swap"
],
"correct": 0
},
{
"text": "Что такое iowait?",
"options": [
"Процент времени, которое CPU ждал завершения I/O",
"Загрузка сети",
"Использование swap",
"Потребление RAM"
],
"correct": 0
},
{
"text": "Как посмотреть, какие процессы используют диск?",
"options": ["iotop", "top", "ps aux", "df -h"],
"correct": 0
},
{
"text": "Как проверить, слушает ли сервис порт?",
"options": ["ss -tuln", "ps aux", "df -h", "free -h"],
"correct": 0
},
{
"text": "Что такое iptables?",
"options": [
"Фильтрация пакетов на уровне ядра",
"Менеджер пакетов",
"Тип файловой системы",
"Сетевой монитор"
],
"correct": 0
},
{
"text": "Как посмотреть историю команд?",
"options": ["history", "cat ~/.bash_history", "journalctl", "ls /var/log"],
"correct": 0
},
{
"text": "Где хранятся системные логи?",
"options": ["/var/log/", "/etc/log/", "/tmp", "/home"],
"correct": 0
},
{
"text": "Как отследить системные вызовы?",
"options": ["strace -p PID", "lsof", "netstat", "ps"],
"correct": 0
},
{
"text": "Как управлять сервисами в systemd?",
"options": ["systemctl start/stop/enable", "service start", "init.d", "run"],
"correct": 0
},
{
"text": "Как установить пакет из исходного кода?",
"options": ["./configure → make → make install", "apt install", "yum install", "pip install"],
"correct": 0
},
{
"text": "Что такое initramfs?",
"options": [
"Временная ФС в RAM с драйверами для монтирования корня",
"Загрузчик",
"Тип ядра",
"Лог-файл"
],
"correct": 0
},
{
"text": "Как работает fork()?",
"options": [
"Создаёт копию процесса (copy-on-write)",
"Запускает новый терминал",
"Перезагружает систему",
"Убивает процесс"
],
"correct": 0
},
{
"text": "Как работать с файлами >2GB на 32-битной системе?",
"options": [
"Требуется поддержка large file support (LFS)",
"Невозможно",
"Только через swap",
"Автоматически работает"
],
"correct": 0
},
{
"text": "Что такое softirq?",
"options": [
"Нижняя половина обработки прерываний в ядре",
"Тип сигнала",
"Сетевой пакет",
"Ошибка диска"
],
"correct": 0
},
{
"text": "Как посмотреть дерево процессов?",
"options": ["pstree", "ps aux", "top", "htop"],
"correct": 0
},
{
"text": "Как найти процесс по имени?",
"options": ["pgrep имя", "ps aux | grep имя", "top", "htop"],
"correct": 0
},
{
"text": "Как убить процесс по имени?",
"options": ["pkill имя", "kill PID", "stop имя", "exit имя"],
"correct": 0
},
{
"text": "Как проверить целостность ФС?",
"options": ["fsck /dev/sdX1", "df -h", "du -sh", "lsblk"],
"correct": 0
},
{
"text": "Как монтировать ФС постоянно?",
"options": ["Добавить запись в /etc/fstab", "Выполнить mount", "Создать скрипт", "Использовать systemd"],
"correct": 0
},
{
"text": "Как узнать UUID раздела?",
"options": ["blkid /dev/sdX1", "lsblk", "df -h", "fdisk -l"],
"correct": 0
}
]
}
],
"networking": [
{
"title": "IP-адресация и маски подсети",
"content": "IP-адрес (IPv4) — это 32-битный числовой идентификатор устройства в сети, записываемый как четыре десятичных числа через точку (например, 192.168.1.10). Маска подсети определяет, какая часть адреса относится к сети, а какая — к хосту. Например, маска /24 (255.255.255.0) означает, что первые 24 бита — сеть, остальные 8 — хосты. В такой подсети теоретически 256 адресов, но два зарезервированы: первый — сетевой адрес (192.168.1.0), последний — широковещательный (192.168.1.255), поэтому доступно 254 хоста. Приватные диапазоны (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) используются во внутренних сетях и не маршрутизируются в интернете.",
"questions": [
{
"text": "Сколько хостов доступно в сети 192.168.1.0/24?",
"options": ["256", "254", "255", "128"],
"correct": 1
},
{
"text": "Какой из адресов является приватным?",
"options": ["8.8.8.8", "172.15.0.1", "192.168.10.5", "203.0.113.1"],
"correct": 2
},
{
"text": "Что означает маска /23?",
"options": ["512 адресов всего, 510 для хостов", "256 адресов", "1024 адреса", "128 адресов"],
"correct": 0
}
]
},
{
"title": "Модели OSI и TCP/IP",
"content": "Модель OSI (7 уровней) — концептуальная модель взаимодействия сетевых протоколов: 1) Физический, 2) Канальный, 3) Сетевой, 4) Транспортный, 5) Сеансовый, 6) Представительский, 7) Прикладной. Модель TCP/IP (4 уровня) — упрощённая и используемая на практике: Link (Link Layer), Internet (IP), Transport (TCP/UDP), Application (HTTP, DNS, SSH). Протокол TCP работает на транспортном уровне (4-й в OSI, 3-й в TCP/IP). SSH — на прикладном уровне, но использует TCP для передачи данных. Понимание уровней помогает диагностировать проблемы: например, если не работает ping — проблема на сетевом уровне, если не открывается сайт — на прикладном.",
"questions": [
{
"text": "На каком уровне OSI работает протокол TCP?",
"options": ["Сетевой (3-й)", "Транспортный (4-й)", "Канальный (2-й)", "Прикладной (7-й)"],
"correct": 1
},
{
"text": "На каком уровне OSI работает SSH?",
"options": ["Прикладной (7-й)", "Транспортный (4-й)", "Сетевой (3-й)", "Сеансовый (5-й)"],
"correct": 0
},
{
"text": "Сколько уровней в модели OSI?",
"options": ["4", "5", "7", "8"],
"correct": 2
}
]
},
{
"title": "TCP vs UDP",
"content": "TCP (Transmission Control Protocol) — надёжный, ориентированный на соединение протокол. Он гарантирует доставку, порядок пакетов и защиту от дублирования через подтверждения (ACK), повторные передачи и управление потоком. Используется для веба (HTTP), почты, SSH. UDP (User Datagram Protocol) — ненадёжный, без установки соединения. Он быстрее, но не гарантирует доставку. Используется для DNS, VoIP, потокового видео, онлайн-игр. DNS использует UDP для стандартных запросов (быстро, маленький объём), но переключается на TCP при больших ответах (например, при DNSSEC) или зоне передачи.",
"questions": [
{
"text": "Почему DNS использует UDP?",
"options": ["Потому что запросы короткие и UDP быстрее", "Потому что UDP надёжнее TCP", "DNS не поддерживает TCP", "Для шифрования запросов"],
"correct": 0
},
{
"text": "Какой протокол гарантирует доставку пакетов?",
"options": ["UDP", "ICMP", "TCP", "ARP"],
"correct": 2
},
{
"text": "Какой протокол используется для VoIP?",
"options": ["TCP", "UDP", "HTTP", "SSH"],
"correct": 1
}
]
},
{
"title": "DNS: как это работает",
"content": "DNS (Domain Name System) преобразует доменные имена (yandex.ru) в IP-адреса. Процесс: 1) Браузер проверяет кеш ОС. 2) Если нет — обращается к рекурсивному DNS-резолверу (например, 8.8.8.8). 3) Резолвер запрашивает корневые серверы → серверы зоны .ru → авторитетные серверы yandex.ru. Авторитетный DNS хранит записи: A (IPv4), AAAA (IPv6), CNAME (алиас), MX (почта), TXT (текстовые данные, например, для верификации). Рекурсивный DNS выполняет всю цепочку за клиента и кэширует результат. Локальный DNS в браузере/ОС позволяет избежать повторных запросов.",
"questions": [
{
"text": "Какие типы DNS-записей существуют?",
"options": ["A, AAAA, CNAME, MX, TXT", "TCP, UDP, ICMP", "IPv4, IPv6, MAC", "SSL, TLS, HTTPS"],
"correct": 0
},
{
"text": "Что такое рекурсивный DNS?",
"options": ["Сервер, выполняющий полную цепочку запросов за клиента", "Сервер, отдающий только кэш", "Локальный резолвер в ОС", "Корневой сервер"],
"correct": 0
},
{
"text": "Что такое authority в DNS?",
"options": ["Авторитетный сервер, хранящий оригинальные записи", "Центр сертификации", "Администратор домена", "Тип записи"],
"correct": 0
},
{
"text": "На каком протоколе работает DNS?",
"options": ["В основном UDP, при больших ответах — TCP", "Только TCP", "Только HTTP", "Только ICMP"],
"correct": 0
}
]
},
{
"title": "HTTP и HTTPS",
"content": "HTTP (HyperText Transfer Protocol) — протокол прикладного уровня для передачи веб-данных. Методы: GET (получение), POST (отправка), PUT (обновление), DELETE (удаление). Статус-коды: 2xx (успех, например, 200), 3xx (перенаправление, 301/302), 4xx (ошибка клиента, 404), 5xx (ошибка сервера, 500). Заголовки содержат метаданные: User-Agent, Cookie, Authorization, Content-Type. HTTPS — это HTTP поверх TLS/SSL, обеспечивающий шифрование, целостность и аутентификацию. Базовая HTTP-аутентификация передаёт логин/пароль в заголовке Authorization в base64 (небезопасно без HTTPS).",
"questions": [
{
"text": "Какие основные типы HTTP-запросов существуют?",
"options": ["GET, POST, PUT, DELETE", "TCP, UDP, ICMP", "A, AAAA, CNAME", "SSL, TLS, SSH"],
"correct": 0
},
{
"text": "Что означает статус-код 404?",
"options": ["Успех", "Перенаправление", "Ошибка клиента (не найдено)", "Ошибка сервера"],
"correct": 2
},
{
"text": "Что может содержаться в заголовках HTTP?",
"options": ["User-Agent, Cookie, Authorization", "MAC-адрес, TTL", "SSL-ключ", "DNS-записи"],
"correct": 0
},
{
"text": "Как работает базовая HTTP-аутентификация?",
"options": ["Логин/пароль в base64 в заголовке Authorization", "Через TLS-сертификат", "Через отдельный порт", "С двухфакторной авторизацией"],
"correct": 0
}
]
},
{
"title": "SSL/TLS и безопасность",
"content": "SSL (устарел) и TLS — протоколы шифрования на транспортном уровне. TLS-handshake: 1) Клиент и сервер договариваются о версии и шифрах. 2) Сервер отправляет сертификат. 3) Клиент проверяет его у доверенного центра сертификации (CA). 4) Генерируется сессионный ключ (симметричное шифрование). SNI (Server Name Indication) позволяет одному IP-адресу обслуживать несколько HTTPS-сайтов, передавая имя хоста на этапе handshake. PFS (Perfect Forward Secrecy) гарантирует, что компрометация долгосрочного ключа не раскроет прошлые сессии. mTLS (mutual TLS) требует сертификат от клиента — используется во внутренних микросервисах.",
"questions": [
{
"text": "Что такое SNI?",
"options": ["Расширение TLS для передачи имени хоста", "Тип DNS-записи", "Метод шифрования в SSH", "Протокол VoIP"],
"correct": 0
},
{
"text": "Что такое Perfect Forward Secrecy (PFS)?",
"options": ["Каждая сессия использует уникальный ключ", "Полное шифрование данных", "Метод сжатия сертификатов", "Тип аутентификации"],
"correct": 0
},
{
"text": "Как работает TLS-handshake?",
"options": ["Договор о шифрах, обмен сертификатами, генерация сессионного ключа", "Обмен паролями", "Через UDP", "С ручным подтверждением"],
"correct": 0
}
]
},
{
"title": "Сетевые инструменты: ping, traceroute, TTL",
"content": "Ping использует протокол ICMP (Internet Control Message Protocol), а не TCP/UDP, поэтому у него нет портов. Он отправляет ICMP Echo Request и ждёт Echo Reply. TTL (Time To Live) — поле в IP-заголовке, ограничивающее время жизни пакета (обычно 64). Каждый маршрутизатор уменьшает TTL на 1; при 0 — пакет отбрасывается, и отправляется ICMP Time Exceeded. Traceroute использует TTL: отправляет пакеты с TTL=1,2,3... и по ICMP-ответам строит маршрут до цели. Низкий latency до 8.8.8.8 (Google DNS) обеспечивается глобальной CDN и оптимизацией маршрутов.",
"questions": [
{
"text": "На каком порту работает ping?",
"options": ["Ping не использует порты — работает поверх ICMP", "Порт 7", "Порт 53", "Порт 80"],
"correct": 0
},
{
"text": "Что такое TTL?",
"options": ["Поле в IP-заголовке, ограничивающее время жизни пакета", "Тип лицензии", "Метод сжатия", "Протокол аутентификации"],
"correct": 0
},
{
"text": "Как работает traceroute?",
"options": ["Отправляет пакеты с увеличивающимся TTL", "Делает ping до каждого узла", "Использует DNS", "Анализирует таблицу маршрутизации"],
"correct": 0
}
]
},
{
"title": "NAT, VLAN и маршрутизация",
"content": "NAT (Network Address Translation) позволяет множеству устройств в локальной сети выходить в интернет через один публичный IP. Например, роутер заменяет исходный IP 192.168.1.10 на свой публичный при исходящем трафике и наоборот — при ответе. VLAN (Virtual LAN) логически разделяет одну физическую сеть на несколько изолированных сегментов (например, для отделов), улучшая безопасность и управление. Таблица маршрутизации на устройстве определяет, куда направлять пакеты: по умолчанию — шлюз (роутер), для локальных сетей — напрямую.",
"questions": [
{
"text": "Зачем нужен VLAN?",
"options": ["Для логического разделения физической сети", "Для увеличения скорости", "Для шифрования", "Для настройки IP"],
"correct": 0
},
{
"text": "Как работает NAT?",
"options": ["Позволяет многим устройствам использовать один публичный IP", "Шифрует трафик", "Блокирует соединения", "Ускоряет DNS"],
"correct": 0
},
{
"text": "Что такое таблица маршрутизации?",
"options": ["Определяет, куда направлять пакеты", "Хранит пароли", "Список DNS-серверов", "Журнал подключений"],
"correct": 0
}
]
},
{
"title": "Практические сценарии",
"content": "Если сервис на порту 80 доступен локально (curl localhost), но не извне — возможные причины: 1) Фаервол (например, Windows Defender или iptables) блокирует входящие подключения. 2) Сервис слушает только на 127.0.0.1 (localhost), а не на 0.0.0.0 (все интерфейсы). Проверка: netstat -tuln → должно быть 0.0.0.0:80, а не 127.0.0.1:80. Вторая причина: провайдер или хостинг блокируют порт 80 (часто на VPS без белого IP).",
"questions": [
{
"text": "Сервис на 80 порту доступен локально, но не из браузера. Почему?",
"options": ["Слушает только 127.0.0.1 или фаервол блокирует", "Порт 80 закрыт провайдером", "Нужен HTTPS", "Браузер не поддерживает HTTP"],
"correct": 0
},
{
"text": "Почему latency до 8.8.8.8 всегда низкий?",
"options": ["Потому что это Google DNS с глобальной CDN", "Потому что это локальный адрес", "Потому что пинг через UDP", "Потому что нет шифрования"],
"correct": 0
}
]
},
{
"title": "Балансировщики L4 и L7",
"content": "L4-балансировщик (например, IPVS, HAProxy в режиме TCP) работает на транспортном уровне (TCP/UDP). Он распределяет трафик по IP и порту, не видя содержимого. Быстрый, но ограниченный. L7-балансировщик (Nginx, HAProxy в HTTP-режиме, ALB в AWS) работает на прикладном уровне. Он читает заголовки HTTP (Host, User-Agent), может маршрутизировать по URI, кукам, содержимому. Позволяет делать канареечные релизы, A/B-тестирование, но требует больше ресурсов.",
"questions": [
{
"text": "Чем отличаются балансировщики L4 и L7?",
"options": ["L4 — по IP/порту; L7 — по содержимому (HTTP)", "L4 шифрует трафик", "L7 быстрее", "L4 используется только в облаке"],
"correct": 0
},
{
"text": "Что даёт балансировщик трафика?",
"options": ["Распределение нагрузки для отказоустойчивости", "Шифрование всего трафика", "Автоматическую настройку DNS", "Ускорение интернета"],
"correct": 0
}
]
},
{
"title": "SSH и безопасный доступ",
"content": "SSH (Secure Shell) работает поверх TCP (порт 22). Установка соединения: 1) Клиент и сервер обмениваются версиями. 2) Договариваются о шифрах. 3) Сервер отправляет свой публичный ключ. 4) Клиент проверяет его по записям в ~/.ssh/known_hosts. Авторизация: 1) По паролю. 2) По ключу: клиент подписывает запрос своим приватным ключом, сервер проверяет публичным. Ключи надёжнее и удобнее.",
"questions": [
{
"text": "Как устанавливает соединение SSH?",
"options": ["Обмен версиями, договор о шифрах, проверка ключа", "Через HTTP-запрос", "Через UDP", "Требует DNS TXT"],
"correct": 0
},
{
"text": "Какой метод авторизации в SSH надёжнее?",
"options": ["По ключу", "По паролю", "По IP", "По имени пользователя"],
"correct": 0
}
]
},
{
"title": "Дополнительно: mTLS, iptables, PFS",
"content": "mTLS (mutual TLS) — двусторонняя аутентификация, где и клиент, и сервер предъявляют сертификаты. Используется в микросервисных архитектурах. Настройка проброса портов в iptables: iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080 — перенаправляет внешний порт 80 на внутренний 8080. PFS (Perfect Forward Secrecy) достигается использованием эфемерных ключей — каждый сеанс использует уникальный ключ.",
"questions": [
{
"text": "Что такое mTLS?",
"options": ["Взаимная аутентификация по сертификатам", "Тип балансировщика", "Метод сжатия TLS", "Протокол для мобильных сетей"],
"correct": 0
},
{
"text": "Как работает двусторонняя аутентификация (mTLS)?",
"options": ["И клиент, и сервер проверяют сертификаты", "Используется только пароль", "Работает без сертификатов", "Требует физического ключа"],
"correct": 0
},
{
"text": "Как настроить проброс портов через iptables?",
"options": ["iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080", "iptables --allow-port 80", "Невозможно", "Через route add"],
"correct": 0
}
]
},
{
"title": "Итоговый тест: полная проверка знаний по сетям",
"content": "Этот тест содержит ВСЕ вопросы по сетям — от основ IP до продвинутых тем вроде mTLS и PFS. Удачи!",
"questions": [
{
"text": "Что такое IP и маска подсети?",
"options": ["IP — уникальный идентификатор устройства; маска определяет границу сети и хоста", "IP — MAC-адрес", "IP — имя домена", "IP — пароль от Wi-Fi"],
"correct": 0
},
{
"text": "Чем отличается TCP от UDP?",
"options": ["TCP — надёжный с подтверждением; UDP — быстрый, без гарантий", "TCP работает только локально", "TCP использует порты, UDP — нет", "TCP шифрует трафик"],
"correct": 0
},
{
"text": "Как работает DNS, зачем он нужен?",
"options": ["Преобразует домены в IP-адреса", "Шифрует трафик", "Блокирует сайты", "Ускоряет загрузку"],
"correct": 0
},
{
"text": "Какие типы DNS-записей существуют?",
"options": ["A, AAAA, CNAME, MX, TXT", "TCP, UDP, ICMP", "IPv4, IPv6, MAC", "SSL, TLS, HTTPS"],
"correct": 0
},
{
"text": "Как узнать мой внешний IP-адрес?",
"options": ["Через сервисы вроде ifconfig.me", "Командой ipconfig", "Командой ifconfig", "В настройках роутера"],
"correct": 0
},
{
"text": "Какие стандартные коды ответов есть у веб-серверов?",
"options": ["2xx, 3xx, 4xx, 5xx", "1xx, 2xx, 3xx", "A, B, C, D", "HTTP, HTTPS, FTP"],
"correct": 0
},
{
"text": "В чём отличие HTTP от HTTPS?",
"options": ["HTTPS — это HTTP поверх TLS", "HTTP только на порту 80", "HTTPS быстрее", "HTTP требует авторизации"],
"correct": 0
},
{
"text": "Что такое SSL и TLS?",
"options": ["Протоколы шифрования транспортного уровня", "Типы веб-серверов", "Методы сжатия", "СУБД"],
"correct": 0
},
{
"text": "Какие основные типы HTTP-запросов существуют?",
"options": ["GET, POST, PUT, DELETE", "TCP, UDP, ICMP", "A, AAAA, CNAME", "SSL, TLS, SSH"],
"correct": 0
},
{
"text": "Как TCP устанавливает соединение?",
"options": ["Через трёхэтапное рукопожатие", "Через двухэтапное", "Автоматически", "С DNS-запросом"],
"correct": 0
},
{
"text": "Что происходит, когда в браузере вводишь yandex.ru?",
"options": ["DNS-запрос, TCP-соединение, HTTP-запрос", "Сразу HTTPS без DNS", "Подключение к локальному серверу", "Используется только UDP"],
"correct": 0
},
{
"text": "Как TCP поддерживает соединение?",
"options": ["Через ACK, повторные передачи, управление потоком", "Через регулярные ping", "С DNS-кэшированием", "Автоматически"],
"correct": 0
},
{
"text": "Что такое и зачем нужен ARP-протокол?",
"options": ["Сопоставляет IP MAC-адресам в локальной сети", "Шифрует трафик", "Маршрутизирует пакеты", "Блокирует IP"],
"correct": 0
},
{
"text": "Зачем нужен VLAN?",
"options": ["Для логического разделения физической сети", "Для увеличения скорости", "Для шифрования", "Для настройки IP"],
"correct": 0
},
{
"text": "На каком уровне OSI работает TCP?",
"options": ["Транспортный (4-й)", "Сетевой (3-й)", "Канальный (2-й)", "Прикладной (7-й)"],
"correct": 0
},
{
"text": "На каком уровне OSI работает SSH?",
"options": ["Прикладной (7-й)", "Транспортный (4-й)", "Сетевой (3-й)", "Сеансовый (5-й)"],
"correct": 0
},
{
"text": "Что такое адреса 127.0.0.0/8, 192.168.0.0/16 и т.д.?",
"options": ["Приватные диапазоны для внутренних сетей", "Публичные DNS", "Корневые серверы", "Multicast"],
"correct": 0
},
{
"text": "Как работает NAT и зачем он нужен?",
"options": ["Позволяет многим устройствам использовать один публичный IP", "Шифрует трафик", "Блокирует соединения", "Ускоряет DNS"],
"correct": 0
},
{
"text": "Что такое SNI?",
"options": ["Расширение TLS для передачи имени хоста", "Тип DNS-записи", "Метод шифрования SSH", "Протокол VoIP"],
"correct": 0
},
{
"text": "Чем симметричное шифрование отличается от асимметричного?",
"options": ["Симметричное — один ключ; асимметричное — пара ключей", "Симметричное медленнее", "Симметричное только в HTTPS", "Асимметричное не обеспечивает целостность"],
"correct": 0
},
{
"text": "Почему DNS использует UDP?",
"options": ["Потому что запросы короткие и UDP быстрее", "Потому что UDP надёжнее", "DNS не поддерживает TCP", "Для шифрования"],
"correct": 0
},
{
"text": "На каком порту работает ping?",
"options": ["Ping не использует порты — работает поверх ICMP", "Порт 7", "Порт 53", "Порт 80"],
"correct": 0
},
{
"text": "Как работает ICMP?",
"options": ["Протокол для служебных сообщений (ошибки доставки)", "Шифрует трафик", "Используется для DNS", "Работает только в IPv6"],
"correct": 0
},
{
"text": "Что такое TTL?",
"options": ["Поле в IP-заголовке, ограничивающее время жизни пакета", "Тип лицензии", "Метод сжатия", "Протокол аутентификации"],
"correct": 0
},
{
"text": "Как работает traceroute?",
"options": ["Отправляет пакеты с увеличивающимся TTL", "Делает ping до каждого узла", "Использует DNS", "Анализирует таблицу маршрутизации"],
"correct": 0
},
{
"text": "Что такое authority в DNS?",
"options": ["Авторитетный сервер с оригинальными записями", "Центр сертификации", "Администратор домена", "Тип записи"],
"correct": 0
},
{
"text": "Что такое рекурсивный DNS?",
"options": ["Сервер, выполняющий полную цепочку запросов за клиента", "Сервер с кэшированными ответами", "Локальный резолвер", "Корневой сервер"],
"correct": 0
},
{
"text": "У тебя маска /23. Сколько адресов доступно?",
"options": ["512 всего, 510 для хостов", "256", "1024", "128"],
"correct": 0
},
{
"text": "Как работает базовая HTTP-аутентификация?",
"options": ["Логин/пароль в base64 в заголовке Authorization", "Через TLS-сертификат", "Через отдельный порт", "С двухфакторной авторизацией"],
"correct": 0
},
{
"text": "Как работают сертификаты в HTTPS?",
"options": ["Сервер отправляет сертификат, клиент проверяет у CA", "Сертификат шифрует весь трафик", "Сертификат генерируется браузером", "Используется только для SMTP"],
"correct": 0
},
{
"text": "Как устанавливает соединение SSH?",
"options": ["Обмен версиями, договор о шифрах, проверка ключа", "Через HTTP", "Через UDP", "Требует DNS TXT"],
"correct": 0
},
{
"text": "Чем отличаются балансировщики L4 и L7?",
"options": ["L4 — по IP/порту; L7 — по содержимому", "L4 шифрует трафик", "L7 быстрее", "L4 только в облаке"],
"correct": 0
},
{
"text": "Почему latency до 8.8.8.8 всегда низкий?",
"options": ["Потому что это Google DNS с глобальной CDN", "Потому что локальный адрес", "Потому что пинг через UDP", "Потому что нет шифрования"],
"correct": 0
},
{
"text": "На каком протоколе работает DNS?",
"options": ["В основном UDP, при больших ответах — TCP", "Только TCP", "Только HTTP", "Только ICMP"],
"correct": 0
},
{
"text": "Сервис на 80 порту доступен локально, но не из браузера. Почему?",
"options": ["Слушает только 127.0.0.1 или фаервол блокирует", "Порт 80 закрыт провайдером", "Нужен HTTPS", "Браузер не поддерживает HTTP"],
"correct": 0
},
{
"text": "Что даёт балансировщик трафика?",
"options": ["Распределение нагрузки для отказоустойчивости", "Шифрование всего трафика", "Автоматическую настройку DNS", "Ускорение интернета"],
"correct": 0
},
{
"text": "Что такое mTLS?",
"options": ["Взаимная аутентификация по сертификатам", "Тип балансировщика", "Метод сжатия TLS", "Протокол для мобильных сетей"],
"correct": 0
},
{
"text": "Что может содержаться в заголовках HTTP?",
"options": ["User-Agent, Cookie, Authorization", "MAC-адрес, TTL", "SSL-ключ", "DNS-записи"],
"correct": 0
},
{
"text": "Как работает TLS-handshake?",
"options": ["Договор о шифрах, обмен сертификатами, генерация ключа", "Обмен паролями", "Через UDP", "С ручным подтверждением"],
"correct": 0
},
{
"text": "Как настроить проброс портов через iptables?",
"options": ["iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:8080", "iptables --allow-port 80", "Невозможно", "Через route add"],
"correct": 0
},
{
"text": "Что такое Perfect Forward Secrecy (PFS)?",
"options": ["Каждая сессия использует уникальный ключ", "Полное шифрование данных", "Метод сжатия сертификатов", "Тип аутентификации"],
"correct": 0
},
{
"text": "Как работает двусторонняя аутентификация (mTLS)?",
"options": ["И клиент, и сервер проверяют сертификаты", "Используется только пароль", "Работает без сертификатов", "Требует физического ключа"],
"correct": 0
}
]
}
],
"databases": [
{
"title": "TRUNCATE, DELETE и DROP в SQL",
"content": "Эти команды удаляют данные, но по-разному. DELETE удаляет строки (можно с WHERE), поддерживает ROLLBACK и вызывает триггеры. TRUNCATE быстро очищает всю таблицу, сбрасывает автоинкремент, но не логирует построчно (в MySQL откат невозможен). DROP удаляет таблицу полностью — структуру, данные, индексы. DELETE — для выборочного удаления, TRUNCATE — для быстрой очистки, DROP — для полного удаления таблицы.",
"questions": [
{
"text": "Какая команда удаляет таблицу полностью, включая структуру?",
"options": ["DELETE", "TRUNCATE", "DROP", "ALTER"],
"correct": 2
},
{
"text": "Какая команда позволяет использовать WHERE для удаления строк?",
"options": ["DELETE", "TRUNCATE", "DROP", "CREATE"],
"correct": 0
},
{
"text": "Какая команда сбрасывает автоинкрементный счётчик?",
"options": ["DELETE", "TRUNCATE", "Обе", "Ни одна"],
"correct": 1
}
]
},
{
"title": "Индексы в базах данных",
"content": "Индексы — структуры для ускорения поиска (как оглавление в книге). Создаются для столбцов, часто используемых в WHERE, JOIN, ORDER BY. Типы: B-дерево (стандарт), хеш (только =), составные (несколько столбцов), GIN/GiST (для JSON/текста). Индексы ускоряют SELECT, но замедляют INSERT/UPDATE, так как их тоже нужно обновлять. Уникальные индексы гарантируют отсутствие дубликатов. Используй EXPLAIN, чтобы проверить, используется ли индекс.",
"questions": [
{
"text": "Какой тип индекса подходит для точного сравнения (=) и самый быстрый?",
"options": ["B-дерево", "Хеш-индекс", "Составной", "GIN"],
"correct": 1
},
{
"text": "Что ускоряет индекс на столбце `email`?",
"options": ["Запросы с WHERE email = ...", "Запросы с WHERE age > ...", "INSERT в таблицу", "DROP TABLE"],
"correct": 0
},
{
"text": "Какой индекс гарантирует уникальность значений?",
"options": ["PRIMARY KEY", "UNIQUE INDEX", "Обычный индекс", "Хеш-индекс"],
"correct": 1
}
]
},
{
"title": "Основные операторы SQL",
"content": "SQL-операторы делятся на категории: DQL (SELECT, WHERE, JOIN — запросы), DML (INSERT, UPDATE, DELETE — изменение данных), DDL (CREATE, ALTER, DROP — структура), TCL (COMMIT, ROLLBACK — транзакции), DCL (GRANT, REVOKE — права). SELECT — основа запросов. JOIN объединяет таблицы. GROUP BY группирует, HAVING фильтрует группы. LIMIT ограничивает результат. Используйте EXPLAIN для анализа плана выполнения запроса.",
"questions": [
{
"text": "К какой категории относится оператор SELECT?",
"options": ["DML", "DDL", "DQL", "TCL"],
"correct": 2
},
{
"text": "Какой оператор используется для подтверждения транзакции?",
"options": ["SAVEPOINT", "ROLLBACK", "COMMIT", "GRANT"],
"correct": 2
},
{
"text": "Какой оператор добавляет новый столбец в таблицу?",
"options": ["CREATE COLUMN", "ADD COLUMN", "ALTER TABLE ... ADD COLUMN", "UPDATE TABLE"],
"correct": 2
},
{
"text": "Что делает оператор HAVING?",
"options": ["Фильтрует строки до группировки", "Фильтрует группы после GROUP BY", "Сортирует результат", "Ограничивает количество строк"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Базы данных (Junior)",
"content": "Финальный тест по модулю «Базы данных». 10 вопросов на знание основ SQL.",
"questions": [
{
"text": "Какая команда НЕ может использовать WHERE?",
"options": ["DELETE", "TRUNCATE", "SELECT", "UPDATE"],
"correct": 1
},
{
"text": "Что произойдёт при выполнении DROP TABLE users?",
"options": ["Удалятся только данные", "Таблица очистится, но останется", "Таблица и её структура удалятся", "Сработает ошибка"],
"correct": 2
},
{
"text": "Для чего используется индекс?",
"options": ["Ускорить поиск данных", "Зашифровать данные", "Удалить дубликаты", "Создать резервную копию"],
"correct": 0
},
{
"text": "Какой оператор возвращает уникальные значения?",
"options": ["UNIQUE", "DISTINCT", "GROUP BY", "HAVING"],
"correct": 1
},
{
"text": "Как откатить транзакцию в SQL?",
"options": ["UNDO", "CANCEL", "ROLLBACK", "REVERT"],
"correct": 2
},
{
"text": "Какой оператор изменяет структуру существующей таблицы?",
"options": ["MODIFY", "UPDATE", "ALTER", "CHANGE"],
"correct": 2
},
{
"text": "Какой тип индекса лучше всего подходит для поиска по диапазону (например, price > 100)?",
"options": ["Хеш-индекс", "B-дерево", "GIN", "Уникальный"],
"correct": 1
},
{
"text": "Что делает команда TRUNCATE TABLE?",
"options": ["Удаляет таблицу", "Удаляет все строки быстро", "Удаляет строки с WHERE", "Создаёт копию таблицы"],
"correct": 1
},
{
"text": "Какой оператор используется для объединения таблиц?",
"options": ["MERGE", "COMBINE", "JOIN", "UNION"],
"correct": 2
},
{
"text": "Как ограничить количество результатов в PostgreSQL?",
"options": ["TOP", "LIMIT", "MAX", "FETCH"],
"correct": 1
}
]
}
],
"ansible": [
{
"title": "Что такое Ansible и как он работает",
"content": "Ansible — это инструмент автоматизации инфраструктуры (IaC). Главные особенности: агентless-архитектура (работает через SSH/WinRM), идемпотентность (повторный запуск не ломает систему) и декларативный подход (описываете желаемое состояние). Основные компоненты: Inventory (список хостов), Playbook (YAML-сценарий), Module (готовые команды), Role (переиспользуемый блок). Ansible загружает модули на целевые узлы через Python и возвращает результат в JSON.",
"questions": [
{
"text": "Какая архитектура у Ansible?",
"options": ["Требует агентов на хостах", "Агентless (работает через SSH/WinRM)", "Использует открытые порты кроме SSH", "Только для Linux"],
"correct": 1
},
{
"text": "Что означает идемпотентность в Ansible?",
"options": ["Задача выполняется быстрее при повторном запуске", "Повторный запуск не меняет систему, если она уже в нужном состоянии", "Задача всегда ломает систему", "Требует перезагрузки сервера"],
"correct": 1
},
{
"text": "Как Ansible подключается к Linux-хостам?",
"options": ["Через специальный агент", "Через SSH", "Через HTTP API", "Через Telnet"],
"correct": 1
}
]
},
{
"title": "Playbook и Inventory в Ansible",
"content": "Playbook — это YAML-файл с задачами (tasks), который описывает автоматизацию. Структура: hosts (целевые хосты), become (sudo), tasks (вызов модулей). Inventory — файл (INI или YAML), где перечислены хосты и их параметры (ansible_user, ansible_port и т.д.). Пример inventory: [webservers] 10.0.0.1. Пример playbook: установка Nginx через apt и запуск службы через service. Playbook можно запустить командой ansible-playbook -i inventory playbook.yml.",
"questions": [
{
"text": "Какой формат файла используется для Playbook?",
"options": ["JSON", "XML", "YAML", "INI"],
"correct": 2
},
{
"text": "Как указать нестандартный SSH-порт для хоста в inventory?",
"options": ["10.0.0.1:2222", "10.0.0.1 port=2222", "10.0.0.1 ansible_port=2222", "Нельзя указать"],
"correct": 2
},
{
"text": "Какая команда запускает playbook?",
"options": ["ansible run playbook.yml", "ansible-playbook playbook.yml", "ansible execute playbook.yml", "playbook run"],
"correct": 1
}
]
},
{
"title": "Роли (Roles) в Ansible",
"content": "Роль — это переиспользуемый набор задач, шаблонов, файлов и переменных с чёткой структурой: tasks/main.yml (задачи), handlers/main.yml (обработчики), templates/ (шаблоны Jinja2), files/ (статические файлы), vars/main.yml (переменные), defaults/main.yml (переменные по умолчанию). Роли подключаются в playbook через секцию roles. Преимущество: удобство поддержки и повторное использование (например, роль nginx можно подключить в десятки проектов). Создать роль: ansible-galaxy init my_role.",
"questions": [
{
"text": "Где хранятся шаблоны конфигов в роли?",
"options": ["files/", "templates/", "vars/", "handlers/"],
"correct": 1
},
{
"text": "Какая папка содержит переменные по умолчанию (низкий приоритет)?",
"options": ["vars/", "defaults/", "meta/", "tasks/"],
"correct": 1
},
{
"text": "Как подключить роль в playbook?",
"options": ["import_role: nginx", "include: roles/nginx", "roles: - nginx", "call nginx_role"],
"correct": 2
}
]
},
{
"title": "Продвинутые возможности: Handlers, Tags, Ansible vs Terraform",
"content": "Handlers — задачи, которые запускаются только при уведомлении (notify) и только если произошли изменения (например, перезапуск nginx после обновления конфига). Tags позволяют запускать часть задач: --tags 'install'. Ansible vs Terraform: Ansible — для управления конфигурацией существующих серверов (push-модель), Terraform — для создания/удаления облачной инфраструктуры (IaC). Ansible — идемпотентный, безагентный, использует модули и плагины.",
"questions": [
{
"text": "Когда выполняется handler?",
"options": ["После каждой задачи", "Только если задача изменила состояние и вызвала notify", "Перед всеми задачами", "Никогда"],
"correct": 1
},
{
"text": "Чем Ansible отличается от Terraform?",
"options": ["Ansible создаёт инфраструктуру, Terraform настраивает её", "Ansible управляет конфигурацией серверов, Terraform — управляет облачными ресурсами", "Terraform работает через SSH, Ansible — через API", "Нет разницы"],
"correct": 1
},
{
"text": "Как запустить только задачи с тегом 'deploy'?",
"options": ["--tag deploy", "--tags 'deploy'", "-t deploy", "Все варианты верны"],
"correct": 3
},
{
"text": "Где работают модули Ansible?",
"options": ["На управляющей машине", "На целевых хостах", "В облаке", "В Docker-контейнере"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Ansible (Junior)",
"content": "Финальный тест по модулю Ansible. 15 вопросов на все ключевые темы.",
"questions": [
{
"text": "Какая команда проверяет подключение к хостам?",
"options": ["ansible all -m ping", "ansible ping all", "ansible test all", "ping all"],
"correct": 0
},
{
"text": "Что такое inventory в Ansible?",
"options": ["Файл с задачами", "Список управляемых хостов", "Шаблон конфигурации", "Результат выполнения"],
"correct": 1
},
{
"text": "Какой модуль используется для установки пакетов в Ubuntu?",
"options": ["yum", "apt", "package", "install"],
"correct": 1
},
{
"text": "Какой файл в роли содержит основные задачи?",
"options": ["tasks/main.yml", "handlers/main.yml", "vars/main.yml", "defaults/main.yml"],
"correct": 0
},
{
"text": "Что делает параметр become: yes в playbook?",
"options": ["Подключается под другим пользователем", "Выполняет задачи с правами sudo", "Пропускает задачу", "Логирует выполнение"],
"correct": 1
},
{
"text": "Какой формат inventory поддерживает вложенные группы?",
"options": ["Только INI", "Только YAML", "Оба формата", "Ни один"],
"correct": 2
},
{
"text": "Что такое facts в Ansible?",
"options": ["Переменные, заданные пользователем", "Автоматически собранные данные о хостах", "Шаблоны Jinja2", "Результаты тестов"],
"correct": 1
},
{
"text": "Какой плагин отвечает за подключение к хостам?",
"options": ["callback", "lookup", "connection", "inventory"],
"correct": 2
},
{
"text": "Где хранятся статические файлы для копирования в роли?",
"options": ["templates/", "files/", "vars/", "meta/"],
"correct": 1
},
{
"text": "Что произойдёт, если задача не изменила состояние, но вызвала notify?",
"options": ["Handler выполнится", "Handler не выполнится", "Playbook завершится с ошибкой", "Ansible перезапустится"],
"correct": 1
},
{
"text": "Какой модуль управляет службами (сервисами)?",
"options": ["service", "systemd", "start", "run"],
"correct": 0
},
{
"text": "Как создать новую роль?",
"options": ["ansible role create my_role", "ansible-galaxy init my_role", "mkdir roles/my_role", "Все способы верны"],
"correct": 1
},
{
"text": "Какой параметр inventory задаёт пользователя для SSH?",
"options": ["user", "ssh_user", "ansible_user", "login"],
"correct": 2
},
{
"text": "Что такое плагины в Ansible?",
"options": ["Замена модулей", "Расширение функциональности на управляющей машине", "Агенты на хостах", "Графический интерфейс"],
"correct": 1
},
{
"text": "Какой принцип позволяет запускать playbook много раз без вреда?",
"options": ["Idempotency", "Agentless", "Declarative", "Modular"],
"correct": 0
}
]
}
],
"docker": [
{
"title": "Контейнеризация vs Виртуализация",
"content": "Контейнеризация и виртуализация — разные подходы к изоляции. Виртуализация (VM) эмулирует железо через гипервизор и запускает полную гостевую ОС — тяжело, но безопасно. Контейнеризация (Docker) делит ядро хоста через namespaces (изоляция процессов, сети, ФС) и cgroups (ограничение ресурсов). Контейнер — это просто изолированный процесс, запускается за миллисекунды, потребляет минимум ресурсов. Изоляция слабее (общее ядро), но для микросервисов — идеальна. В облаках часто контейнеры запускают внутри VM (гибрид). Выбор: VM — для разных ОС или полной изоляции, контейнеры — для DevOps, CI/CD, микросервисов.",
"questions": [
{
"text": "В чём ключевое отличие контейнера от виртуальной машины?",
"options": ["Контейнер эмулирует железо", "Контейнер использует ядро хоста, VM — свою ОС", "VM запускается быстрее", "Контейнер требует гипервизор"],
"correct": 1
},
{
"text": "Какая технология обеспечивает изоляцию процессов в контейнере?",
"options": ["Гипервизор", "Namespaces", "cgroups", "VirtualBox"],
"correct": 1
},
{
"text": "Какая технология ограничивает CPU/RAM для контейнера?",
"options": ["Namespaces", "cgroups", "KVM", "Docker Hub"],
"correct": 1
}
]
},
{
"title": "Образы, слои и Copy-on-Write",
"content": "Docker-образ — неизменяемый шаблон для контейнера, состоит из слоёв. Каждая инструкция в Dockerfile (FROM, RUN, COPY) создаёт новый слой. Слои кэшируются: изменение в Dockerfile пересобирает только текущий и последующие слои. При запуске контейнера поверх слоёв образа создаётся записываемый слой (Copy-on-Write): изменения файлов сохраняются только в нём. Это позволяет экономить место и ускорять сборку. Анализ слоёв: `docker history <image>`. Оптимизация: объединять команды RUN, удалять кэш, использовать .dockerignore.",
"questions": [
{
"text": "Что такое слой (layer) в Docker?",
"options": ["Отдельный контейнер", "Неизменяемый компонент образа, созданный инструкцией Dockerfile", "Тип сети", "Файл логов"],
"correct": 1
},
{
"text": "Как работает Copy-on-Write в контейнере?",
"options": ["Копирует весь образ при запуске", "При изменении файла создаёт копию в записываемом слое", "Запрещает изменение файлов", "Работает только в VM"],
"correct": 1
},
{
"text": "Какой командой посмотреть слои образа?",
"options": ["docker layers", "docker history", "docker inspect", "docker images"],
"correct": 1
}
]
},
{
"title": "Dockerfile: инструкции, CMD vs ENTRYPOINT, оптимизация",
"content": "Dockerfile — инструкции для сборки образа. Ключевые команды: FROM (база), RUN (команды при сборке), COPY/ADD (копирование файлов; COPY предпочтительнее), WORKDIR (рабочая директория), CMD/ENTRYPOINT (запуск). CMD — аргументы по умолчанию (переопределяются), ENTRYPOINT — основная команда (не переопределяется без --entrypoint). Многоэтапная сборка (multi-stage) уменьшает размер образа: сборка в одном образе, копирование результата в минималистичный. Оптимизация: использовать -slim образы, удалять кэш (`rm -rf /var/lib/apt/lists/*`), избегать latest.",
"questions": [
{
"text": "В чём разница между CMD и ENTRYPOINT?",
"options": ["CMD нельзя переопределить, ENTRYPOINT — можно", "ENTRYPOINT задаёт основную команду, CMD — аргументы по умолчанию", "ENTRYPOINT работает только в multi-stage", "Нет разницы"],
"correct": 1
},
{
"text": "Зачем нужна многоэтапная сборка?",
"options": ["Для запуска нескольких контейнеров", "Для уменьшения размера финального образа", "Для ускорения загрузки Docker Hub", "Для совместимости с Kubernetes"],
"correct": 1
},
{
"text": "Почему не рекомендуется использовать образы с тегом latest?",
"options": ["Они самые большие", "Они нестабильны и нарушают воспроизводимость", "Они не содержат Python", "Они платные"],
"correct": 1
},
{
"text": "Какая инструкция предпочтительнее для копирования файлов?",
"options": ["ADD", "COPY", "RUN cp", "WORKDIR"],
"correct": 1
}
]
},
{
"title": "Сети, тома и Docker Compose",
"content": "Docker поддерживает сети: bridge (изолированная сеть по умолчанию), host (контейнер использует сеть хоста), none (без сети). Для связи контейнеров — пользовательские bridge-сети (`docker network create`). Тома (volumes) сохраняют данные между перезапусками: named volumes (управляются Docker) и bind mounts (привязка директории хоста). Docker Compose — инструмент для запуска мультконтейнерных приложений из YAML-файла (docker-compose.yml). Основные команды: `docker-compose up`, `down`, `ps`. Compose автоматически создаёт общую сеть для сервисов.",
"questions": [
{
"text": "В чём разница между bridge и host сетями?",
"options": ["bridge — сеть хоста, host — изолированная", "bridge — изолированная (по умолчанию), host — сеть хоста", "host работает только в VM", "bridge медленнее host всегда"],
"correct": 1
},
{
"text": "Когда использовать named volumes вместо bind mounts?",
"options": ["Когда нужно привязать директорию хоста", "Когда данные должны управляться Docker (переносимость)", "Bind mounts безопаснее", "Named volumes не работают в Compose"],
"correct": 1
},
{
"text": "Какая команда запускает приложение через Docker Compose?",
"options": ["docker run compose", "docker-compose up", "docker compose start", "compose run"],
"correct": 1
}
]
},
{
"title": "Безопасность и лучшие практики",
"content": "Безопасность Docker: запуск от непривилегированного пользователя (`USER` в Dockerfile), избегание `--privileged`, использование минимальных образов (-slim, -alpine), сканирование уязвимостей (trivy), не хранение секретов в образе (использовать docker secrets или переменные окружения при запуске). Лучшие практики: всегда указывать конкретную версию образа (не latest), использовать .dockerignore, объединять RUN-команды, многоэтапная сборка, HEALTHCHECK для мониторинга. Запуск: `docker run --read-only --tmpfs /tmp ...` для дополнительной защиты.",
"questions": [
{
"text": "Как запустить контейнер от непривилегированного пользователя?",
"options": ["Использовать sudo внутри контейнера", "Добавить USER nobody в Dockerfile", "Запустить с --privileged", "Это невозможно"],
"correct": 1
},
{
"text": "Почему не стоит хранить секреты (пароли, ключи) в Dockerfile?",
"options": ["Они видны в истории слоёв образа", "Dockerfile не поддерживает секреты", "Секреты замедляют сборку", "Они автоматически удаляются"],
"correct": 0
},
{
"text": "Какой флаг делает ФС контейнера доступной только для чтения?",
"options": ["--read-only", "--no-write", "--secure", "--readonly"],
"correct": 0
}
]
},
{
"title": "Диагностика проблем в Docker",
"content": "Контейнер запущен, но приложение недоступно? Проверяйте: `docker logs <container>` (логи), `docker exec -it <container> sh` (заход в контейнер), `docker port <container>` (проброшенные порты), `docker inspect <container>` (детали). Проблемы с сетью между контейнерами? Убедитесь, что они в одной пользовательской сети. Высокое потребление памяти? Ограничьте через `--memory=512m` и мониторьте `docker stats`. Ошибки сборки? Читайте вывод шага, проверяйте пути в COPY, наличие файлов в .dockerignore. Частые ошибки: порт уже занят, нет EXPOSE, приложение слушает только localhost (а не 0.0.0.0).",
"questions": [
{
"text": "Как посмотреть логи контейнера?",
"options": ["docker log", "docker logs", "docker inspect --logs", "journalctl -u docker"],
"correct": 1
},
{
"text": "Почему приложение в контейнере может быть недоступно извне, даже если порт проброшен?",
"options": ["Приложение слушает только 127.0.0.1, а не 0.0.0.0", "Docker не поддерживает TCP", "Нужен перезапуск хоста", "Порт должен быть выше 10000"],
"correct": 0
},
{
"text": "Какой командой зайти в запущенный контейнер?",
"options": ["docker attach", "docker exec -it", "docker shell", "docker run --inside"],
"correct": 1
},
{
"text": "Как ограничить память контейнера?",
"options": ["--ram=512m", "--memory=512m", "--mem-limit=512m", "Docker не позволяет ограничить память"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Docker (Junior)",
"content": "Финальный тест по Docker. 25+ вопросов на все ключевые темы: архитектура, образы, Dockerfile, сети, тома, безопасность, диагностика.",
"questions": [
{
"text": "Что такое Docker?",
"options": ["Гипервизор для VM", "Платформа контейнеризации на основе ядра Linux", "Менеджер пакетов", "Сетевой протокол"],
"correct": 1
},
{
"text": "В чём разница между образом и контейнером?",
"options": ["Образ — запущенный экземпляр, контейнер — шаблон", "Контейнер — запущенный экземпляр образа", "Нет разницы", "Образ хранится в облаке, контейнер — локально"],
"correct": 1
},
{
"text": "Какая инструкция в Dockerfile задаёт базовый образ?",
"options": ["BASE", "IMAGE", "FROM", "COPY"],
"correct": 2
},
{
"text": "Что делает инструкция EXPOSE в Dockerfile?",
"options": ["Открывает порт на хосте", "Указывает, какие порты использует приложение (документация)", "Блокирует порт", "Перенаправляет трафик"],
"correct": 1
},
{
"text": "Какой командой собрать образ из Dockerfile?",
"options": ["docker run", "docker build", "docker create", "docker compose"],
"correct": 1
},
{
"text": "Что такое multi-stage build?",
"options": ["Сборка образа на нескольких серверах", "Многоэтапная сборка для уменьшения размера финального образа", "Сборка с несколькими Dockerfile", "Тип сети"],
"correct": 1
},
{
"text": "Какой файл исключает ненужные файлы из COPY в Dockerfile?",
"options": [".gitignore", ".dockerignore", "exclude.txt", "Dockerfile.ignore"],
"correct": 1
},
{
"text": "В чём разница между ADD и COPY?",
"options": ["ADD только копирует, COPY может распаковывать", "COPY только копирует, ADD может распаковывать архивы и скачивать URL", "Нет разницы", "ADD работает только в Compose"],
"correct": 1
},
{
"text": "Как переопределить ENTRYPOINT при запуске контейнера?",
"options": ["Это невозможно", "Через --entrypoint", "Через -e", "Через docker update"],
"correct": 1
},
{
"text": "Какой тип сети Docker используется по умолчанию?",
"options": ["host", "none", "bridge", "overlay"],
"correct": 2
},
{
"text": "Что такое bind mount?",
"options": ["Том, управляемый Docker", "Привязка директории хоста в контейнер", "Тип сети", "Метод шифрования"],
"correct": 1
},
{
"text": "Какой командой остановить контейнер грациозно?",
"options": ["docker kill", "docker stop", "docker pause", "docker rm"],
"correct": 1
},
{
"text": "Что делает docker pause?",
"options": ["Полностью останавливает контейнер", "Замораживает процессы, сохраняя состояние в памяти", "Удаляет контейнер", "Перезапускает контейнер"],
"correct": 1
},
{
"text": "Какой флаг ограничивает CPU до 0.5 ядра?",
"options": ["--cpus=0.5", "--cpu=0.5", "--cores=0.5", "--cpu-limit=0.5"],
"correct": 0
},
{
"text": "Почему важно запускать контейнер от непривилегированного пользователя?",
"options": ["Для ускорения работы", "Для безопасности (ограничение привилегий)", "Для совместимости с Windows", "Это требование Docker Hub"],
"correct": 1
},
{
"text": "Как посмотреть использование ресурсов контейнерами?",
"options": ["docker top", "docker stats", "docker ps -a", "docker info"],
"correct": 1
},
{
"text": "Что такое Docker Compose?",
"options": ["Инструмент для оркестрации кластеров", "Инструмент для запуска мультконтейнерных приложений из YAML", "Замена Docker", "Тип тома"],
"correct": 1
},
{
"text": "Какой командой увидеть список запущенных контейнеров?",
"options": ["docker list", "docker ps", "docker containers", "docker show"],
"correct": 1
},
{
"text": "Что делать, если сборка Dockerfile падает на шаге COPY?",
"options": ["Переустановить Docker", "Проверить, существуют ли файлы и не исключены ли они в .dockerignore", "Использовать ADD вместо COPY", "Запустить с --force"],
"correct": 1
},
{
"text": "Какой инструмент используется для сканирования уязвимостей в образах?",
"options": ["docker scan", "trivy", "clair", "Все вышеперечисленные"],
"correct": 3
},
{
"text": "Что такое cgroups в контексте Docker?",
"options": ["Технология изоляции файловой системы", "Технология ограничения ресурсов (CPU, RAM)", "Тип сети", "Метод аутентификации"],
"correct": 1
},
{
"text": "Какой командой удалить неиспользуемые образы и тома?",
"options": ["docker system prune", "docker clean", "docker rm -all", "docker prune"],
"correct": 0
},
{
"text": "Что такое healthcheck в Docker?",
"options": ["Проверка состояния диска хоста", "Инструкция для периодической проверки работоспособности приложения", "Метод шифрования", "Тип логов"],
"correct": 1
},
{
"text": "Какой командой подключиться к запущенному контейнеру и выполнить команду?",
"options": ["docker connect", "docker run --inside", "docker exec", "docker attach --command"],
"correct": 2
},
{
"text": "Что произойдёт, если не указать тег образа (например, nginx вместо nginx:alpine)?",
"options": ["Docker выберет случайный тег", "Будет использован тег latest", "Сборка упадёт", "Используется самый старый тег"],
"correct": 1
},
{
"text": "Какой командой посмотреть детали контейнера (сети, тома, переменные)?",
"options": ["docker info", "docker describe", "docker inspect", "docker details"],
"correct": 2
},
{
"text": "Что делает инструкция WORKDIR в Dockerfile?",
"options": ["Устанавливает права на файлы", "Задаёт рабочую директорию для последующих команд", "Копирует файлы", "Создаёт пользователя"],
"correct": 1
}
]
}
],
"kubernetes": [
{
"title": "Архитектура Kubernetes: Control Plane и Worker Nodes",
"content": "Kubernetes-кластер состоит из Control Plane (управляющий слой) и Worker Nodes (рабочие узлы). Control Plane: kube-apiserver — центральный API для управления, etcd — распределённое хранилище состояния кластера, kube-scheduler — распределяет поды по узлам, kube-controller-manager — управляет контроллерами (реплик, узлов и т.д.). На каждом Worker Node работает: kubelet — агент для запуска подов, kube-proxy — сетевой прокси для балансировки трафика, Container Runtime (containerd, CRI-O) — запускает контейнеры. Пользователь взаимодействует через kubectl → kube-apiserver → etcd. Контроллеры и планировщик реагируют на изменения — kubelet запускает поды. Это обеспечивает самовосстановление, масштабирование и отказоустойчивость.",
"questions": [
{
"text": "Какой компонент Kubernetes хранит всё состояние кластера?",
"options": ["kube-apiserver", "etcd", "kube-scheduler", "kubelet"],
"correct": 1
},
{
"text": "Какой компонент запускает контейнеры на рабочем узле?",
"options": ["kube-proxy", "kubelet", "kube-scheduler", "etcd"],
"correct": 1
},
{
"text": "Через какой компонент проходят все команды kubectl?",
"options": ["kube-scheduler", "kube-controller-manager", "kube-apiserver", "kubelet"],
"correct": 2
}
]
},
{
"title": "Основные объекты Kubernetes: Pod, Service, Deployment",
"content": "Pod — минимальная единица развёртывания, содержит 1+ контейнеров с общим сетевым пространством и томами. Service — предоставляет стабильный IP/DNS для доступа к группе подов (типы: ClusterIP, NodePort, LoadBalancer). Deployment — управляет репликами подов: масштабирование, rolling-обновления, откаты. Deployment создаёт ReplicaSet, который следит за количеством подов. ConfigMap и Secret хранят конфигурацию и чувствительные данные (пароли в base64). PersistentVolume (PV) и PersistentVolumeClaim (PVC) — для постоянного хранилища. Namespace изолирует ресурсы (prod, dev). Для запуска: `kubectl apply -f manifest.yml`.",
"questions": [
{
"text": "Что такое Pod в Kubernetes?",
"options": ["Группа сервисов", "Минимальная единица развёртывания (1+ контейнеров)", "Тип сети", "Хранилище конфигурации"],
"correct": 1
},
{
"text": "Какой тип Service открывает порт на всех узлах кластера?",
"options": ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"],
"correct": 1
},
{
"text": "Что делает Deployment?",
"options": ["Хранит пароли", "Управляет репликами подов с поддержкой обновлений", "Создаёт тома", "Обеспечивает сетевую изоляцию"],
"correct": 1
},
{
"text": "Где хранятся чувствительные данные в Kubernetes?",
"options": ["ConfigMap", "Secret", "PersistentVolume", "Namespace"],
"correct": 1
}
]
},
{
"title": "StatefulSet vs Deployment и управление состоянием",
"content": "Deployment — для stateless-приложений (веб-серверы, API): поды взаимозаменяемы, имена случайные, данные временные. StatefulSet — для stateful-приложений (БД, Kafka): каждый под имеет фиксированное имя (pod-0, pod-1), постоянный PersistentVolume, запуск/удаление в строгом порядке. StatefulSet использует volumeClaimTemplates для привязки уникального тома к каждому поду. Headless Service (без ClusterIP) позволяет обращаться напрямую к подам по DNS. Выбор: Deployment — для масштабируемых сервисов, StatefulSet — для баз данных и систем, где важен порядок и состояние.",
"questions": [
{
"text": "В чём ключевое отличие StatefulSet от Deployment?",
"options": ["StatefulSet не поддерживает реплики", "StatefulSet даёт фиксированные имена подов и постоянное хранилище", "Deployment работает только в облаке", "StatefulSet не использует PersistentVolume"],
"correct": 1
},
{
"text": "Для какого типа приложений подходит StatefulSet?",
"options": ["Nginx", "REST API", "MySQL", "Фронтенд-приложение"],
"correct": 2
},
{
"text": "Что такое Headless Service?",
"options": ["Сервис без IP, для прямого доступа к подам по DNS", "Сервис только для внутреннего трафика", "Балансировщик нагрузки", "Тип тома"],
"correct": 0
}
]
},
{
"title": "Сети, Ingress и CNI в Kubernetes",
"content": "Kubernetes использует плагины CNI (Calico, Flannel, WeaveNet) для настройки сети. Каждый под получает уникальный IP из диапазона podCIDR. Сервисы используют ClusterIP для внутренней балансировки. Для внешнего доступа: NodePort (порт на узле), LoadBalancer (облачный балансировщик), или Ingress — объект для маршрутизации HTTP/HTTPS-трафика по правилам (host, path). Ingress требует Ingress Controller (Nginx, Traefik). Ingress Controller завершает TLS, балансирует нагрузку и централизует входящий трафик. Для ограничения трафика между подами — NetworkPolicy.",
"questions": [
{
"text": "Как реализована сеть в Kubernetes?",
"options": ["Через iptables напрямую", "Через плагины CNI (Calico, Flannel)", "Через Docker-сеть", "Сеть не поддерживается"],
"correct": 1
},
{
"text": "Что делает Ingress Controller?",
"options": ["Хранит конфигурацию", "Маршрутизирует HTTP/HTTPS-трафик по правилам Ingress", "Создаёт PersistentVolume", "Управляет репликами"],
"correct": 1
},
{
"text": "Какой объект позволяет ограничить сетевое взаимодействие между подами?",
"options": ["Service", "NetworkPolicy", "ConfigMap", "Secret"],
"correct": 1
}
]
},
{
"title": "Безопасность, ресурсы и отказоустойчивость",
"content": "Безопасность: RBAC (Role-Based Access Control) ограничивает права пользователей и сервисных аккаунтов. Секреты (Secret) хранят данные в base64. Ресурсы: в контейнере указываются requests (гарантированные ресурсы) и limits (максимум). Это нужно для правильного планирования и предотвращения 'голодания' других подов. Отказоустойчивость: несколько master-узлов с etcd в кластере, размещение worker-узлов в разных зонах, liveness/readiness-пробы для самовосстановления, HPA (Horizontal Pod Autoscaler) для масштабирования по CPU/памяти. Резервное копирование etcd — критично для восстановления кластера.",
"questions": [
{
"text": "Что такое liveness probe?",
"options": ["Проверяет готовность пода к трафику", "Проверяет, жив ли под — перезапускает при сбое", "Проверяет запуск контейнера", "Проверяет использование CPU"],
"correct": 1
},
{
"text": "Как ограничить ресурсы контейнера в Kubernetes?",
"options": ["Через limits и requests в манифесте", "Через Dockerfile", "Через CNI", "Это невозможно"],
"correct": 0
},
{
"text": "Что обеспечивает RBAC в Kubernetes?",
"options": ["Сетевую изоляцию", "Управление правами доступа", "Балансировку нагрузки", "Хранение секретов"],
"correct": 1
},
{
"text": "Что делает HPA (Horizontal Pod Autoscaler)?",
"options": ["Масштабирует ноды", "Масштабирует количество подов по метрикам", "Создаёт резервные копии", "Управляет томами"],
"correct": 1
}
]
},
{
"title": "Диагностика и продвинутые объекты: DaemonSet, Job, Helm",
"content": "DaemonSet запускает под на каждом узле — для мониторинга (Node Exporter), логирования (Fluentd). Job запускает под до завершения задачи (миграции, резервное копирование). CronJob — периодический запуск Job по расписанию. Helm — менеджер пакетов для Kubernetes: упрощает развёртывание через шаблоны (Charts), управление версиями и откаты. Диагностика: `kubectl get pods`, `kubectl describe pod`, `kubectl logs`, `kubectl top pods` (требует Metrics Server). Если под в статусе CrashLoopBackOff — проверяйте логи и liveness-пробы. Если Pending — не хватает ресурсов или нет подходящего узла.",
"questions": [
{
"text": "Для чего используется DaemonSet?",
"options": ["Для запуска пода на каждом узле", "Для масштабирования веб-приложения", "Для хранения конфигурации", "Для балансировки трафика"],
"correct": 0
},
{
"text": "Что такое Helm?",
"options": ["Сетевой плагин", "Менеджер пакетов для Kubernetes", "Тип тома", "Контроллер реплик"],
"correct": 1
},
{
"text": "Какой объект запускает задачу по расписанию?",
"options": ["Deployment", "StatefulSet", "CronJob", "Service"],
"correct": 2
}
]
},
{
"title": "Итоговый тест: Kubernetes (Junior)",
"content": "Финальный тест по Kubernetes. 25+ вопросов на архитектуру, объекты, сети, безопасность и диагностику.",
"questions": [
{
"text": "Что такое Kubernetes?",
"options": ["Менеджер пакетов", "Платформа для оркестрации контейнеров", "Тип виртуальной машины", "Сетевой протокол"],
"correct": 1
},
{
"text": "Какой компонент выбирает узел для запуска пода?",
"options": ["kubelet", "kube-scheduler", "kube-proxy", "etcd"],
"correct": 1
},
{
"text": "Что хранится в etcd?",
"options": ["Логи подов", "Всё состояние кластера", "Образы контейнеров", "Сетевые правила"],
"correct": 1
},
{
"text": "Может ли Pod содержать несколько контейнеров?",
"options": ["Нет, только один", "Да, обычно основной + sidecar", "Только в StatefulSet", "Только в Job"],
"correct": 1
},
{
"text": "Какой объект обеспечивает стабильный доступ к подам?",
"options": ["Pod", "Deployment", "Service", "ConfigMap"],
"correct": 2
},
{
"text": "В чём разница между Deployment и ReplicaSet?",
"options": ["Нет разницы", "ReplicaSet поддерживает обновления", "Deployment использует ReplicaSet и добавляет обновления/откаты", "Deployment не поддерживает реплики"],
"correct": 2
},
{
"text": "Для чего используется readiness probe?",
"options": ["Перезапускать под при сбое", "Определять, готов ли под к трафику", "Проверять запуск контейнера", "Измерять CPU"],
"correct": 1
},
{
"text": "Какой тип Service создаёт внешний балансировщик в облаке?",
"options": ["ClusterIP", "NodePort", "LoadBalancer", "Headless"],
"correct": 2
},
{
"text": "Что такое PersistentVolumeClaim (PVC)?",
"options": ["Физический диск", "Запрос на выделение постоянного тома", "Тип сети", "Конфигурация пода"],
"correct": 1
},
{
"text": "Где хранятся пароли и ключи в Kubernetes?",
"options": ["ConfigMap", "Secret", "PersistentVolume", "Deployment"],
"correct": 1
},
{
"text": "Что делает kubelet?",
"options": ["Маршрутизирует трафик", "Запускает и управляет подами на узле", "Хранит состояние кластера", "Планирует размещение подов"],
"correct": 1
},
{
"text": "Какой объект используется для stateful-приложений?",
"options": ["Deployment", "StatefulSet", "DaemonSet", "Job"],
"correct": 1
},
{
"text": "Что такое Ingress?",
"options": ["Тип тома", "Объект для маршрутизации HTTP/HTTPS", "Контроллер реплик", "Тип секрета"],
"correct": 1
},
{
"text": "Как запустить под на каждом узле?",
"options": ["Deployment", "StatefulSet", "DaemonSet", "ReplicaSet"],
"correct": 2
},
{
"text": "Что такое Horizontal Pod Autoscaler (HPA)?",
"options": ["Масштабирует ноды", "Масштабирует поды по CPU/памяти", "Балансирует трафик", "Управляет томами"],
"correct": 1
},
{
"text": "Какой командой посмотреть логи пода?",
"options": ["kubectl logs", "kubectl describe", "kubectl get", "kubectl top"],
"correct": 0
},
{
"text": "Что такое Namespace?",
"options": ["Тип сети", "Логическая изоляция ресурсов", "Хранилище образов", "Контейнерный рантайм"],
"correct": 1
},
{
"text": "Какой компонент управляет сетевыми правилами на узле?",
"options": ["kubelet", "kube-proxy", "CNI", "etcd"],
"correct": 1
},
{
"text": "Что произойдёт, если под не уложится в requests по памяти?",
"options": ["Он не запустится", "Он будет убит OOM Killer", "Он продолжит работать", "Kubernetes увеличит лимит автоматически"],
"correct": 0
},
{
"text": "Какой объект запускает задачу до завершения?",
"options": ["Deployment", "StatefulSet", "Job", "DaemonSet"],
"correct": 2
},
{
"text": "Что такое Helm Chart?",
"options": ["Тип тома", "Шаблон развёртывания приложения", "Сетевой плагин", "Контроллер безопасности"],
"correct": 1
},
{
"text": "Какой статус у пода, если он постоянно падает и перезапускается?",
"options": ["Running", "Pending", "CrashLoopBackOff", "Succeeded"],
"correct": 2
},
{
"text": "Что такое RBAC в Kubernetes?",
"options": ["Сетевой контроллер", "Система управления доступом на основе ролей", "Тип тома", "Протокол аутентификации"],
"correct": 1
},
{
"text": "Какой командой применить манифест?",
"options": ["kubectl create", "kubectl apply", "kubectl run", "kubectl start"],
"correct": 1
},
{
"text": "Сколько экземпляров Control Plane нужно для HA?",
"options": ["1", "2", "3 или нечётное число", "Зависит от количества подов"],
"correct": 2
}
]
}
],
"cicd": [
{
"title": "Основы CI/CD: что такое pipeline?",
"content": "CI/CD — это практика автоматизации этапов разработки и доставки ПО. CI (Continuous Integration) — непрерывная интеграция: при каждом коммите в Git запускается pipeline для сборки кода и запуска тестов. CD (Continuous Delivery/Deployment) — непрерывная доставка/развёртывание: после прохождения тестов артефакт автоматически доставляется в staging или сразу в production. Pipeline — последовательность этапов (stages): checkout → build → test → deploy. Основная цель: быстрая и безопасная доставка изменений с минимальным участием человека.",
"questions": [
{
"text": "Что означает CI в CI/CD?",
"options": ["Continuous Installation", "Continuous Integration", "Code Inspection", "Container Infrastructure"],
"correct": 1
},
{
"text": "В чём разница между Continuous Delivery и Continuous Deployment?",
"options": ["Delivery — ручной релиз, Deployment — автоматический", "Delivery — только для тестов, Deployment — для продакшена", "Нет разницы", "Deployment не использует Git"],
"correct": 0
},
{
"text": "Когда запускается CI pipeline?",
"options": ["Раз в день", "При каждом коммите в Git", "Только при релизе", "Вручную администратором"],
"correct": 1
}
]
},
{
"title": "Git, ветвление и триггеры",
"content": "Git — основа CI/CD. Популярные стратегии ветвления: GitFlow (feature → develop → release → main) и trunk-based development (все работают в main, используют фича-флаги). CI pipeline запускается по триггеру: push в ветку, pull request, тег. Например, в GitHub Actions: `on: [push, pull_request]`. Важно: pipeline должен быть идемпотентным (повторный запуск даёт тот же результат) и быстрым (идеально — <10 минут). Для ускорения — кэширование зависимостей (npm, pip) и параллельное выполнение задач.",
"questions": [
{
"text": "Какая стратегия ветвления предполагает частые коммиты в main?",
"options": ["GitFlow", "Trunk-based development", "Release branching", "Feature toggling"],
"correct": 1
},
{
"text": "Что может быть триггером для CI pipeline?",
"options": ["Только ручной запуск", "Push в Git-ветку", "Изменение DNS", "Перезагрузка сервера"],
"correct": 1
},
{
"text": "Как ускорить CI pipeline?",
"options": ["Убрать все тесты", "Использовать кэширование и параллельные задачи", "Запускать ночью", "Использовать самые дешёвые runner'ы"],
"correct": 1
}
]
},
{
"title": "GitHub Actions и GitLab CI: основы",
"content": "GitHub Actions и GitLab CI — встроенные системы CI/CD в Git-платформы. Workflow (в GH Actions) или Pipeline (в GitLab CI) описывается в YAML-файле в папке `.github/workflows/` или `.gitlab-ci.yml`. Основные блоки: jobs (задачи), steps (шаги), runners (машины для выполнения). Пример: собрать Docker-образ → прогнать тесты → отправить в registry. Secrets (секреты) хранятся в настройках репозитория и подставляются в pipeline как переменные окружения. Важно: никогда не храните секреты в коде!",
"questions": [
{
"text": "Где описывается pipeline в GitHub Actions?",
"options": [".gitlab-ci.yml", ".github/workflows/*.yml", "Dockerfile", "package.json"],
"correct": 1
},
{
"text": "Где в GitLab CI хранится конфигурация pipeline?",
"options": [".github/workflows/ci.yml", ".gitlab-ci.yml", "Jenkinsfile", "Makefile"],
"correct": 1
},
{
"text": "Как безопасно использовать пароли/API-ключи в CI?",
"options": ["Хранить в коде", "Передавать в коммитах", "Использовать Secrets в настройках репозитория", "Писать в логи"],
"correct": 2
}
]
},
{
"title": "Артефакты, образы и стратегии деплоя",
"content": "Артефакт — результат сборки: исполняемый файл, Docker-образ, пакет. Docker-образы пушатся в registry (Docker Hub, GitLab Registry, AWS ECR). Важно: тегировать образы по Git-хешу или версии (не использовать latest!). Стратегии деплоя: 1) Rolling update — постепенная замена подов (K8s по умолчанию). 2) Blue/Green — два идентичных окружения, переключение трафика. 3) Canary — выпуск новой версии части пользователей. Выбор зависит от требований к uptime и риску. Canary позволяет быстро откатиться при ошибках.",
"questions": [
{
"text": "Почему не стоит использовать тег latest для образов в CI/CD?",
"options": ["Он самый большой", "Он нестабилен и ломает воспроизводимость", "Он не поддерживается в K8s", "Он бесплатный"],
"correct": 1
},
{
"text": "Какая стратегия деплоя подразумевает переключение трафика между двумя окружениями?",
"options": ["Rolling update", "Blue/Green", "Canary", "Recreate"],
"correct": 1
},
{
"text": "Что такое артефакт в CI/CD?",
"options": ["Исходный код", "Результат сборки (образ, бинарник)", "Лог ошибок", "Git-коммит"],
"correct": 1
},
{
"text": "Какая стратегия деплоя выпускает новую версию для части пользователей?",
"options": ["Blue/Green", "Rolling", "Canary", "Hotfix"],
"correct": 2
}
]
},
{
"title": "Безопасность и продвинутые практики",
"content": "Безопасность в CI/CD: 1) Secrets — только через защищённые переменные, никогда в коде. 2) SAST (Static Application Security Testing) — анализ кода на уязвимости (например, через Snyk, Trivy, SonarQube). 3) Сканирование Docker-образов на CVE. 4) Минимальные права для runner'ов. Продвинутые практики: 1) GitOps — деплой через Git (FluxCD, ArgoCD). 2) Infrastructure as Code (Terraform) в pipeline. 3) Тесты в production-подобной среде (staging). 4) Откат по Git-тегу или Helm-релизу. CI/CD — не просто автоматизация, а культура доставки ценности быстро и безопасно.",
"questions": [
{
"text": "Что такое SAST?",
"options": ["Сканирование образов", "Статический анализ кода на уязвимости", "Тестирование нагрузки", "Балансировка трафика"],
"correct": 1
},
{
"text": "Какой подход использует Git как единственный источник истины для деплоя?",
"options": ["CI/CD", "GitOps", "DevSecOps", "Trunk-based"],
"correct": 1
},
{
"text": "Где НЕЛЬЗЯ хранить секреты (пароли, ключи)?",
"options": ["В Secrets репозитория", "В переменных окружения CI", "В исходном коде", "В HashiCorp Vault"],
"correct": 2
}
]
},
{
"title": "Итоговый тест: CI/CD (Junior)",
"content": "Финальный тест по CI/CD. 15 вопросов на основы, Git, пайплайны, деплой и безопасность.",
"questions": [
{
"text": "Что такое CI/CD?",
"options": ["Система мониторинга", "Практика автоматизации сборки, тестов и деплоя", "Тип виртуальной машины", "Протокол передачи данных"],
"correct": 1
},
{
"text": "Когда запускается CI pipeline в идеальном сценарии?",
"options": ["Раз в неделю", "При ручной команде", "При каждом коммите в Git", "Только в продакшене"],
"correct": 2
},
{
"text": "Где в GitHub хранится конфигурация Actions?",
"options": [".gitlab-ci.yml", ".github/workflows/", "Jenkinsfile", "/ci/"],
"correct": 1
},
{
"text": "Что такое артефакт в CI/CD?",
"options": ["Исходный код", "Результат сборки (например, Docker-образ)", "Git-ветка", "Лог ошибки"],
"correct": 1
},
{
"text": "Какой стратегией деплоя K8s использует по умолчанию?",
"options": ["Blue/Green", "Canary", "Rolling update", "Recreate"],
"correct": 2
},
{
"text": "Почему важно не использовать latest-тег для образов?",
"options": ["Он медленнее", "Он нарушает воспроизводимость и стабильность", "Он не поддерживается", "Он занимает больше места"],
"correct": 1
},
{
"text": "Как безопасно передать API-ключ в pipeline?",
"options": ["Закодировать в base64 в коде", "Использовать Secrets в настройках репозитория", "Написать в README", "Передать через коммит"],
"correct": 1
},
{
"text": "Что такое trunk-based development?",
"options": ["Работа в долгоживущих ветках", "Частые коммиты в main/trunk", "Использование только тегов", "Отказ от Git"],
"correct": 1
},
{
"text": "Какой инструмент относится к GitOps?",
"options": ["Jenkins", "GitHub Actions", "ArgoCD", "Prometheus"],
"correct": 2
},
{
"text": "Что делает SAST-инструмент?",
"options": ["Сканирует образы", "Анализирует исходный код на уязвимости", "Тестирует производительность", "Балансирует нагрузку"],
"correct": 1
},
{
"text": "Какая стратегия деплоя позволяет быстро откатиться, протестировав на части пользователей?",
"options": ["Rolling", "Blue/Green", "Canary", "Recreate"],
"correct": 2
},
{
"text": "Где в GitLab CI описывается pipeline?",
"options": [".github/workflows/ci.yml", ".gitlab-ci.yml", "Makefile", "Dockerfile"],
"correct": 1
},
{
"text": "Что такое Continuous Deployment?",
"options": ["Ручной релиз после тестов", "Автоматический деплой в продакшен после прохождения тестов", "Только сборка кода", "Только запуск тестов"],
"correct": 1
},
{
"text": "Какой принцип CI/CD помогает избежать 'integration hell'?",
"options": ["Редкие коммиты", "Частая интеграция и тестирование", "Использование только main-ветки", "Отказ от тестов"],
"correct": 1
},
{
"text": "Что такое runner в CI/CD?",
"options": ["Автор пайплайна", "Машина, на которой выполняются задачи", "Тип артефакта", "Сервис мониторинга"],
"correct": 1
}
]
}
],
"monitoring": [
{
"title": "Основы мониторинга: Observability и её три кита",
"content": "Observability (наблюдаемость) — способность понимать внутреннее состояние системы по её внешним сигналам. Три кита observability: 1) Метрики — числовые данные во времени (CPU, память, количество запросов). 2) Логи — текстовые записи о событиях (ошибки, запросы). 3) Трейсы — цепочки вызовов в распределённой системе (как запрос прошёл через микросервисы). Мониторинг — сбор и анализ этих данных для выявления проблем до того, как их заметят пользователи. Health-checks (liveness/readiness) — часть мониторинга: они говорят оруркестратору (K8s), живо ли приложение и готово ли к трафику.",
"questions": [
{
"text": "Какие три компонента составляют observability?",
"options": ["CPU, RAM, Disk", "Метрики, логи, трейсы", "HTTP, TCP, ICMP", "Pods, Services, Deployments"],
"correct": 1
},
{
"text": "Что такое liveness probe в Kubernetes?",
"options": ["Проверка готовности к трафику", "Проверка, живо ли приложение (перезапуск при сбое)", "Сбор логов", "Измерение latency"],
"correct": 1
},
{
"text": "Зачем нужен readiness probe?",
"options": ["Для перезапуска пода", "Чтобы Kubernetes не отправлял трафик, пока приложение не готово", "Для сбора метрик CPU", "Для резервного копирования"],
"correct": 1
}
]
},
{
"title": "Prometheus: сбор и хранение метрик",
"content": "Prometheus — система мониторинга с открытым исходным кодом, специально созданная для сбора метрик. Работает по pull-модели: опрашивает (scrape) цели (targets) по HTTP-эндпоинту `/metrics` с заданной периодичностью. Метрики хранятся в собственной TSDB (time-series базе данных). Поддерживает мощный язык запросов PromQL для анализа и агрегации. Экспортеры (node_exporter, cadvisor) собирают метрики с хостов, контейнеров, баз данных. В Kubernetes Prometheus обнаруживает сервисы через ServiceMonitor или ingress.",
"questions": [
{
"text": "Как работает Prometheus?",
"options": ["Push-модель (приложение отправляет метрики)", "Pull-модель (Prometheus опрашивает эндпоинты)", "Через логи", "Только в облаке"],
"correct": 1
},
{
"text": "Какой эндпоинт использует Prometheus для сбора метрик?",
"options": ["/health", "/logs", "/metrics", "/status"],
"correct": 2
},
{
"text": "Какой инструмент собирает метрики с Linux-хоста для Prometheus?",
"options": ["Filebeat", "node_exporter", "Loki", "Alertmanager"],
"correct": 1
}
]
},
{
"title": "Grafana: визуализация данных",
"content": "Grafana — платформа для визуализации метрик, логов и трейсов. Она подключается к источникам данных (например, Prometheus, Loki, Elasticsearch) и отображает информацию на дашбордах. Дашборды состоят из панелей: графики, таблицы, статусные индикаторы. Grafana позволяет строить сложные визуализации, задавать переменные (например, выбор ноды), настраивать аннотации (деплои, инциденты). В DevOps Grafana — стандарт для отображения состояния инфраструктуры и приложений в реальном времени.",
"questions": [
{
"text": "Какой источник данных чаще всего используется с Grafana для метрик?",
"options": ["Loki", "Prometheus", "Filebeat", "Kibana"],
"correct": 1
},
{
"text": "Что такое дашборд в Grafana?",
"options": ["Скрипт для сбора метрик", "Веб-интерфейс для визуализации данных", "Тип алерта", "Экспортёр"],
"correct": 1
},
{
"text": "Можно ли в Grafana отображать логи и метрики на одном дашборде?",
"options": ["Нет, только метрики", "Да, если настроены соответствующие источники", "Только через Kibana", "Это невозможно по архитектуре"],
"correct": 1
}
]
},
{
"title": "Алертинг: Alertmanager и реакция на инциденты",
"content": "Алертинг — система уведомлений о проблемах. В экосистеме Prometheus за это отвечает Alertmanager. Правила алертов (alerting rules) задаются в Prometheus: например, 'если CPU > 90% 5 минут, создать алерт'. Prometheus отправляет алерты в Alertmanager, который дедуплицирует, группирует и отправляет уведомления в Slack, Email, PagerDuty и т.д. Важно: алерты должны быть actionable (можно предпринять действие), избегать шума (alert fatigue). Пример полезного алерта: 'HTTP-ошибки 5xx > 1% за 5 минут'.",
"questions": [
{
"text": "Какой компонент отвечает за отправку уведомлений в экосистеме Prometheus?",
"options": ["Grafana", "node_exporter", "Alertmanager", "kube-state-metrics"],
"correct": 2
},
{
"text": "Где задаются правила алертов?",
"options": ["В Alertmanager", "В Grafana", "В Prometheus", "В самом приложении"],
"correct": 2
},
{
"text": "Что такое 'alert fatigue'?",
"options": ["Усталость от большого количества бесполезных алертов", "Сбой в Alertmanager", "Задержка уведомлений", "Ошибка в PromQL"],
"correct": 0
}
]
},
{
"title": "Логи: от сбора до анализа",
"content": "Логи — текстовые записи о событиях в приложении или системе. Сбор логов в Kubernetes часто делают через sidecar-контейнеры или демонсеты (Fluentd, Fluent Bit). Популярные стеки: ELK (Elasticsearch, Logstash, Kibana) и EFK (Fluentd вместо Logstash). Лёгкая альтернатива — Grafana Loki: хранит логи без полного индексирования (дешевле), интегрируется с Grafana. LogQL — язык запросов для Loki. Важно: структурированные логи (JSON) проще парсить и фильтровать. Не храните всё — задайте политику ретеншена (например, 7 дней).",
"questions": [
{
"text": "Какой стек включает Elasticsearch, Fluentd и Kibana?",
"options": ["ELK", "EFK", "PLG", "GEL"],
"correct": 1
},
{
"text": "Какой инструмент является лёгкой альтернативой ELK для логов?",
"options": ["Prometheus", "Loki", "Alertmanager", "cadvisor"],
"correct": 1
},
{
"text": "Почему структурированные логи (JSON) лучше?",
"options": ["Они занимают меньше места", "Их проще парсить и фильтровать", "Они шифруются автоматически", "Они не требуют сбора"],
"correct": 1
}
]
},
{
"title": "Итоговый тест: Мониторинг (Junior)",
"content": "Финальный тест по мониторингу. 15 вопросов на observability, Prometheus, Grafana, алертинг и логи.",
"questions": [
{
"text": "Что из перечисленного НЕ является частью observability?",
"options": ["Метрики", "Логи", "Трейсы", "Бэкапы"],
"correct": 3
},
{
"text": "Какой компонент собирает метрики с хостов для Prometheus?",
"options": ["Grafana", "Alertmanager", "node_exporter", "Loki"],
"correct": 2
},
{
"text": "Как Prometheus получает метрики от приложений?",
"options": ["Приложение отправляет метрики (push)", "Prometheus опрашивает эндпоинт /metrics (pull)", "Через логи", "Через Kubernetes API"],
"correct": 1
},
{
"text": "Какой инструмент визуализирует данные из Prometheus?",
"options": ["Kibana", "Loki", "Grafana", "Elasticsearch"],
"correct": 2
},
{
"text": "Что делает Alertmanager?",
"options": ["Собирает метрики", "Хранит логи", "Отправляет уведомления об алертах", "Строит дашборды"],
"correct": 2
},
{
"text": "Где задаются правила для создания алертов?",
"options": ["В Grafana", "В Alertmanager", "В конфигурации Prometheus", "В самом приложении"],
"correct": 2
},
{
"text": "Какой стек использует Fluentd вместо Logstash?",
"options": ["ELK", "EFK", "PLG", "Loki-Grafana"],
"correct": 1
},
{
"text": "Какой инструмент хранит логи и интегрируется с Grafana?",
"options": ["Prometheus", "Loki", "node_exporter", "cadvisor"],
"correct": 1
},
{
"text": "Что проверяет readiness probe в Kubernetes?",
"options": ["Живо ли приложение", "Готово ли приложение принимать трафик", "Сколько памяти использует приложение", "Есть ли ошибки в логах"],
"correct": 1
},
{
"text": "Какой язык запросов используется в Prometheus?",
"options": ["SQL", "LogQL", "PromQL", "Elasticsearch DSL"],
"correct": 2
},
{
"text": "Почему важно избегать 'alert fatigue'?",
"options": ["Это замедляет Grafana", "Команда игнорирует важные алерты", "Это увеличивает стоимость хранения", "Это ломает Prometheus"],
"correct": 1
},
{
"text": "Какой компонент Kubernetes предоставляет метрики о подах и нодах?",
"options": ["kube-proxy", "kubelet", "kube-state-metrics", "coredns"],
"correct": 2
},
{
"text": "Что такое дашборд в Grafana?",
"options": ["Сервер для хранения логов", "Коллекция визуализаций на одной странице", "Правило для алертов", "Экспортёр метрик"],
"correct": 1
},
{
"text": "Какой формат логов предпочтительнее для автоматического анализа?",
"options": ["Plain text", "XML", "JSON", "CSV"],
"correct": 2
},
{
"text": "Какой минимальный полезный алерт вы бы настроили для веб-сервиса?",
"options": ["CPU > 50%", "Доступность /health = false", "Количество логов > 1000/мин", "Изменение версии образа"],
"correct": 1
}
]
}
]
}